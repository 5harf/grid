(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
angular.module('riq-grid', [
  require('./angular-decorator').name
])
  .factory('RiqGridSrvc', function () {
    return {
      core: require('./core')
    };
  })
;


},{"./angular-decorator":13,"./core":21}],2:[function(require,module,exports){
module.exports = function (string) {
  return string.charAt(0).toUpperCase() + string.substring(1);
}

module.exports.words = function (string) {
  return string.replace(/(^|\W)(\w)/g, function (m) {
    return m.toUpperCase()
  })
}

},{}],3:[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (classes.indexOf(className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = classes.indexOf(className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return classes.indexOf(className) > -1
}

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var alnum, ref;

  ref = require('../ref').ref;

  alnum = {
    '0': ref('0', 48),
    '1': ref('1', 49),
    '2': ref('2', 50),
    '3': ref('3', 51),
    '4': ref('4', 52),
    '5': ref('5', 53),
    '6': ref('6', 54),
    '7': ref('7', 55),
    '8': ref('8', 56),
    '9': ref('9', 57),
    a: ref('A', 65),
    b: ref('B', 66),
    c: ref('C', 67),
    d: ref('D', 68),
    e: ref('E', 69),
    f: ref('F', 70),
    g: ref('G', 71),
    h: ref('H', 72),
    i: ref('I', 73),
    j: ref('J', 74),
    k: ref('K', 75),
    l: ref('L', 76),
    m: ref('M', 77),
    n: ref('N', 78),
    o: ref('O', 79),
    p: ref('P', 80),
    q: ref('Q', 81),
    r: ref('R', 82),
    s: ref('S', 83),
    t: ref('T', 84),
    u: ref('U', 85),
    v: ref('V', 86),
    w: ref('W', 87),
    x: ref('X', 88),
    y: ref('Y', 89),
    z: ref('Z', 90)
  };

  module.exports = alnum;

}).call(this);

},{"../ref":10}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var arrow, ref;

  ref = require('../ref').ref;

  arrow = {
    left: ref('Left', 37),
    up: ref('Up', 38),
    right: ref('Right', 39),
    down: ref('Down', 40)
  };

  module.exports = arrow;

}).call(this);

},{"../ref":10}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var brand, ref;

  ref = require('../ref').ref;

  brand = {
    apple: ref('Apple &#8984;', 224),
    windows: {
      start: ref('Windows start', [91, 92]),
      menu: ref('Windows menu', 93)
    }
  };

  module.exports = brand;

}).call(this);

},{"../ref":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var punctuation, ref;

  ref = require('../ref').ref;

  punctuation = {
    colon: ref('Colon/Semicolon', [59, 186]),
    equal: ref('Equal/Plus', [61, 187]),
    comma: ref('Comma/Less Than', [44, 188]),
    hyphen: ref('Hyphen/Underscore', [45, 109, 189]),
    period: ref('Period/Greater Than', [46, 190]),
    tilde: ref('Tilde/Back Tick', [96, 192]),
    apostrophe: ref('Apostrophe/Quote', [39, 222]),
    slash: {
      forward: ref('Forward Slash/Question Mark', [47, 191]),
      backward: ref('Backward Slash/Pipe', 220)
    },
    brace: {
      square: {
        open: ref('Open Square/Curly Brace', 219),
        close: ref('Close Square/Curly Brace', 221)
      }
    }
  };

  punctuation.semicolon = punctuation.colon;

  punctuation.plus = punctuation.equal;

  punctuation.lessthan = punctuation.comma;

  punctuation.underscore = punctuation.hyphen;

  punctuation.greaterthan = punctuation.period;

  punctuation.question = punctuation.slash.forward;

  punctuation.backtick = punctuation.tilde;

  punctuation.pipe = punctuation.slash.backward;

  punctuation.quote = punctuation.apostrophe;

  punctuation.brace.curly = punctuation.brace.square;

  module.exports = punctuation;

}).call(this);

},{"../ref":10}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var ref, special;

  ref = require('../ref').ref;

  special = {
    backspace: ref('Backspace', 8),
    tab: ref('Tab', 9),
    enter: ref('Enter', 13),
    shift: ref('Shift', 16),
    ctrl: ref('Ctrl', 17),
    alt: ref('Alt', 18),
    caps: ref('Caps Lock', 20),
    esc: ref('Escape', 27),
    space: ref('Space', 32),
    num: ref('Num Lock', 144)
  };

  module.exports = special;

}).call(this);

},{"../ref":10}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var isRef, iterator, key,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  isRef = require('./ref').isRef;

  key = {};

  key.code = {
    special: require('./code/special'),
    arrow: require('./code/arrow'),
    punctuation: require('./code/punctuation'),
    alnum: require('./code/alnum'),
    brand: require('./code/brand')
  };

  key.get = function(pressed) {
    return iterator(key.code, pressed);
  };

  key.is = function(ref, pressed) {
    if (!isRef(ref)) {
      ref = iterator(ref, pressed);
    }
    if (isRef(ref)) {
      if (isRef(pressed)) {
        return pressed === ref;
      } else {
        return pressed === ref.code || __indexOf.call(ref.code, pressed) >= 0;
      }
    } else {
      return pressed === ref;
    }
  };

  iterator = function(context, pressed) {
    var i, out, ref;
    for (i in context) {
      if (!__hasProp.call(context, i)) continue;
      ref = context[i];
      if (isRef(ref)) {
        if (key.is(ref, pressed)) {
          return ref;
        }
      } else {
        out = iterator(ref, pressed);
        if (isRef(out)) {
          return out;
        }
      }
    }
  };

  if (typeof window !== 'undefined') {
    window.key = key;
  }

  module.exports = key;

}).call(this);

},{"./code/alnum":4,"./code/arrow":5,"./code/brand":6,"./code/punctuation":7,"./code/special":8,"./ref":10}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Reference, assertRef, isRef, ref;

  Reference = (function() {

    function Reference(name, code) {
      this.name = name;
      this.code = code;
    }

    return Reference;

  })();

  ref = function(name, code) {
    return new Reference(name, code);
  };

  isRef = function(ref) {
    return ref instanceof Reference;
  };

  assertRef = function(ref) {
    if (!isRef(ref)) {
      throw new Error('Invalid reference');
    }
    return ref;
  };

  module.exports = {
    ref: ref,
    isRef: isRef,
    assertRef: assertRef
  };

}).call(this);

},{}],11:[function(require,module,exports){
var addDirtyProps = require('../add-dirty-props');
var util = require('../util');
var noop = require('../no-op');
var passThrough = require('../pass-through');

module.exports = function (_grid, name, lengthName, defaultSize) {
    var grid = _grid;

    var descriptors = [];
    var numFixed = 0;
    var numHeaders = 0;
    var makeDirtyClean = require('../dirty-clean');
    var dirtyClean = makeDirtyClean(grid);
    var builderDirtyClean = makeDirtyClean(grid);
    var selected = [];

    function setDescriptorsDirty(eventOptional) {
        var event = eventOptional || {};
        event.type = 'grid-' + name + '-change';
        grid.eventLoop.fire(event);
        dirtyClean.setDirty();
        builderDirtyClean.setDirty();
    }

    function fireSelectionChange() {
        grid.eventLoop.fire('grid-' + name + '-selection-change');
    }

    function updateDescriptorIndices() {
        descriptors.forEach(function (descriptor, i) {
            descriptor.index = i;
        });
    }

    var api = {
        areBuildersDirty: builderDirtyClean.isDirty,
        isDirty: dirtyClean.isDirty,
        defaultSize: defaultSize,
        add: function (toAdd) {
            if (!util.isArray(toAdd)) {
                toAdd = [toAdd];
            }
            toAdd.forEach(function (descriptor) {
                if (descriptor.header) {
                    descriptors.splice(numHeaders, 0, descriptor);
                    numFixed++;
                    numHeaders++;
                }

                else {
                    //if the column is fixed and the last one added is fixed (we only allow fixed at the beginning for now)
                    if (descriptor.fixed) {
                        if (!descriptors.length || descriptors[descriptors.length - 1].fixed) {
                            numFixed++;
                        } else {
                            throw 'Cannot add a fixed column after an unfixed one';
                        }
                    }
                    descriptors.push(descriptor);
                }
            });
            updateDescriptorIndices();
            setDescriptorsDirty({action: 'add', descriptors: toAdd});
        },
        addHeaders: function (toAdd) {
            if (!util.isArray(toAdd)) {
                toAdd = [toAdd];
            }
            toAdd.forEach(function (header) {
                header.header = true;
            });
            api.add(toAdd);
        },
        header: function (index) {
            return descriptors[index];
        },
        get: function (index) {
            return descriptors[index];
        },
        length: function (includeHeaders) {
            var subtract = includeHeaders ? 0 : numHeaders;
            return descriptors.length - subtract;
        },
        remove: function (descriptor, dontUpdateIndex) {
            var index = descriptors.indexOf(descriptor);
            if (index !== -1) {
                descriptors.splice(index, 1);
                if (descriptor.header) {
                    numFixed--;
                    numHeaders--;
                } else if (descriptor.fixed) {
                    numFixed--;
                }
            }
            if (!dontUpdateIndex) {
                updateDescriptorIndices();
            }
        },
        clear: function (includeHeaders) {
            descriptors.slice(0).forEach(function (descriptor) {
                if (includeHeaders || !descriptor.header) {
                    api.remove(descriptor, true);
                }
            });
        },
        move: function (start, target) {
            descriptors.splice(target, 0, descriptors.splice(start, 1)[0]);
            updateDescriptorIndices();
            setDescriptorsDirty({action: 'move', descriptors: [api.get(start), api.get(target)]});
        },
        numHeaders: function () {
            return numHeaders;
        },
        numFixed: function () {
            return numFixed;
        },
        toVirtual: function (dataIndex) {
            return dataIndex + api.numHeaders();
        },
        toData: function (virtualIndex) {
            return virtualIndex - api.numHeaders();
        },

        select: function (index) {

            var descriptor = api[name](index);
            if (!descriptor.selected) {
                descriptor.selected = true;
                selected.push(index);
                fireSelectionChange();
            }
        },
        deselect: function (index, dontNotify) {
            var descriptor = api[name](index);
            if (descriptor.selected) {
                descriptor.selected = false;
                selected.splice(selected.indexOf(index), 1);
                if (!dontNotify) {
                    fireSelectionChange();
                }
            }
        },
        toggleSelect: function (index) {
            var descriptor = api[name](index);
            if (descriptor.selected) {
                api.deselect(index);
            } else {
                api.select(index);
            }
        },
        clearSelected: function () {
            var length = selected.length;
            selected.slice(0).forEach(function (index) {
                api.deselect(index, true);
            });
            if (length) {
                fireSelectionChange();
            }
        },
        getSelected: function () {
            return selected;
        },
        create: function (builder) {
            var descriptor = {};
            var fixed = false;
            Object.defineProperty(descriptor, 'fixed', {
                enumerable: true,
                get: function () {
                    return descriptor.header || fixed;
                },
                set: function (_fixed) {
                    fixed = _fixed;
                }
            });
//
//            Object.defineProperty(descriptor, 'index', {
//                enumerable: true,
//                get: function () {
//                    return descriptors.indexOf(descriptor);
//                }
//            });

            addDirtyProps(descriptor, ['builder'], [builderDirtyClean]);
            descriptor.builder = builder;

            return addDirtyProps(descriptor, [
                {
                    name: lengthName,
                    onDirty: function () {
                        setDescriptorsDirty({action: 'size', descriptors: [descriptor]});
                    }
                },
                {
                    name: 'hidden',
                    onDirty: function () {
                        setDescriptorsDirty({action: 'hide', descriptors: [descriptor]});
                    }
                }
            ], [dirtyClean]);
        },
        createBuilder: function (render, update) {
            return {render: render || noop, update: update || passThrough};
        }

    };

    //basically height or width
    api[lengthName] = function (index) {
        var descriptor = descriptors[index];
        if (!descriptor) {
            return NaN;
        }


        if (descriptor.hidden) {
            return 0;
        }

        return descriptor[lengthName] || api.defaultSize;
    };

    //row or col get
    api[name] = function (index) {
        return descriptors[index + numHeaders];
    };

    return api;
};
},{"../add-dirty-props":12,"../dirty-clean":26,"../no-op":32,"../pass-through":33,"../util":40}],12:[function(require,module,exports){
module.exports = function (obj, props, dirtyCleans) {
    props.forEach(function (prop) {
        var val;
        var name = prop.name || prop;
        Object.defineProperty(obj, name, {
            enumerable: true,
            get: function () {
                return val;
            }, set: function (_val) {
                var isChanged = _val !== val;
                
                val = _val;

                if (isChanged) {
                    dirtyCleans.forEach(function (dirtyClean) {
                        dirtyClean.setDirty();
                    });
                    if (prop.onDirty) {
                        prop.onDirty();
                    }
                }
            }
        });
    });
    return obj;
};
},{}],13:[function(require,module,exports){
module.exports = angular.module('grid-decorator', [])
    .factory('GridDecoratorSrvc', function ($compile) {
        var GridDecoratorSrvc = {
            render: function (opts) {
                var compiled = $compile(opts.template)(opts.$scope);
                compiled.on('decorator-destroy', function () {
                    opts.$scope.$destroy();
                    //unbind in a timeout to allow any other listeners to fire first
                    setTimeout(function () {
                        compiled.off('decorator-destroy');
                    }, 1);
                });
                opts.$scope.$apply();
                if (opts.events) {
                    compiled[0].style.pointerEvents = 'all';
                }
                return compiled[0];
            },
            headerDecorators: function (grid, model) {
                var origAnnotate = model.annotateDecorator;
                model.annotateDecorator = function (dec) {
                    dec.render = function () {
                        return GridDecoratorSrvc.render(dec.renderOpts);
                    };
                    if (origAnnotate) {
                        origAnnotate(dec);
                    }
                };

                require('../header-decorators')(grid, model);
            }
        };
        return GridDecoratorSrvc
    })

;
},{"../header-decorators":28}],14:[function(require,module,exports){
var positionRange = require('../position-range');
var makeDirtyClean = require('../dirty-clean');
var addDirtyProps = require('../add-dirty-props');

module.exports = function (_grid) {
    var grid = _grid;

    var dirtyClean = makeDirtyClean(grid);
    var descriptors = [];

    var api = {
        add: function (descriptor) {
            descriptors.push(descriptor);
            dirtyClean.setDirty();
        },
        remove: function (descriptor) {
            descriptors.splice(descriptors.indexOf(descriptor), 1);
            dirtyClean.setDirty();
        },
        getAll: function () {
            return descriptors.slice(0);
        },
        create: function (top, left, className, height, width, space) {
            var thisDirtyClean = makeDirtyClean(grid);
            var descriptor = {};
            //mixins
            positionRange(descriptor, thisDirtyClean, dirtyClean);
            addDirtyProps(descriptor, ['class'], [thisDirtyClean, dirtyClean]);

            //all of these are optional
            descriptor.top = top;
            descriptor.left = left;
            //default to single cell ranges
            descriptor.height = height || 1;
            descriptor.width = width || 1;
            descriptor.class = className;
            descriptor.space = space || descriptor.space;
            return descriptor;
        },
        isDirty: dirtyClean.isDirty
    };


    return api;
};
},{"../add-dirty-props":12,"../dirty-clean":26,"../position-range":35}],15:[function(require,module,exports){
var customEvent = require('../custom-event');

var PROPS_TO_COPY_FROM_MOUSE_EVENTS = ['clientX', 'clientY', 'gridX', 'gridY', 'layerX', 'layerY', 'row', 'col', 'realRow', 'realCol'];


module.exports = function (_grid) {
    var grid = _grid;

    var model = {};

    var wasDragged = false;

    model._annotateEvent = function annotateEvent(e) {
        switch (e.type) {
            case 'click':
                e.wasDragged = wasDragged;
            /* jshint -W086 */
            case 'mousedown':
            /* jshint +W086 */
            case 'mousemove':
            case 'mouseup':
            case 'dblclick':
                model._annotateEventInternal(e);
                break;

        }
    };

    model._annotateEventFromViewCoords = function (e, viewRow, viewCol) {
        e.realRow = viewRow;
        e.realCol = viewCol;
        e.virtualRow = grid.viewPort.toVirtualRow(e.realRow);
        e.virtualCol = grid.viewPort.toVirtualCol(e.realCol);
        e.row = e.virtualRow - grid.rowModel.numHeaders();
        e.col = e.virtualCol - grid.colModel.numHeaders();
    }

    model._annotateEventInternal = function (e) {
        var y = grid.viewPort.toGridY(e.clientY);
        var x = grid.viewPort.toGridX(e.clientX);
        var viewRow = grid.viewPort.getRowByTop(y);
        var viewCol = grid.viewPort.getColByLeft(x);
        model._annotateEventFromViewCoords(e, viewRow, viewCol);
        e.gridX = x;
        e.gridY = y;
    };

    grid.eventLoop.addInterceptor(function (e) {
        model._annotateEvent(e);

        if (e.type === 'mousedown') {
            setupDragEventForMouseDown(e);
        }
    });

    function setupDragEventForMouseDown(downEvent) {
        wasDragged = false;
        var lastDragRow = downEvent.row;
        var lastDragCol = downEvent.col;
        var dragStarted = false;
        var unbindMove = grid.eventLoop.bind('mousemove', window, function (e) {
            if (dragStarted && !e.which) {
                //got a move event without mouse down which means we somehow missed the mouseup
                console.log('mousemove unbind, how on earth do these happen?');
                handleMouseUp(e);
                return;
            }

            if (!dragStarted) {
                wasDragged = true;
                createAndFireDragEvent('grid-drag-start', downEvent);
                dragStarted = true;
            }

            createAndFireDragEvent('grid-drag', e);

            if (e.row !== lastDragRow || e.col !== lastDragCol) {
                createAndFireDragEvent('grid-cell-drag', e);

                lastDragRow = e.row;
                lastDragCol = e.col;
            }

        });

        var unbindUp = grid.eventLoop.bind('mouseup', window, handleMouseUp);

        function handleMouseUp(e) {
            unbindMove();
            unbindUp();

            var dragEnd = createDragEventFromMouseEvent('grid-drag-end', e);

            //row, col, x, and y should inherit
            grid.eventLoop.fire(dragEnd);
        }
    }

    function createDragEventFromMouseEvent(type, e) {
        var event = customEvent(type, true, true);
        PROPS_TO_COPY_FROM_MOUSE_EVENTS.forEach(function (prop) {
            event[prop] = e[prop];
        });
        event.originalEvent = e;
        return event;
    }

    function createAndFireDragEvent(type, e) {
        var drag = createDragEventFromMouseEvent(type, e);
        if (e.target) {
            e.target.dispatchEvent(drag);
        } else {
            grid.eventLoop.fire(drag);
        }
        return drag;
    }

    return model;
};
},{"../custom-event":23}],16:[function(require,module,exports){
var util = require('../util');

module.exports = function (_grid) {
    var grid = _grid;
    var dirtyClean = require('../dirty-clean')(grid);


    var row;
    var model = {col: 0};
    Object.defineProperty(model, 'row', {
        enumerable: true,
        get: function () {
            return row;
        },
        set: function (r) {
            row = r;
        }
    });
    model.row = 0;

    model.isDirty = dirtyClean.isDirty;

    model.scrollTo = function (r, c, dontFire, fromPixelModel) {
        if (isNaN(r) || isNaN(c)) {
            return;
        }
        var maxRow = (grid.rowModel.length() || 1) - 1;
        var maxCol = (grid.colModel.length() || 1) - 1;
        var lastRow = model.row;
        var lastCol = model.col;
        model.row = util.clamp(r, 0, maxRow);
        model.col = util.clamp(c, 0, maxCol);
        if (lastRow !== model.row || lastCol !== model.col) {
            dirtyClean.setDirty();

            if (!dontFire) {
                grid.eventLoop.fire('grid-cell-scroll');
            }

            if (!fromPixelModel) {
                var top = grid.virtualPixelCellModel.height(0, model.row - 1);
                var left = grid.virtualPixelCellModel.width(0, model.col - 1);
                grid.pixelScrollModel.scrollTo(top, left, true);
            }
        }
    };

    function convertVirtualToScroll(virtualCoord, rowOrCol) {
        return virtualCoord - grid[rowOrCol + 'Model'].numFixed();
    }

    function getScrollToRowOrCol(virtualCoord, rowOrCol, heightWidth) {
        var currentScroll = model[rowOrCol];
        var scrollTo = currentScroll;
        if (grid.viewPort[rowOrCol + 'IsInView'](virtualCoord)) {
            return scrollTo;
        }

        var targetScroll = convertVirtualToScroll(virtualCoord, rowOrCol);
        if (targetScroll < currentScroll) {
            scrollTo = targetScroll;
        } else if (targetScroll > currentScroll) {

            var lengthToCell = grid.virtualPixelCellModel[heightWidth](0, virtualCoord);
            var numFixed = grid[rowOrCol + 'Model'].numFixed();
            scrollTo = 0;
            for (var i = numFixed; i < virtualCoord; i++) {
                lengthToCell -= grid.virtualPixelCellModel[heightWidth](i);
                scrollTo = i - (numFixed - 1);
                if (lengthToCell <= grid.viewPort[heightWidth]) {
                    break;
                }
            }
        }

        return scrollTo;
    }

    model.scrollIntoView = function (vr, vc) {
        vr = grid.virtualPixelCellModel.clampRow(vr);
        vc = grid.virtualPixelCellModel.clampCol(vc);
        var newRow = getScrollToRowOrCol(vr, 'row', 'height');
        var newCol = getScrollToRowOrCol(vc, 'col', 'width');
        model.scrollTo(newRow, newCol);
    };


    return model;
};
},{"../dirty-clean":26,"../util":40}],17:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = require('../abstract-row-col-model')(grid, 'col', 'width', 100);

    return api;
};
},{"../abstract-row-col-model":11}],18:[function(require,module,exports){
var elementClass = require('element-class');
var util = require('../util');


module.exports = function (_grid) {
    var grid = _grid;

    var api = {annotateDecorator: makeReorderDecorator};

    function makeReorderDecorator(headerDecorator) {
        var col = headerDecorator.left;
        headerDecorator._dragRect = grid.decorators.create(0, undefined, Infinity, undefined, 'px', 'real');

        headerDecorator._dragRect.postRender = function (div) {
            div.setAttribute('class', 'grid-drag-rect');
        };

        headerDecorator._onDragStart = function (e) {
            if (e.realCol < grid.colModel.numFixed()) {
                return;
            }


            grid.decorators.add(headerDecorator._dragRect);

            headerDecorator._dragRect.width = grid.viewPort.getColWidth(col);
            var colOffset = e.gridX - headerDecorator.getDecoratorLeft();

            headerDecorator._dragRect._targetCol = grid.decorators.create(0, undefined, Infinity, 1, 'cell', 'real');
            headerDecorator._dragRect._targetCol.postRender = function (div) {
                div.setAttribute('class', 'grid-reorder-target');
                headerDecorator._dragRect._targetCol._renderedElem = div;
            };
            grid.decorators.add(headerDecorator._dragRect._targetCol);

            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (e) {
                headerDecorator._dragRect.left = util.clamp(e.gridX - colOffset, grid.viewPort.getColLeft(grid.colModel.numFixed()), Infinity);
                headerDecorator._dragRect._targetCol.left = util.clamp(e.realCol, grid.colModel.numFixed(), Infinity);
                if (e.realCol > col) {
                    elementClass(headerDecorator._dragRect._targetCol._renderedElem).add('right');
                } else {
                    elementClass(headerDecorator._dragRect._targetCol._renderedElem).remove('right');
                }


            });

            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function (e) {
                var targetCol = headerDecorator._dragRect._targetCol.left;

                grid.colModel.move(grid.viewPort.toVirtualCol(col), grid.viewPort.toVirtualCol(targetCol));
                grid.decorators.remove([headerDecorator._dragRect._targetCol, headerDecorator._dragRect]);
                headerDecorator._unbindDrag();
                headerDecorator._unbindDragEnd();
            });
        };

        headerDecorator.postRender = function (div) {
            div.setAttribute('class', 'grid-col-reorder');
            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);
        };

        return headerDecorator;
    }

    require('../header-decorators')(grid, api);

    return api;
};
},{"../header-decorators":28,"../util":40,"element-class":3}],19:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = {annotateDecorator: annotateDecorator};

    function annotateDecorator(headerDecorator) {
        var col = headerDecorator.left;
        headerDecorator._dragLine = grid.decorators.create(0, undefined, Infinity, 1, 'px', 'real');

        headerDecorator._dragLine.postRender = function (div) {
            div.setAttribute('class', 'grid-drag-line');
        };

        headerDecorator._onDragStart = function (e) {

            grid.decorators.add(headerDecorator._dragLine);

            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (e) {
                var minX = headerDecorator.getDecoratorLeft() + 10;
                headerDecorator._dragLine.left = Math.max(e.gridX, minX);
            });

            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function (e) {
                grid.colModel.get(grid.viewPort.toVirtualCol(col)).width = headerDecorator._dragLine.left - headerDecorator.getDecoratorLeft();
                grid.decorators.remove(headerDecorator._dragLine);
                headerDecorator._unbindDrag();
                headerDecorator._unbindDragEnd();
            });
        };

        headerDecorator.postRender = function (div) {
            div.style.transform = 'translateX(50%)';
            div.style.webkitTransform = 'translateX(50%)';

            div.style.removeProperty('left');
            div.setAttribute('class', 'col-resize');

            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);
        };
    }

    require('../header-decorators')(grid, api);

    return api;
};
},{"../header-decorators":28}],20:[function(require,module,exports){
var ctrlOrCmd = require('../ctrl-or-cmd');

module.exports = function (_grid) {
    var grid = _grid;
    grid.eventLoop.bind('keydown', function (e) {
        switch (e.type) {
            case 'keydown':
                if (ctrlOrCmd(e)) {
                    if (key.is(key.code.alnum.c, e.which)) {
                        //prepare for copy
                        var copyData = [];
                        var selectionRange = grid.navigationModel.selection;
                        //valid selection range cannot go to -1
                        if (selectionRange.top === -1) {
                            selectionRange = {
                                top: grid.navigationModel.focus.row,
                                left: grid.navigationModel.focus.col,
                                width: 1,
                                height: 1
                            };
                        }
                        for (var r = selectionRange.top; r <= selectionRange.top + selectionRange.height; r++) {
                            var row = [];
                            copyData.push(row)
                            for (var c = selectionRange.left; c <= selectionRange.left + selectionRange.width; c++) {
                                row.push(grid.dataModel.getCopyData(r, c));
                            }
                        }
                    }
                }
                break;
        }
    });
};
},{"../ctrl-or-cmd":22}],21:[function(require,module,exports){
var elementClass = require('element-class');
var dirtyClean = require('../dirty-clean');

module.exports = function () {

    var grid = {};

    //the order here matters because some of these depend on each other
    grid.eventLoop = require('../event-loop')(grid);
    grid.decorators = require('../decorators')(grid);
    grid.cellClasses = require('../cell-classes')(grid);
    grid.rowModel = require('../row-model')(grid);
    grid.colModel = require('../col-model')(grid);
    grid.dataModel = require('../simple-data-model')(grid);
    grid.virtualPixelCellModel = require('../virtual-pixel-cell-model')(grid);
    grid.cellScrollModel = require('../cell-scroll-model')(grid);
    grid.cellMouseModel = require('../cell-mouse-model')(grid);

    grid.viewPort = require('../view-port')(grid);
    grid.viewLayer = require('../view-layer')(grid);

    //things with logic that also register decorators (slightly less core than the other models)
    grid.navigationModel = require('../navigation-model')(grid);
    grid.pixelScrollModel = require('../pixel-scroll-model')(grid);
    grid.colResize = require('../col-resize')(grid);
    grid.colReorder = require('../col-reorder')(grid);
    grid.showHiddenCols = require('../show-hidden-cols')(grid);
    require('../copy-paste')(grid);

    var drawRequested = false;
    grid.requestDraw = function () {
        if (!grid.eventLoop.isRunning) {
            grid.viewLayer.draw();
        } else {
            drawRequested = true;
        }
    };

    grid.eventLoop.bind('grid-draw', function () {
        drawRequested = false;
    });

    grid.eventLoop.addExitListener(function () {
        if (drawRequested) {
            grid.viewLayer.draw();
        }
    });

    function createFocusTextArea(container) {
        var textarea = document.createElement('textarea');
        textarea.setAttribute('dts', 'grid-textarea');
        textarea.style.position = 'fixed';
        textarea.style.left = '-100000px';
        textarea.addEventListener('focus', function () {
            if (container) {
                elementClass(container).add('focus');
            }
            textarea.select();
        });

        textarea.addEventListener('blur', function () {
            if (container) {
                elementClass(container).remove('focus');
            }
        });

        container.appendChild(textarea);
        if (!container.getAttribute('tabIndex')) {
            container.tabIndex = -1;
        }
        container.addEventListener('focus', function () {
            if (textarea) {
                textarea.focus();
            }
        });

        return textarea;
    }

    grid.build = function (container) {
        grid.textarea = createFocusTextArea(container);
        grid.viewPort.sizeToContainer(container);
        grid.viewLayer.build(container);
        grid.eventLoop.setContainer(container);
    };

    grid.makeDirtyClean = function () {
        return dirtyClean(grid);
    };

    return grid;
};
},{"../cell-classes":14,"../cell-mouse-model":15,"../cell-scroll-model":16,"../col-model":17,"../col-reorder":18,"../col-resize":19,"../copy-paste":20,"../decorators":25,"../dirty-clean":26,"../event-loop":27,"../navigation-model":31,"../pixel-scroll-model":34,"../row-model":37,"../show-hidden-cols":38,"../simple-data-model":39,"../view-layer":41,"../view-port":42,"../virtual-pixel-cell-model":43,"element-class":3}],22:[function(require,module,exports){
module.exports = function (e) {
    return (window.navigator.userAgent.match(/win/i) ? e.ctrlKey : e.metaKey)
};
},{}],23:[function(require,module,exports){
module.exports = function (name, bubbles, cancelable, detail) {
    var event = document.createEvent('CustomEvent');  // MUST be 'CustomEvent'
    event.initCustomEvent(name, bubbles, cancelable, detail);
    return event;
};
},{}],24:[function(require,module,exports){
module.exports = function (fn, delay) {
    var f = function debounced() {
        if (f.timeout) {
            clearTimeout(f.timeout);
            f.timeout = undefined;
        }
        f.timeout = setTimeout(fn, delay);
    };
    return f;
};
},{}],25:[function(require,module,exports){
var util = require('../util');
var makeDirtyClean = require('../dirty-clean');
var positionRange = require('../position-range');

module.exports = function (_grid) {
    var grid = _grid;

    var dirtyClean = makeDirtyClean(grid);

    var aliveDecorators = [];
    var deadDecorators = [];

    var decorators = {
        add: function (decorator) {
            aliveDecorators.push(decorator);
            dirtyClean.setDirty();
        },
        remove: function (decorators) {
            if (!util.isArray(decorators)) {
                decorators = [decorators];
            }
            decorators.forEach(function (decorator) {
                var index = aliveDecorators.indexOf(decorator);
                if (index !== -1) {
                    aliveDecorators.splice(index, 1);
                    deadDecorators.push(decorator);
                    dirtyClean.setDirty();
                }
            });
        },
        getAlive: function () {
            return aliveDecorators.slice(0);
        },
        popAllDead: function () {
            var oldDead = deadDecorators;
            deadDecorators = [];
            return oldDead;
        },
        isDirty: dirtyClean.isDirty,
        create: function (t, l, h, w, u, s) {
            var decorator = {};
            var thisDirtyClean = makeDirtyClean(grid);

            //mixin the position range functionality
            positionRange(decorator, thisDirtyClean, dirtyClean);
            decorator.top = t;
            decorator.left = l;
            decorator.height = h;
            decorator.width = w;
            decorator.units = u || decorator.units;
            decorator.space = s || decorator.space;

            //they can override but we should have an empty default to prevent npes
            decorator.render = function () {
                var div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.top = '0px';
                div.style.left = '0px';
                div.style.bottom = '0px';
                div.style.right = '0px';
                if (decorator.postRender) {
                    decorator.postRender(div);
                }
                return div;
            };
            return decorator;

        }

    };


    return decorators;
};
},{"../dirty-clean":26,"../position-range":35,"../util":40}],26:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;
    var dirty = true;

    grid.eventLoop.bind('grid-draw', function () {
        api.setClean();
    });


    var api = {
        isDirty: function () {
            return dirty;
        },
        isClean: function () {
            return !dirty;
        },
        setDirty: function () {
            dirty = true;
            //when things are initalizing sometimes this doesn't exist yet
            //we have to hope that at the end of initialization the grid will call request draw itself
            if (grid.requestDraw) {
                grid.requestDraw();
            }
        },
        setClean: function () {
            dirty = false;
        }
    };
    return api;
};
},{}],27:[function(require,module,exports){
var mousewheel = require('../mousewheel');
var util = require('../util');
var listeners = require('../listeners');

var EVENTS = ['click', 'mousedown', 'mouseup', 'mousemove', 'dblclick', 'keydown', 'keypress', 'keyup'];

var GRID_EVENTS = ['grid-drag-start', 'grid-drag', 'grid-cell-drag', 'grid-drag-end'];

var eventLoop = function (_grid) {
    var grid = _grid;
    var eloop = {
        isRunning: false
    };

    var handlersByName = {};
    var domUnbindFns = [];

    var unbindAll;

    eloop.setContainer = function (container) {
        var unbindMouseWheelFn = mousewheel.bind(container, mainLoop);

        EVENTS.forEach(function (name) {
            bindToDomElement(container, name, mainLoop);
        });

        GRID_EVENTS.forEach(function (name) {
            bindToDomElement(window, name, mainLoop);
        });

        unbindAll = function () {
            unbindMouseWheelFn();

            //have to copy the array since the unbind will actually remove itself from the array which modifies it mid iteration
            domUnbindFns.slice(0).forEach(function (unbind) {
                unbind();
            });
        };
    };

    function getHandlers(name) {
        var handlers = handlersByName[name];
        if (!handlers) {
            handlers = handlersByName[name] = [];
        }
        return handlers;
    }

    function bindToDomElement(elem, name, listener) {
        elem.addEventListener(name, listener);
        var unbindFn = function () {
            elem.removeEventListener(name, listener);
            domUnbindFns.splice(domUnbindFns.indexOf(unbindFn), 1);
        };
        domUnbindFns.push(unbindFn);
        return unbindFn;
    }

    function getHandlerFromArgs(args) {
        var handler = args.filter(function (arg) {
            return typeof arg === 'function';
        })[0];
        return handler;
    }

    eloop.bind = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        var name = args.filter(function (arg) {
            return typeof arg === 'string';
        })[0];
        var handler = getHandlerFromArgs(args);
        if (!handler || !name) {
            throw 'cannot bind without at least name and function';
        }


        var elem = args.filter(function (arg) {
            return util.isElement(arg) || arg === window || arg === document;
        })[0];

        if (!elem) {
            getHandlers(name).push(handler);
            return function () {
                var handlers = getHandlers(name);
                handlers.splice(handlers.indexOf(handler), 1);
            };
        } else {
            var listener = loopWith(handler);
            //make sure the elem can receive events
            if (elem.style) {
                elem.style.pointerEvents = 'all';
            }
            return bindToDomElement(elem, name, listener);
        }
    };

    eloop.bindOnce = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        var handler = getHandlerFromArgs(args);
        args.splice(args.indexOf(handler), 1, function bindOnceHandler(e) {
            unbind();
            handler(e);
        });
        var unbind = eloop.bind.apply(this, args);
        return unbind;
    }

    eloop.fire = function (event) {
        event = typeof event === 'string' ? {type: event} : event;
        mainLoop(event);
    };

    var interceptors = listeners();
    var exitListeners = listeners();

    eloop.addInterceptor = interceptors.addListener;
    eloop.addExitListener = exitListeners.addListener;

    function loopWith(fn) {
        return function (e) {
            loop(e, fn);
        };
    }

    var mainLoop = loopWith(function (e) {
        //have to copy the array because handlers can unbind themselves which modifies the array
        //we use some so that we can break out of the loop if need be
        getHandlers(e.type).slice(0).some(function (handler) {
            handler(e);
            if (e.gridStopBubbling) {
                return true;
            }
        });
    });

    function loop(e, bodyFn) {
        var isOuterLoopRunning = eloop.isRunning;
        eloop.isRunning = true;
        interceptors.notify(e);
        if (!e.gridStopBubbling) {
            bodyFn(e);
        }

        if (!isOuterLoopRunning) {
            eloop.isRunning = false;
            exitListeners.notify(e);
        }
    }

    eloop.bind('grid-destroy', function () {
        unbindAll();
        eloop.destroyed = true;
    });

    eloop.stopBubbling = function (e) {
        e.gridStopBubbling = true;
        return e;
    };

    return eloop;
};


eventLoop.EVENTS = EVENTS;
eventLoop.GRID_EVENTS = GRID_EVENTS;
module.exports = eventLoop;
},{"../listeners":29,"../mousewheel":30,"../util":40}],28:[function(require,module,exports){
module.exports = function (_grid, model) {
    var grid = _grid;

    var api = model || {};
    api._decorators = {};

    function makeDecorator(col) {
        var decorator = grid.decorators.create(0, col, 1, 1, 'cell', 'real');


        decorator.getDecoratorLeft = function () {
            var firstRect = decorator.boundingBox && decorator.boundingBox.getClientRects() && decorator.boundingBox.getClientRects()[0] || {};
            return grid.viewPort.toGridX(firstRect.left) || 0;
        };

        if (api.annotateDecorator) {
            api.annotateDecorator(decorator);
        }


        return decorator;
    }

    api.makeDecorator = api.makeDecorator || makeDecorator;

    function ensureDecoratorPerCol() {
        for (var c = 0; c < grid.viewPort.cols; c++) {
            if (!api._decorators[c]) {
                if (api.isNeeded && !api.isNeeded(c)) {
                    continue;
                }
                var decorator = api.makeDecorator(c);
                api._decorators[c] = decorator;
                grid.decorators.add(decorator);
            }
        }
    }

    grid.eventLoop.bind('grid-viewport-change', function () {
        ensureDecoratorPerCol();
    });
    ensureDecoratorPerCol();

    return api;
};
},{}],29:[function(require,module,exports){
/*
 A simple package for creating a list of listeners that can be added to and notified
 */

module.exports = function () {
    var listeners = [];
    return {
        //returns a removal function to unbind the listener
        addListener: function (fn) {
            listeners.push(fn);
            return function () {
                listeners.splice(listeners.indexOf(fn), 1);
            };
        },
        notify: function (e) {
            listeners.forEach(function (listener) {
                listener(e);
            });
        }
    };
};
},{}],30:[function(require,module,exports){
var EVENT_NAMES = ['mousewheel', 'wheel', 'DOMMouseScroll'];

var api = {
    getDelta: function (event, xaxis) {
        if (event.wheelDelta) { //for everything but firefox
            var delta = event.wheelDeltaY;
            if (xaxis) {
                delta = event.wheelDeltaX;
            }
            return delta;

        } else if (event.detail) { //for firefox pre version 17
            if (event.axis && ((event.axis === 1 && xaxis) || (event.axis === 2 && !xaxis))) {
                return -1 * event.detail * 12;
            }
        } else if (event.deltaX || event.deltaY) {
            if (xaxis) {
                return -1 * event.deltaX;
            } else {
                return -1 * event.deltaY;
            }
        }
        return 0;
    },

    //binds a cross browser normalized mousewheel event, and returns a function that will unbind the listener;
    bind: function (elem, listener) {
        var normalizedListener = function (e) {
            listener(normalizeWheelEvent(e));
        };

        EVENT_NAMES.forEach(function (name) {
            elem.addEventListener(name, normalizedListener);
        });

        return function () {
            EVENT_NAMES.forEach(function (name) {
                elem.removeEventListener(name, normalizedListener);
            });
        };

    },
    normalize: normalizeWheelEvent
};

function normalizeWheelEvent(e) {
    var deltaX = api.getDelta(e, true);
    var deltaY = api.getDelta(e);
    var newEvent = Object.create(e,
        {
            deltaY: {value: deltaY},
            deltaX: {value: deltaX},
            type: {value: 'mousewheel'}
        });

    newEvent.preventDefault = function () {
        newEvent.defaultPrevented = true;
        if (e && e.preventDefault) {
            e.preventDefault();
        }
    };
    return newEvent;
}

module.exports = api;
},{}],31:[function(require,module,exports){
var key = require('key');
var util = require('../util');
var rangeUtil = require('../range-util');

module.exports = function (_grid) {
    var grid = _grid;

    var model = {
        focus: {
            row: 0,
            col: 0
        }
    };

    var focusClass = grid.cellClasses.create(0, 0, 'focus');
    grid.cellClasses.add(focusClass);

    model.focusDecorator = grid.decorators.create(0, 0, 1, 1);
    model.focusDecorator.render = function () {
        var div = defaultRender();
        div.setAttribute('class', 'grid-focus-decorator');
        return div;
    };
    grid.decorators.add(model.focusDecorator);


    function clampRowToMinMax(row) {
        return util.clamp(row, 0, grid.rowModel.length() - 1);
    }

    function clampColToMinMax(col) {
        return util.clamp(col, 0, grid.colModel.length() - 1);
    }

    model.setFocus = function setFocus(row, col, optionalEvent) {
        row = clampRowToMinMax(row);
        col = clampColToMinMax(col);
        model.focus.row = row;
        model.focus.col = col;
        focusClass.top = row;
        focusClass.left = col;
        model.focusDecorator.top = row;
        model.focusDecorator.left = col;
        grid.cellScrollModel.scrollIntoView(row, col);
        //focus changes always clear the selection
        clearSelection();
    };

    grid.eventLoop.bind('keydown', function (e) {
        var arrow = key.code.arrow;
        if (!key.is(arrow, e.which)) {
            return;
        }
        //focus logic

        if (!e.shiftKey) {
            //if nothing changes great we'll stay where we are
            var navToRow = model.focus.row;
            var navToCol = model.focus.col;


            switch (e.which) {
                case arrow.down.code:
                    navToRow++;
                    break;
                case arrow.up.code:
                    navToRow--;
                    break;
                case arrow.right.code:
                    navToCol++;
                    break;
                case arrow.left.code:
                    navToCol--;
                    break;
            }
            model.setFocus(navToRow, navToCol, e);
        } else {
            //selection logic
            var newSelection;
            //stand in for if it's cleared
            if (model.selection.top === -1) {
                newSelection = {top: model.focus.row, left: model.focus.col, height: 1, width: 1};
            } else {
                newSelection = {
                    top: model.selection.top,
                    left: model.selection.left,
                    height: model.selection.height,
                    width: model.selection.width
                };
            }

            switch (e.which) {
                case arrow.down.code:
                    if (model.focus.row === newSelection.top) {
                        newSelection.height++;
                    } else {
                        newSelection.top++;
                        newSelection.height--;
                    }
                    break;
                case arrow.up.code:
                    if (model.focus.row === newSelection.top + newSelection.height - 1) {
                        newSelection.top--;
                        newSelection.height++;
                    } else {
                        newSelection.height--;

                    }
                    break;
                case arrow.right.code:
                    if (model.focus.col === newSelection.left) {
                        newSelection.width++;
                    } else {
                        newSelection.left++;
                        newSelection.width--;
                    }
                    break;
                case arrow.left.code:
                    if (model.focus.col === newSelection.left + newSelection.width - 1) {
                        newSelection.left--;
                        newSelection.width++;
                    } else {
                        newSelection.width--;
                    }
                    break;
            }
            if (newSelection.height === 1 && newSelection.width === 1) {
                clearSelection();
            } else {
                model.setSelection(newSelection);
            }

        }
    });

    function outsideMinMax(row, col) {
        return row < 0 || row > grid.rowModel.length() || col < 0 || col > grid.colModel.length();
    }

    grid.eventLoop.bind('mousedown', function (e) {
        //assume the event has been annotated by the cell mouse model interceptor
        var row = e.row;
        var col = e.col;
        if (row < 0 && col >= 0) {
            grid.colModel.toggleSelect(col);
        }
        if (col < 0 && row >= 0) {
            grid.rowModel.toggleSelect(row);
        }

        if (row < 0 && col < 0) {
            return;
        }

        if (!e.shiftKey) {
            model.setFocus(row, col, e);
        } else {
            setSelectionFromPoints(model.focus.row, model.focus.col, row, col);
        }

    });

    model._rowSelectionClasses = [];
    model._colSelectionClasses = [];
    //row col selection
    function handleRowColSelectionChange(rowOrCol) {
        var decoratorsField = ('_' + rowOrCol + 'SelectionClasses');
        model[decoratorsField].forEach(function (selectionDecorator) {
            grid.cellClasses.remove(selectionDecorator);
        });
        model[decoratorsField] = [];

        grid[rowOrCol + 'Model'].getSelected().forEach(function (index) {
            var virtualIndex = grid[rowOrCol + 'Model'].toVirtual(index);
            var top = rowOrCol === 'row' ? virtualIndex : 0;
            var left = rowOrCol === 'col' ? virtualIndex : 0;
            var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');
            grid.cellClasses.add(decorator);
            model[decoratorsField].push(decorator);
        });
    }

    grid.eventLoop.bind('grid-row-selection-change', function () {
        handleRowColSelectionChange('row');
    });

    grid.eventLoop.bind('grid-col-selection-change', function () {
        handleRowColSelectionChange('col');
    });

    var selection = grid.decorators.create();

    var defaultRender = selection.render;
    selection.render = function () {
        var div = defaultRender();
        div.setAttribute('class', 'grid-selection');
        return div;
    };

    grid.decorators.add(selection);

    model.setSelection = function setSelection(newSelection) {
        selection.top = newSelection.top;
        selection.left = newSelection.left;
        selection.height = newSelection.height;
        selection.width = newSelection.width;
    };

    function clearSelection() {
        model.setSelection({top: -1, left: -1, height: -1, width: -1});
    }

    function setSelectionFromPoints(fromRow, fromCol, toRow, toCol) {
        var newSelection = rangeUtil.createFromPoints(fromRow, fromCol, clampRowToMinMax(toRow), clampColToMinMax(toCol));
        model.setSelection(newSelection);
    }

    selection._onDragStart = function (e) {
        if (outsideMinMax(e.row, e.col)) {
            return;
        }
        var fromRow = model.focus.row;
        var fromCol = model.focus.col;
        var unbindDrag = grid.eventLoop.bind('grid-cell-drag', function (e) {
            setSelectionFromPoints(fromRow, fromCol, e.row, e.col);
        });

        var unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {
            unbindDrag();
            unbindDragEnd();
        });
    };

    grid.eventLoop.bind('grid-drag-start', selection._onDragStart);
    clearSelection();

    model.selection = selection;

    return model;
};
},{"../range-util":36,"../util":40,"key":9}],32:[function(require,module,exports){
module.exports = function () {
    //a noop function to use
};
},{}],33:[function(require,module,exports){
module.exports = function () {
    return arguments[0];
};
},{}],34:[function(require,module,exports){
var util = require('../util');
var debounce = require('../debounce');
var capitalize = require('capitalize');

module.exports = function (_grid) {
    var grid = _grid;
    var model = {top: 0, left: 0, maxScroll: {}};
    var scrollBarWidth = 10;

    grid.eventLoop.bind('grid-virtual-pixel-cell-change', function () {
        var scrollHeight = grid.virtualPixelCellModel.totalHeight() - grid.virtualPixelCellModel.fixedHeight();
        var scrollWidth = grid.virtualPixelCellModel.totalWidth() - grid.virtualPixelCellModel.fixedWidth();
        model.setScrollSize(scrollHeight, scrollWidth);
        cacheMaxScroll();
        sizeScrollBars();
    });


    grid.eventLoop.bind('grid-viewport-change', function () {
        cacheMaxScroll();
        sizeScrollBars();
    });

    function cacheMaxScroll() {
        model.maxScroll.height = getMaxScroll('height');
        model.maxScroll.width = getMaxScroll('width');
    }

    //assumes a standardized wheel event that we create through the mousewheel package
    grid.eventLoop.bind('mousewheel', function handleMouseWheel(e) {
        var deltaY = e.deltaY;
        var deltaX = e.deltaX;
        model.scrollTo(model.top - deltaY, model.left - deltaX, true);
        debouncedNotify();
        e.preventDefault();
    });

    model.setScrollSize = function (h, w) {
        model.height = h;
        model.width = w;
    };

    function notifyListeners() {
        //TODO: possibly keep track of delta since last update and send it along. for now, no
        grid.eventLoop.fire('grid-pixel-scroll');

        //update the cell scroll
        var scrollTop = model.top;
        var row = grid.virtualPixelCellModel.getRow(scrollTop + grid.virtualPixelCellModel.fixedHeight()) - grid.rowModel.numFixed();

        var scrollLeft = model.left;
        var col = grid.virtualPixelCellModel.getCol(scrollLeft + grid.virtualPixelCellModel.fixedWidth()) - grid.colModel.numFixed();

        grid.cellScrollModel.scrollTo(row, col, undefined, true);
    }

    var debouncedNotify = debounce(notifyListeners, 1);

    model.scrollTo = function (top, left, dontNotify) {
        model.top = util.clamp(top, 0, model.maxScroll.height);
        model.left = util.clamp(left, 0, model.maxScroll.width);
        positionScrollBars();

        if (!dontNotify) {
            notifyListeners();
        }


    };


    /* SCROLL BAR LOGIC */
    function getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz) {
        var scrollBarTopClick = scrollBarRealClickCoord - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
        var scrollRatio = scrollBarTopClick / getMaxScrollBarCoord(heightWidth, vertHorz);
        var scrollCoord = scrollRatio * model.maxScroll[heightWidth];
        return scrollCoord;
    }

    function makeScrollBarDecorator(isHorz) {
        var decorator = grid.decorators.create();
        var xOrY = isHorz ? 'X' : 'Y';
        var heightWidth = isHorz ? 'width' : 'height';
        var vertHorz = isHorz ? 'horz' : 'vert';
        var gridCoordField = 'grid' + xOrY;
        var layerCoordField = 'layer' + xOrY;
        var viewPortClampFn = grid.viewPort['clamp' + xOrY];

        decorator.postRender = function (scrollBarElem) {
            scrollBarElem.setAttribute('class', 'grid-scroll-bar');
            decorator._onDragStart = function (e) {
                if (e.target !== scrollBarElem) {
                    return;
                }
                var scrollBarOffset = e[layerCoordField];

                decorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (e) {
                    var gridCoord = viewPortClampFn(e[gridCoordField]);
                    var scrollBarRealClickCoord = gridCoord - scrollBarOffset;
                    var scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz);
                    if (isHorz) {
                        model.scrollTo(model.top, scrollCoord);
                    } else {
                        model.scrollTo(scrollCoord, model.left);
                    }
                });

                decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function (e) {
                    decorator._unbindDrag();
                    decorator._unbindDragEnd();
                });

                e.stopPropagation();
            };

            grid.eventLoop.bind('grid-drag-start', scrollBarElem, decorator._onDragStart);
            grid.eventLoop.bind('mousedown', scrollBarElem, function (e) {
                grid.eventLoop.stopBubbling(e);
            });

            return scrollBarElem;
        };

        decorator.units = 'px';
        decorator.space = 'real';

        return decorator;
    }

    model.vertScrollBar = makeScrollBarDecorator();
    model.horzScrollBar = makeScrollBarDecorator(true);
    model.vertScrollBar.width = scrollBarWidth;
    model.horzScrollBar.height = scrollBarWidth;

    function getMaxScroll(heightWidth) {
        var rowOrCol = heightWidth === 'height' ? 'row' : 'col';
        var scrollLength = model[heightWidth];
        var viewScrollHeightOrWidth = getViewScrollHeightOrWidth(heightWidth);
        var firstScrollableCell = grid[rowOrCol + 'Model'].numFixed();
        while (scrollLength > viewScrollHeightOrWidth - 10) {
            scrollLength -= grid.virtualPixelCellModel[heightWidth](firstScrollableCell);
            firstScrollableCell++;
        }
        return model[heightWidth] - scrollLength;
    }

    model._getMaxScroll = getMaxScroll;

    function getScrollRatioFromVirtualScrollCoords(scroll, heightWidth) {
        var maxScroll = model.maxScroll[heightWidth];
        var scrollRatio = scroll / maxScroll;
        return scrollRatio;
    }

    function getMaxScrollBarCoord(heightWidth, vertHorz) {
        return getViewScrollHeightOrWidth(heightWidth) - model[vertHorz + 'ScrollBar'][heightWidth];
    }

    function getRealScrollBarPosition(scroll, heightWidth, vertHorz) {
        var scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll, heightWidth);
        var maxScrollBarScroll = getMaxScrollBarCoord(heightWidth, vertHorz);
        //in scroll bar coords
        var scrollBarCoord = scrollRatio * maxScrollBarScroll;
        //add the fixed height to translate back into real coords
        return scrollBarCoord + grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
    }

    model._getRealScrollBarPosition = getRealScrollBarPosition;
    model._getScrollPositionFromReal = getScrollPositionFromReal;

    function calcScrollBarRealTop() {
        return getRealScrollBarPosition(model.top, 'height', 'vert');
    }

    function calcScrollBarRealLeft() {
        return getRealScrollBarPosition(model.left, 'width', 'horz');
    }

    function positionScrollBars() {
        model.vertScrollBar.top = calcScrollBarRealTop();
        model.horzScrollBar.left = calcScrollBarRealLeft();
    }

    function getViewScrollHeightOrWidth(heightWidth) {
        return grid.viewPort[heightWidth] - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
    }

    function getScrollableViewWidth() {
        return getViewScrollHeightOrWidth('width');
    }

    function getScrollableViewHeight() {
        return getViewScrollHeightOrWidth('height');
    }

    function sizeScrollBars() {
        model.vertScrollBar.left = grid.viewPort.width - scrollBarWidth;
        model.horzScrollBar.top = grid.viewPort.height - scrollBarWidth;
        var scrollableViewHeight = getScrollableViewHeight();
        var scrollableViewWidth = getScrollableViewWidth();
        model.vertScrollBar.height = Math.max(scrollableViewHeight / grid.virtualPixelCellModel.totalHeight() * scrollableViewHeight, 20);
        model.horzScrollBar.width = Math.max(scrollableViewWidth / grid.virtualPixelCellModel.totalWidth() * scrollableViewWidth, 20);
        positionScrollBars();
    }

    grid.decorators.add(model.vertScrollBar);
    grid.decorators.add(model.horzScrollBar);
    /* END SCROLL BAR LOGIC */

    return model;
};
},{"../debounce":24,"../util":40,"capitalize":2}],35:[function(require,module,exports){
var addDirtyProps = require('../add-dirty-props');
module.exports = function (range, dirtyClean, parentDirtyClean) {
    range = range || {}; //allow mixin functionality
    range.isDirty = dirtyClean.isDirty;

    var watchedProperties = ['top', 'left', 'height', 'width', 'units', 'space'];
    var dirtyCleans = [dirtyClean];
    if (parentDirtyClean) {
        dirtyCleans.push(parentDirtyClean);
    }

    addDirtyProps(range, watchedProperties, dirtyCleans);
    //defaults
    range.units = 'cell';
    range.space = 'data';

    return range;
};
},{"../add-dirty-props":12}],36:[function(require,module,exports){
module.exports = {
    //takes a point and a length as the ranges in array form
    intersect: function (range1, range2) {
        var range2Start = range2[0];
        var range1Start = range1[0];
        var range1End = range1Start + range1[1] - 1;
        var range2End = range2Start + range2[1] - 1;
        if (range2Start > range1End || range2End < range1Start) {
            return null;
        }
        var resultStart = (range1Start > range2Start ? range1Start : range2Start);
        var resultEnd = (range1End < range2End ? range1End : range2End);
        return [
            resultStart,
            resultEnd - resultStart + 1
        ];
    },
    //takes a point and a length as the ranges in array form
    union: function (range1, range2) {
        if (!range1) {
            return range2;
        }
        if (!range2) {
            return range1;
        }
        var range2Start = range2[0];
        var range2End = range2Start + range2[1] - 1;
        var range1Start = range1[0];
        var range1End = range1Start + range1[1] - 1;
        var resultStart = (range1Start < range2Start ? range1Start : range2Start);
        return [
            resultStart,
            (range1End > range2End ? range1End : range2End) - resultStart + 1
        ];
    },

    //takes two row, col points and creates a normal position range
    createFromPoints: function (r1, c1, r2, c2) {
        var range = {};
        if (r1 < r2) {
            range.top = r1;
            range.height = r2 - r1 + 1;
        } else {
            range.top = r2;
            range.height = r1 - r2 + 1;
        }

        if (c1 < c2) {
            range.left = c1;
            range.width = c2 - c1 + 1;
        } else {
            range.left = c2;
            range.width = c1 - c2 + 1;
        }
        return range;
    }
};


},{}],37:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = require('../abstract-row-col-model')(grid, 'row', 'height', 30);

    return api;
};
},{"../abstract-row-col-model":11}],38:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = {_decorators: {}};

    function setColShowing(col) {
        grid.colModel.get(col).hidden = false;
    }

    function doWhileHidden(col, fn) {
        while (grid.colModel.get(col - 1).hidden) {
            col--;
            fn && fn(col);
        }
        return col;
    }

    function createDecorator(col, right) {
        var headerDecorator = grid.decorators.create(0, col, 1, 1, 'cell', 'virtual');

        headerDecorator.postRender = function (div) {

            if (right) {
                div.style.transform = 'translate(50%, -50%)';
                div.style.webkitTransform = 'translate(50%, -50%)';
                div.style.removeProperty('left');
            } else {
                div.style.transform = 'translate(-50%, -50%)';
                div.style.webkitTransform = 'translate(-50%, -50%)';
                div.style.removeProperty('right');
            }
            div.style.removeProperty('bottom');
            div.style.top = '50%';
            div.setAttribute('class', 'show-hidden-cols');

            grid.eventLoop.bind('click', div, function () {
                doWhileHidden(col, setColShowing);
            });
        };
        return headerDecorator;
    }

    grid.eventLoop.bind('grid-col-change', function (e) {
        if (e.action === 'hide' || e.action === 'add') {
            e.descriptors.forEach(function (descriptor) {
                var col = descriptor.index;
                if (!col && col !== 0) {
                    return;
                }
                if (descriptor.hidden) {
                    var decCol = col + 1;
                    var rightSide = col === grid.colModel.length(true) - 1;
                    if (rightSide) {
                        //if we're last we actually have to backtrack to the last showing column
                        var lastHiddenCol = doWhileHidden(col);
                        decCol = lastHiddenCol - 1;

                    }
                    var decorator = createDecorator(decCol, rightSide);
                    grid.decorators.add(decorator);
                    api._decorators[col] = decorator;
                } else {
                    var decorator = api._decorators[col];
                    grid.decorators.remove(decorator);
                    api._decorators[col] = undefined;
                }
            });
        }
    });

    return api;
};
},{}],39:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var cellData = [];
    var headerData = [];
    var sortedCol;
    var ascending;
    var dirtyClean = require('../dirty-clean')(grid);
    var internalSet = function (data, r, c, datum) {
        if (!data[r]) {
            data[r] = [];
        }
        data[r][c] = datum;
        dirtyClean.setDirty();
    };

    var api = {
        isDirty: dirtyClean.isDirty,
        set: function (r, c, datum) {
            internalSet(cellData, r, c, datum);
        },
        setHeader: function (r, c, datum) {
            internalSet(headerData, r, c, datum);
        },
        get: function (r, c) {
            var dataRow = cellData[grid.rowModel.row(r).dataRow];
            var datum = dataRow && dataRow[grid.colModel.col(c).dataCol];
            var value = datum && datum.value;
            return {
                value: value,
                formatted: value && 'r' + value[0] + ' c' + value[1] || ''
            };
        },
        getCopyData: function (r, c) {
            return api.get(r, c);
        },
        getHeader: function (r, c) {
            var dataRow = headerData[grid.rowModel.get(r).dataRow];

            var datum = dataRow && dataRow[grid.colModel.get(c).dataCol];
            var value = datum && datum.value;
            return {
                value: value,
                formatted: value && 'hr' + value[0] + ' hc' + value[1] || ''
            };
        },

        toggleSort: function (c) {
            var retVal = -1;
            var compareMethod = function (val1, val2) {
                return val1 < (val2) ? retVal : -1 * retVal;
            };
            if (c === sortedCol) {
                if (ascending) {
                    retVal = 1;
                }
                ascending = !ascending;
            } else {
                sortedCol = c;
                ascending = true;
            }
            cellData.sort(function (dataRow1, dataRow2) {
                if (!dataRow1 || !dataRow1[c]) {
                    return retVal;
                }
                if (!dataRow2 || !dataRow2[c]) {
                    return retVal * -1;
                }
                return compareMethod(dataRow1[c].value, dataRow2[c].value);
            });
            dirtyClean.setDirty();
        }
    };

    return api;
};
},{"../dirty-clean":26}],40:[function(require,module,exports){
module.exports = {
    clamp: function (num, min, max, returnNaN) {
        if (num > max) {
            return returnNaN ? NaN : max;
        }
        if (num < min) {
            return returnNaN ? NaN : min;
        }
        return num;
    },
    isNumber: function (number) {
        return typeof number === 'number' && !isNaN(number);
    },
    isElement: function (node) {
        return !!(node &&
        (node.nodeName || // we are a direct element
        (node.prop && node.attr && node.find)));  // we have an on and find method part of jquery API
    },
    isArray: function (value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },
    position: function (elem, t, l, b, r) {
        elem.style.top = t + 'px';
        elem.style.left = l + 'px';
        elem.style.bottom = b + 'px';
        elem.style.right = r + 'px';
        elem.style.position = 'absolute';

    }
};
},{}],41:[function(require,module,exports){
var customEvent = require('../custom-event');
var debounce = require('../debounce');
var util = require('../util');


module.exports = function (_grid) {
    var viewLayer = {};


    var grid = _grid;
    var container;
    var root;
    var cellContainer;
    var decoratorContainer;
    var borderWidth;

    var GRID_CELL_CONTAINER_BASE_CLASS = 'grid-cells';
    var GRID_VIEW_ROOT_CLASS = 'js-grid-view-root';
    var CELL_CLASS = 'grid-cell';

    var cells; //matrix of rendered cell elements;
    var rows; //array of all rendered rows
    var builtCols; //map from col index to an array of built elements for the column to update on scroll
    var builtRows; //map from row index to an array of built elements for the row to update on scroll

    //add the cell classes through the standard method
    grid.cellClasses.add(grid.cellClasses.create(0, 0, CELL_CLASS, Infinity, Infinity, 'virtual'));

    var rowHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-row-header', Infinity, 0, 'virtual');
    var colHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-col-header', 0, Infinity, 'virtual');
    var fixedColClasses = grid.cellClasses.create(0, -1, 'grid-last-fixed-col', Infinity, 1, 'virtual');
    var fixedRowClasses = grid.cellClasses.create(-1, 0, 'grid-last-fixed-row', 1, Infinity, 'virtual');

    grid.cellClasses.add(rowHeaderClasses);
    grid.cellClasses.add(colHeaderClasses);
    grid.cellClasses.add(fixedRowClasses);
    grid.cellClasses.add(fixedColClasses);


    grid.eventLoop.bind('grid-col-change', function () {
        fixedColClasses.left = grid.colModel.numFixed() - 1;
        rowHeaderClasses.width = grid.colModel.numHeaders();
    });

    grid.eventLoop.bind('grid-row-change', function () {
        fixedRowClasses.top = grid.rowModel.numFixed() - 1;
        colHeaderClasses.height = grid.rowModel.numHeaders();
    });


    viewLayer.build = function (elem) {
        cleanup();

        container = elem;

        cellContainer = document.createElement('div');
        cellContainer.setAttribute('dts', 'grid-cells');
        cellContainer.setAttribute('class', GRID_CELL_CONTAINER_BASE_CLASS);
        util.position(cellContainer, 0, 0, 0, 0);
        cellContainer.style.zIndex = 0;

        decoratorContainer = document.createElement('div');
        decoratorContainer.setAttribute('dts', 'grid-decorators');
        util.position(decoratorContainer, 0, 0, 0, 0);
        decoratorContainer.style.zIndex = 0;
        decoratorContainer.style.pointerEvents = 'none';

        root = document.createElement('div');
        root.setAttribute('class', GRID_VIEW_ROOT_CLASS);

        root.appendChild(cellContainer);
        root.appendChild(decoratorContainer);

        container.appendChild(root);

    };


    function measureBorderWidth() {
        //read the border width, for the rare case of larger than 1px borders, otherwise the draw will default to 1
        if (borderWidth) {
            return;
        }
        var jsGridCell = cells[0] && cells[0][0];
        if (jsGridCell) {
            var oldClass = jsGridCell.className;
            jsGridCell.className = CELL_CLASS;
            var computedStyle = getComputedStyle(jsGridCell);
            var borderWidthProp = computedStyle.getPropertyValue('border-left-width');
            borderWidth = parseInt(borderWidthProp);
            jsGridCell.className = oldClass;
        }
        borderWidth = isNaN(borderWidth) || !borderWidth ? undefined : borderWidth;
        return borderWidth;
    }

    //only draw once per js turn, may need to create a synchronous version
    viewLayer.draw = debounce(function () {
        viewLayer._draw();
    }, 1);

    viewLayer._draw = function () {
        //return if we haven't built yet
        if (!container) {
            return;
        }

        var rebuilt = grid.viewPort.isDirty();
        if (rebuilt) {
            viewLayer._buildCells(cellContainer);
        }

        var builtColsDirty = grid.colModel.areBuildersDirty();
        if (rebuilt || builtColsDirty) {
            viewLayer._buildCols();
        }

        var builtRowsDirty = grid.rowModel.areBuildersDirty();
        if (rebuilt || builtRowsDirty) {
            viewLayer._buildRows();
        }

        var cellsPositionOrSizeChanged = grid.colModel.isDirty() || grid.rowModel.isDirty() || grid.cellScrollModel.isDirty();

        if (grid.cellClasses.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawCellClasses();
        }

        if (rebuilt || cellsPositionOrSizeChanged || builtColsDirty || builtRowsDirty || grid.dataModel.isDirty()) {
            viewLayer._drawCells();
        }

        if (grid.decorators.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawDecorators(cellsPositionOrSizeChanged);
        }

        grid.eventLoop.fire('grid-draw');
    };

    /* CELL LOGIC */
    function getBorderWidth() {
        return borderWidth || 1;
    }

    viewLayer._drawCells = function () {
        measureBorderWidth();
        var bWidth = getBorderWidth();
        var headerRows = grid.rowModel.numHeaders();
        var headerCols = grid.colModel.numHeaders();
        var totalVisibleCellWidth = 0;
        var lastVirtualCol;
        grid.viewPort.iterateCells(function drawCell(r, c) {
            var cell = cells[r][c];
            var width = grid.viewPort.getColWidth(c);
            var virtualCol = grid.viewPort.toVirtualCol(c);
            //if we got the same vCol we've been clamped and its time to hide this cell
            //also hide the cell if its width is zero cause ya...
            if (width == 0 || virtualCol === lastVirtualCol) {
                cell.style.display = 'none';
                return;
            }
            if (r === 0) {
                //calculate width for rows later but only do it one time (so on the first row)
                totalVisibleCellWidth += width;
            }

            lastVirtualCol = virtualCol;
            cell.style.display = '';
            cell.style.width = width + bWidth + 'px';

            var left = grid.viewPort.getColLeft(c);

            cell.style.left = left + 'px';

            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            var virtualRow = grid.viewPort.toVirtualRow(r);

            var data;
            if (r < headerRows || c < headerCols) {
                data = grid.dataModel.getHeader(virtualRow, virtualCol);
            } else {
                data = grid.dataModel.get(grid.rowModel.toData(virtualRow), grid.colModel.toData(virtualCol));
            }
            //artificially only get builders for row headers for now
            var builder = virtualRow < headerRows && grid.rowModel.get(virtualRow).builder || undefined;
            var hasRowBuilder = true;
            if (!builder) {
                hasRowBuilder = false;
                builder = grid.colModel.get(virtualCol).builder;
            }

            var cellChild;
            if (builder) {
                var builtElem;
                if (hasRowBuilder) {
                    builtElem = builtRows[virtualRow][c];
                } else {
                    builtElem = builtCols[virtualCol][r];
                }
                cellChild = builder.update(builtElem, {
                    virtualCol: virtualCol,
                    virtualRow: virtualRow,
                    data: data
                });
            }
            //if we didn't get a child from the builder use a regular text node
            if (!cellChild) {
                cellChild = document.createTextNode(data.formatted);
            }
            cell.appendChild(cellChild);
        }, function drawRow(r) {
            var height = grid.viewPort.getRowHeight(r);
            var row = rows[r];
            if (height == 0) {
                row.style.display = 'none';
                return;
            }
            row.style.display = '';
            row.style.height = height + bWidth + 'px';
            var top = grid.viewPort.getRowTop(r);
            row.style.top = top + 'px';
        });

        rows.forEach(function (row) {
            row.style.width = totalVisibleCellWidth + 'px';
        });

        if (grid.cellScrollModel.row % 2) {
            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS + ' odds';
        } else {
            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS;
        }
    };


    viewLayer._buildCells = function buildCells(cellContainer) {
        while (cellContainer.firstChild) {
            cellContainer.removeChild(cellContainer.firstChild);
        }


        cells = [];
        rows = [];
        var row;
        grid.viewPort.iterateCells(function (r, c) {
            var cell = buildDivCell();
            cells[r][c] = cell;
            row.appendChild(cell);
        }, function (r) {
            cells[r] = [];
            row = document.createElement('div');
            row.setAttribute('class', 'grid-row');
            row.setAttribute('dts', 'grid-row');
            row.style.position = 'absolute';
            row.style.left = 0;
            rows[r] = row;
            cellContainer.appendChild(row);
        });
    };

    function buildDivCell() {
        var cell = document.createElement('div');
        cell.setAttribute('dts', 'grid-cell');
        var style = cell.style;
        style.position = 'absolute';
        style.boxSizing = 'border-box';
        style.top = '0px';
        style.bottom = '0px';
        return cell;
    }

    /* END CELL LOGIC */

    /* COL BUILDER LOGIC */
    viewLayer._buildCols = function () {
        builtCols = {};
        for (var c = 0; c < grid.colModel.length(true); c++) {
            var builder = grid.colModel.get(c).builder;
            if (builder) {
                builtCols[c] = [];
                for (var realRow = 0; realRow < grid.viewPort.rows; realRow++) {
                    builtCols[c][realRow] = builder.render();
                }
            }
        }
    };
    /* END COL BUILDER LOGIC */

    /* ROW BUILDER LOGIC 
     *  for now we only build headers
     * */

    viewLayer._buildRows = function () {
        builtRows = {};
        for (var r = 0; r < grid.rowModel.numHeaders(); r++) {
            var builder = grid.rowModel.get(r).builder;
            if (builder) {
                builtRows[r] = [];
                for (var realCol = 0; realCol < grid.viewPort.cols; realCol++) {
                    builtRows[r][realCol] = builder.render();
                }
            }
        }
    };
    /* END ROW BUILDER LOGIC*/

    /* DECORATOR LOGIC */
    function setPosition(boundingBox, top, left, height, width) {
        var style = boundingBox.style;
        if (height <= 0 || width <= 0) {
            style.display = 'none';
            return;
        }
        style.display = ''
        style.top = top + 'px';
        style.left = left + 'px';
        style.height = height + 'px';
        style.width = width + 'px';
        style.position = 'absolute';
    }

    function positionDecorator(bounding, t, l, h, w) {
        setPosition(bounding, t, l, util.clamp(h, 0, grid.viewPort.height), util.clamp(w, 0, grid.viewPort.width));
    }

    function positionCellDecoratorFromViewCellRange(realCellRange, boundingBox) {
        var realPxRange = grid.viewPort.toPx(realCellRange);
        positionDecorator(boundingBox, realPxRange.top, realPxRange.left, realPxRange.height && realPxRange.height + getBorderWidth(), realPxRange.width && realPxRange.width + getBorderWidth());
    }

    function createRangeForDescriptor(descriptor) {
        var range = {
            top: descriptor.top,
            left: descriptor.left,
            height: descriptor.height,
            width: descriptor.width
        };
        if (descriptor.space === 'data' && descriptor.units === 'cell') {
            range.top += grid.rowModel.numHeaders();
            range.left += grid.colModel.numHeaders();
        }
        return range;
    }

    viewLayer._drawDecorators = function (cellsPositionOrSizeChanged) {
        var aliveDecorators = grid.decorators.getAlive();
        aliveDecorators.forEach(function (decorator) {

            var boundingBox = decorator.boundingBox;
            if (!boundingBox) {
                boundingBox = document.createElement('div');
                boundingBox.style.pointerEvents = 'none';
                decorator.boundingBox = boundingBox;
                var decElement = decorator.render();
                if (decElement) {
                    boundingBox.appendChild(decElement);
                    decoratorContainer.appendChild(boundingBox);
                }
            }

            if (decorator.isDirty() || cellsPositionOrSizeChanged) {
                if (decorator.space === 'real') {
                    switch (decorator.units) {
                        case 'px':
                            positionDecorator(boundingBox, decorator.top, decorator.left, decorator.height, decorator.width);
                            break;
                        case 'cell':
                            positionCellDecoratorFromViewCellRange(decorator, boundingBox);
                            break;
                    }
                }
                else if (decorator.space === 'virtual' || decorator.space === 'data') {
                    switch (decorator.units) {
                        case 'px':
                            break;
                        case 'cell':
                        /* jshint -W086 */
                        default:
                            var range = createRangeForDescriptor(decorator);
                            var realCellRange = grid.viewPort.intersect(range);
                            if (realCellRange) {
                                positionCellDecoratorFromViewCellRange(realCellRange, boundingBox);
                            } else {
                                positionDecorator(boundingBox, -1, -1, -1, -1);
                            }
                            break;
                        /* jshint +W086 */
                    }

                }
            }
        });

        removeDecorators(grid.decorators.popAllDead());
    };

    function removeDecorators(decorators) {
        decorators.forEach(function (decorator) {
            var boundingBox = decorator.boundingBox;
            if (boundingBox) {
                //if they rendered an element previously we attached it to the bounding box as the only child
                var renderedElement = boundingBox.firstChild;
                if (renderedElement) {
                    //create a destroy dom event that bubbles
                    var destroyEvent = customEvent('decorator-destroy', true);
                    renderedElement.dispatchEvent(destroyEvent);
                }
                decoratorContainer.removeChild(boundingBox);
                decorator.boundingBox = undefined;
            }
        });
    }

    /* END DECORATOR LOGIC */

    /* CELL CLASSES LOGIC */
    viewLayer._drawCellClasses = function () {
        grid.viewPort.iterateCells(function (r, c) {
            cells[r][c].className = '';
        });
        grid.cellClasses.getAll().forEach(function (descriptor) {
            var range = createRangeForDescriptor(descriptor);
            var intersection = grid.viewPort.intersect(range);
            if (intersection) {
                rowLoop:
                    for (var r = 0; r < intersection.height; r++) {
                        for (var c = 0; c < intersection.width; c++) {
                            var row = intersection.top + r;
                            var col = intersection.left + c;

                            var cellRow = cells[row];
                            if (!cellRow) {
                                continue rowLoop;
                            }
                            var cell = cellRow[col];
                            if (!cell) {
                                continue;
                            }
                            cell.className = (cell.className ? cell.className + ' ' : '') + descriptor.class;
                        }
                    }
            }
        });
    };

    /* END CELL CLASSES LOGIC*/

    viewLayer.destroy = cleanup;

    function cleanup() {
        removeDecorators(grid.decorators.getAlive().concat(grid.decorators.popAllDead()));
        if (!container) {
            return;
        }
        var querySelectorAll = container.querySelectorAll('.' + GRID_VIEW_ROOT_CLASS);
        for (var i = 0; i < querySelectorAll.length; ++i) {
            var root = querySelectorAll[i];
            container.removeChild(root);
        }
    }

    grid.eventLoop.bind('grid-destroy', function () {
        viewLayer.destroy();
        clearTimeout(viewLayer.draw.timeout);
    });

    return viewLayer;
};
},{"../custom-event":23,"../debounce":24,"../util":40}],42:[function(require,module,exports){
var util = require('../util');
var rangeUtil = require('../range-util');
var capitalize = require('capitalize');
var addDirtyProps = require('../add-dirty-props');
var debounce = require('../debounce');

module.exports = function (_grid) {
    var grid = _grid;
    var dirtyClean = require('../dirty-clean')(grid);
    var container;

    var viewPort = addDirtyProps({}, ['rows', 'cols', 'width', 'height'], [dirtyClean]);
    viewPort.rows = 0;
    viewPort.cols = 0;
    viewPort.isDirty = dirtyClean.isDirty;

    //these probably trigger reflow so we may need to think about caching the value and updating it at on draws or something
    function getFirstClientRect() {
        return container && container.getClientRects && container.getClientRects() && container.getClientRects()[0] || {};
    }

    Object.defineProperty(viewPort, 'top', {
        enumerable: true,
        get: function () {
            return getFirstClientRect().top || 0;
        }
    });

    Object.defineProperty(viewPort, 'left', {
        enumerable: true,
        get: function () {
            return getFirstClientRect().left || 0;
        }
    });

    viewPort.toGridX = function (clientX) {
        return clientX - viewPort.left;
    };

    viewPort.toGridY = function (clientY) {
        return clientY - viewPort.top;
    };


    var fixed = {rows: 0, cols: 0};

    function getFixed(rowOrCol) {
        return fixed[rowOrCol + 's'];
    }

    viewPort.sizeToContainer = function (elem) {
        container = elem;
        viewPort.width = elem.offsetWidth;
        viewPort.height = elem.offsetHeight;
        viewPort.rows = calculateMaxLengths(viewPort.height, grid.rowModel);
        viewPort.cols = calculateMaxLengths(viewPort.width, grid.colModel);
        grid.eventLoop.fire('grid-viewport-change');
    };

    viewPort._onResize = debounce(function () {
        viewPort._resize();
    }, 200);

    grid.eventLoop.bind('grid-destroy', function () {
        clearTimeout(viewPort._onResize.timeout);
        clearTimeout(shortDebouncedResize.timeout);
    });

    viewPort._resize = function () {
        if (container) {
            viewPort.sizeToContainer(container);
        }
    };

    var shortDebouncedResize = debounce(function () {
        viewPort._resize();
    }, 1);

    viewPort.shortDebouncedResize = shortDebouncedResize;


    grid.eventLoop.bind('resize', window, function () {
        //we don't bind the handler directly so that tests can mock it out
        viewPort._onResize();
    });

    grid.eventLoop.bind('grid-row-change', function () {
        fixed.rows = grid.rowModel.numFixed();
        shortDebouncedResize();
    });

    grid.eventLoop.bind('grid-col-change', function () {
        fixed.cols = grid.colModel.numFixed();
        shortDebouncedResize();
    });

    function convertRealToVirtual(coord, rowOrCol, coordIsVirtual) {
        //could cache this on changes i.e. row-change or col-change events
        var numFixed = getFixed(rowOrCol);
        if (coord < numFixed) {
            return coord;
        }
        return coord + (coordIsVirtual ? -1 : 1) * grid.cellScrollModel[rowOrCol];
    }

// converts a viewport row or column to a real row or column 
// clamps it if the column would be outside the range
    function getVirtualRowColUnsafe(realCoord, rowOrCol) {
        return convertRealToVirtual(realCoord, rowOrCol);
    }

    function getVirtualRowColClamped(viewCoord, rowOrCol) {
        var virtualRowCol = getVirtualRowColUnsafe(viewCoord, rowOrCol);
        return grid.virtualPixelCellModel['clamp' + capitalize(rowOrCol)](virtualRowCol);
    }

    viewPort.toVirtualRow = function (r) {
        return getVirtualRowColClamped(r, 'row');
    };

    viewPort.toVirtualCol = function (c) {
        return getVirtualRowColClamped(c, 'col');
    };

    function getRealRowColClamped(virtualCoord, rowOrCol) {
        var numFixed = getFixed(rowOrCol);
        if (virtualCoord < numFixed) {
            return virtualCoord;
        }
        var maxViewPortIndex = viewPort[rowOrCol + 's'] - 1;
        return util.clamp(virtualCoord - grid.cellScrollModel[rowOrCol], numFixed, maxViewPortIndex, true);
    }

    viewPort.rowIsInView = function (virtualRow) {
        var realRow = viewPort.toRealRow(virtualRow);
        return !isNaN(realRow) && getLengthBetweenViewCoords(0, realRow, 'row', 'height', true) < viewPort.height;
    };

    viewPort.colIsInView = function (virtualCol) {
        var realCol = viewPort.toRealCol(virtualCol);
        return !isNaN(realCol) && getLengthBetweenViewCoords(0, realCol, 'col', 'width', true) < viewPort.width;
    };


//default unclamped cause that seems to be the more likely use case converting this direction
    viewPort.toRealRow = function (virtualRow) {
        return getRealRowColClamped(virtualRow, 'row');
    };

    viewPort.toRealCol = function (virtualCol) {
        return getRealRowColClamped(virtualCol, 'col');
    };

    viewPort.clampRow = function (r) {
        return util.clamp(r, 0, viewPort.rows - 1);
    };

    viewPort.clampCol = function (c) {
        return util.clamp(c, 0, viewPort.cols - 1);
    };

    viewPort.clampY = function (y) {
        return util.clamp(y, 0, viewPort.height);
    };

    viewPort.clampX = function (x) {
        return util.clamp(x, 0, viewPort.width);
    };

    function getLengthBetweenViewCoords(startCoord, endCoord, rowOrCol, heightOrWidth, inclusive) {
        var rowOrColCap = capitalize(rowOrCol);
        var toVirtual = viewPort['toVirtual' + rowOrColCap];
        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];
        var clampFn = viewPort['clamp' + rowOrColCap];
        var pos = 0;
        var numFixed = getFixed(rowOrCol);
        var isInNonfixedArea = endCoord >= numFixed;
        var isInFixedArea = startCoord < numFixed;
        var exclusiveOffset = (inclusive ? 0 : 1);
        if (isInFixedArea) {
            var fixedEndCoord = (isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset);
            pos += lengthFn(startCoord, fixedEndCoord);
        }
        if (isInNonfixedArea) {
            pos += lengthFn((isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord)), toVirtual(clampFn(endCoord)) - exclusiveOffset);
        }
        return pos;
    }

    function getTopOrLeft(endCoord, rowOrCol, heightOrWidth) {
        return getLengthBetweenViewCoords(0, endCoord, rowOrCol, heightOrWidth);
    }

    viewPort.getRowTop = function (viewPortCoord) {
        return getTopOrLeft(viewPortCoord, 'row', 'height');
    };

    viewPort.getColLeft = function (viewPortCol) {
        return getTopOrLeft(viewPortCol, 'col', 'width');
    };

    viewPort.toPx = function (realCellRange) {
        return {
            top: viewPort.getRowTop(realCellRange.top),
            left: viewPort.getColLeft(realCellRange.left),
            height: getLengthBetweenViewCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, 'row', 'height', true),
            width: getLengthBetweenViewCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, 'col', 'width', true)
        };
    };

    function getRowOrColFromPosition(pos, rowOrCol, heightOrWidth, returnVirtual) {
        //we could do this slighly faster with binary search to get log(n) instead of n, but will only do it if we actually need to optimize this
        var rowOrColCap = capitalize(rowOrCol);
        var viewMax = viewPort[rowOrCol + 's'];
        var toVirtual = viewPort['toVirtual' + rowOrColCap];
        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];
        var summedLength = 0;
        for (var i = 0; i < viewMax; i++) {
            var virtual = toVirtual(i);
            var length = lengthFn(virtual);
            var newSum = summedLength + length;
            if (newSum > pos) {
                return returnVirtual ? virtual : i;
            }
            summedLength = newSum;
        }
        return NaN;
    }

    viewPort.getVirtualRowByTop = function (top) {
        return getRowOrColFromPosition(top, 'row', 'height', true);
    };

    viewPort.getVirtualColByLeft = function (left) {
        return getRowOrColFromPosition(left, 'col', 'width', true);
    };

    viewPort.getRowByTop = function (top) {
        return getRowOrColFromPosition(top, 'row', 'height');
    };

    viewPort.getColByLeft = function (left) {
        return getRowOrColFromPosition(left, 'col', 'width');
    };

    viewPort.getRowHeight = function (viewPortRow) {
        return grid.virtualPixelCellModel.height(viewPort.toVirtualRow(viewPort.clampRow(viewPortRow)));
    };

    viewPort.getColWidth = function (viewPortCol) {
        return grid.virtualPixelCellModel.width(viewPort.toVirtualCol(viewPort.clampCol(viewPortCol)));
    };

    function intersectRowsOrCols(intersection, range, topOrLeft, rowOrCol, heightOrWidth) {
        var numFixed = fixed[rowOrCol + 's'];
        var fixedRange = [0, numFixed];

        var virtualRange = [range[topOrLeft], range[heightOrWidth]];
        var fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);
        var scrollRange = [numFixed, viewPort[rowOrCol + 's'] - numFixed];
        virtualRange[0] -= grid.cellScrollModel[rowOrCol];
        var scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);
        var resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);
        if (!resultRange) {
            return null;
        }

        intersection[topOrLeft] = resultRange[0];
        intersection[heightOrWidth] = resultRange[1];
        return intersection;
    }

    viewPort.intersect = function (range) {
        //assume virtual cells for now
        var intersection = intersectRowsOrCols({}, range, 'top', 'row', 'height');
        if (!intersection) {
            return null;
        }
        return intersectRowsOrCols(intersection, range, 'left', 'col', 'width');
    };


    function calculateMaxLengths(totalLength, lengthModel) {
        var lengthMethod = lengthModel.width && grid.virtualPixelCellModel.width || grid.virtualPixelCellModel.height;
        var numFixed = lengthModel.numFixed();
        var windowLength = 0;
        var maxSize = 0;
        var fixedLength = 0;
        var windowStartIndex = numFixed;

        for (var fixed = 0; fixed < numFixed; fixed++) {
            fixedLength += lengthMethod(fixed);
        }

        //it might be safer to actually sum the lengths in the virtualPixelCellModel but for now here is ok
        for (var index = numFixed; index < lengthModel.length(true); index++) {
            var lengthOfIindex = lengthMethod(index);
            windowLength += lengthOfIindex;
            while (windowLength + fixedLength > totalLength && windowStartIndex < index) {
                windowLength -= lengthMethod(windowStartIndex);
                windowStartIndex++;
            }
            var windowSize = index - windowStartIndex + 1; // add the one because we want the last index that didn't fit
            if (windowSize > maxSize) {
                maxSize = windowSize;
            }

        }
        return maxSize + numFixed + 1;
    }


    viewPort.iterateCells = function (cellFn, optionalRowFn, optionalMaxRow, optionalMaxCol) {
        optionalMaxRow = optionalMaxRow || Infinity;
        optionalMaxCol = optionalMaxCol || Infinity;
        for (var r = 0; r < Math.min(viewPort.rows, optionalMaxRow); r++) {
            if (optionalRowFn) {
                optionalRowFn(r);
            }
            if (cellFn) {
                for (var c = 0; c < Math.min(viewPort.cols, optionalMaxCol); c++) {
                    cellFn(r, c);

                }
            }
        }
    };

    return viewPort;
}
},{"../add-dirty-props":12,"../debounce":24,"../dirty-clean":26,"../range-util":36,"../util":40,"capitalize":2}],43:[function(require,module,exports){
var util = require('../util');

module.exports = function (_grid) {
    var grid = _grid;
    var model = {};

    //all pixels are assumed to be in the virtual world, no real world pixels are dealt with here :)
    model.getRow = function (topPx) {
        if (topPx < 0) {
            return NaN;
        }
        var sumLength = 0;
        for (var r = 0; r < grid.rowModel.length(true); r++) {
            sumLength += grid.rowModel.height(r);
            if (topPx < sumLength) {
                return r;
            }
        }
        return NaN;
    };

    //yes these are very similar but there will be differences
    model.getCol = function (leftPx) {
        if (leftPx < 0) {
            return NaN;
        }
        var sumLength = 0;
        for (var c = 0; c < grid.colModel.length(true); c++) {
            sumLength += grid.colModel.width(c);
            if (leftPx < sumLength) {
                return c;
            }
        }
        return NaN;
    };


    function clampRowOrCol(virtualRowCol, rowOrCol) {
        var maxRowCol = grid[rowOrCol + 'Model'].length(true) - 1;
        return util.clamp(virtualRowCol, 0, maxRowCol);
    }

    model.clampRow = function (virtualRow) {
        return clampRowOrCol(virtualRow, 'row');
    };

    model.clampCol = function (virtualCol) {
        return clampRowOrCol(virtualCol, 'col');
    };

    //for now these just call through to the row and column model, but very likely it will need to include some other calculations
    model.height = function (virtualRowStart, virtualRowEnd) {
        return heightOrWidth(virtualRowStart, virtualRowEnd, 'row');
    };

    model.width = function (virtualColStart, virtualColEnd) {
        return heightOrWidth(virtualColStart, virtualColEnd, 'col');
    };

    function heightOrWidth(start, end, rowOrCol) {
        var length = 0;
        if (end < start) {
            return 0;
        }
        end = util.isNumber(end) ? end : start;
        end = clampRowOrCol(end, rowOrCol);
        start = clampRowOrCol(start, rowOrCol);
        var lengthModel = grid[rowOrCol + 'Model'];
        var lengthFn = lengthModel.width || lengthModel.height;
        for (var i = start; i <= end; i++) {
            length += lengthFn(i);
        }
        return length;
    }

    model.totalHeight = function () {
        return model.height(0, grid.rowModel.length(true) - 1);
    };

    model.totalWidth = function () {
        return model.width(0, grid.colModel.length(true) - 1);
    };

    model.fixedHeight = function () {
        return model.height(0, grid.rowModel.numFixed() - 1);
    };

    model.fixedWidth = function () {
        return model.width(0, grid.colModel.numFixed() - 1);
    };

    function sizeChangeListener() {
        //for now we don't cache anything about this so we just notify
        grid.eventLoop.fire('grid-virtual-pixel-cell-change');
    }

    grid.eventLoop.bind('grid-col-change', sizeChangeListener);
    grid.eventLoop.bind('grid-row-change', sizeChangeListener);

    return model;
};
},{"../util":40}]},{},[1])
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ndWxwLXRhc2tzLXJpcS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwic3JjL21vZHVsZXMvcmlxLWdyaWQtZW50cnkuanMiLCJub2RlX21vZHVsZXMvY2FwaXRhbGl6ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbGVtZW50LWNsYXNzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2tleS9saWIvY29kZS9hbG51bS5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL2NvZGUvYXJyb3cuanMiLCJub2RlX21vZHVsZXMva2V5L2xpYi9jb2RlL2JyYW5kLmpzIiwibm9kZV9tb2R1bGVzL2tleS9saWIvY29kZS9wdW5jdHVhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL2NvZGUvc3BlY2lhbC5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL3JlZi5qcyIsInNyYy9tb2R1bGVzL2Fic3RyYWN0LXJvdy1jb2wtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9hZGQtZGlydHktcHJvcHMvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9hbmd1bGFyLWRlY29yYXRvci9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NlbGwtY2xhc3Nlcy9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NlbGwtbW91c2UtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9jZWxsLXNjcm9sbC1tb2RlbC9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NvbC1tb2RlbC9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NvbC1yZW9yZGVyL2luZGV4LmpzIiwic3JjL21vZHVsZXMvY29sLXJlc2l6ZS9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NvcHktcGFzdGUvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9jb3JlL2luZGV4LmpzIiwic3JjL21vZHVsZXMvY3RybC1vci1jbWQvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9jdXN0b20tZXZlbnQvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2RlY29yYXRvcnMvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9kaXJ0eS1jbGVhbi9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2V2ZW50LWxvb3AvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9oZWFkZXItZGVjb3JhdG9ycy9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2xpc3RlbmVycy9pbmRleC5qcyIsInNyYy9tb2R1bGVzL21vdXNld2hlZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9uYXZpZ2F0aW9uLW1vZGVsL2luZGV4LmpzIiwic3JjL21vZHVsZXMvbm8tb3AvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9wYXNzLXRocm91Z2gvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9waXhlbC1zY3JvbGwtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9wb3NpdGlvbi1yYW5nZS9pbmRleC5qcyIsInNyYy9tb2R1bGVzL3JhbmdlLXV0aWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9yb3ctbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9zaG93LWhpZGRlbi1jb2xzL2luZGV4LmpzIiwic3JjL21vZHVsZXMvc2ltcGxlLWRhdGEtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy91dGlsL2luZGV4LmpzIiwic3JjL21vZHVsZXMvdmlldy1sYXllci9pbmRleC5qcyIsInNyYy9tb2R1bGVzL3ZpZXctcG9ydC9pbmRleC5qcyIsInNyYy9tb2R1bGVzL3ZpcnR1YWwtcGl4ZWwtY2VsbC1tb2RlbC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImFuZ3VsYXIubW9kdWxlKCdyaXEtZ3JpZCcsIFtcbiAgcmVxdWlyZSgnLi9hbmd1bGFyLWRlY29yYXRvcicpLm5hbWVcbl0pXG4gIC5mYWN0b3J5KCdSaXFHcmlkU3J2YycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29yZTogcmVxdWlyZSgnLi9jb3JlJylcbiAgICB9O1xuICB9KVxuO1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zdWJzdHJpbmcoMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLndvcmRzID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyhefFxcVykoXFx3KS9nLCBmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBtLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICByZXR1cm4gbmV3IEVsZW1lbnRDbGFzcyhvcHRzKVxufVxuXG5mdW5jdGlvbiBFbGVtZW50Q2xhc3Mob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRWxlbWVudENsYXNzKSkgcmV0dXJuIG5ldyBFbGVtZW50Q2xhc3Mob3B0cylcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgLy8gc2ltaWxhciBkb2luZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IGJ1dCB3b3JrcyBpbiBJRThcbiAgaWYgKG9wdHMubm9kZVR5cGUpIG9wdHMgPSB7ZWw6IG9wdHN9XG5cbiAgdGhpcy5vcHRzID0gb3B0c1xuICB0aGlzLmVsID0gb3B0cy5lbCB8fCBkb2N1bWVudC5ib2R5XG4gIGlmICh0eXBlb2YgdGhpcy5lbCAhPT0gJ29iamVjdCcpIHRoaXMuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZWwpXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGlmIChlbC5jbGFzc05hbWUgPT09IFwiXCIpIHJldHVybiBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVxuICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMSkgcmV0dXJuIGNsYXNzZXNcbiAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSlcbiAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJylcbiAgcmV0dXJuIGNsYXNzZXNcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgaWYgKGVsLmNsYXNzTmFtZSA9PT0gXCJcIikgcmV0dXJuXG4gIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KCcgJylcbiAgdmFyIGlkeCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpXG4gIGlmIChpZHggPiAtMSkgY2xhc3Nlcy5zcGxpY2UoaWR4LCAxKVxuICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKVxuICByZXR1cm4gY2xhc3Nlc1xufVxuXG5FbGVtZW50Q2xhc3MucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIGlmICghZWwpIHJldHVyblxuICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgnICcpXG4gIHJldHVybiBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xXG59XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4zXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYWxudW0sIHJlZjtcblxuICByZWYgPSByZXF1aXJlKCcuLi9yZWYnKS5yZWY7XG5cbiAgYWxudW0gPSB7XG4gICAgJzAnOiByZWYoJzAnLCA0OCksXG4gICAgJzEnOiByZWYoJzEnLCA0OSksXG4gICAgJzInOiByZWYoJzInLCA1MCksXG4gICAgJzMnOiByZWYoJzMnLCA1MSksXG4gICAgJzQnOiByZWYoJzQnLCA1MiksXG4gICAgJzUnOiByZWYoJzUnLCA1MyksXG4gICAgJzYnOiByZWYoJzYnLCA1NCksXG4gICAgJzcnOiByZWYoJzcnLCA1NSksXG4gICAgJzgnOiByZWYoJzgnLCA1NiksXG4gICAgJzknOiByZWYoJzknLCA1NyksXG4gICAgYTogcmVmKCdBJywgNjUpLFxuICAgIGI6IHJlZignQicsIDY2KSxcbiAgICBjOiByZWYoJ0MnLCA2NyksXG4gICAgZDogcmVmKCdEJywgNjgpLFxuICAgIGU6IHJlZignRScsIDY5KSxcbiAgICBmOiByZWYoJ0YnLCA3MCksXG4gICAgZzogcmVmKCdHJywgNzEpLFxuICAgIGg6IHJlZignSCcsIDcyKSxcbiAgICBpOiByZWYoJ0knLCA3MyksXG4gICAgajogcmVmKCdKJywgNzQpLFxuICAgIGs6IHJlZignSycsIDc1KSxcbiAgICBsOiByZWYoJ0wnLCA3NiksXG4gICAgbTogcmVmKCdNJywgNzcpLFxuICAgIG46IHJlZignTicsIDc4KSxcbiAgICBvOiByZWYoJ08nLCA3OSksXG4gICAgcDogcmVmKCdQJywgODApLFxuICAgIHE6IHJlZignUScsIDgxKSxcbiAgICByOiByZWYoJ1InLCA4MiksXG4gICAgczogcmVmKCdTJywgODMpLFxuICAgIHQ6IHJlZignVCcsIDg0KSxcbiAgICB1OiByZWYoJ1UnLCA4NSksXG4gICAgdjogcmVmKCdWJywgODYpLFxuICAgIHc6IHJlZignVycsIDg3KSxcbiAgICB4OiByZWYoJ1gnLCA4OCksXG4gICAgeTogcmVmKCdZJywgODkpLFxuICAgIHo6IHJlZignWicsIDkwKVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gYWxudW07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4zXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYXJyb3csIHJlZjtcblxuICByZWYgPSByZXF1aXJlKCcuLi9yZWYnKS5yZWY7XG5cbiAgYXJyb3cgPSB7XG4gICAgbGVmdDogcmVmKCdMZWZ0JywgMzcpLFxuICAgIHVwOiByZWYoJ1VwJywgMzgpLFxuICAgIHJpZ2h0OiByZWYoJ1JpZ2h0JywgMzkpLFxuICAgIGRvd246IHJlZignRG93bicsIDQwKVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gYXJyb3c7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4zXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYnJhbmQsIHJlZjtcblxuICByZWYgPSByZXF1aXJlKCcuLi9yZWYnKS5yZWY7XG5cbiAgYnJhbmQgPSB7XG4gICAgYXBwbGU6IHJlZignQXBwbGUgJiM4OTg0OycsIDIyNCksXG4gICAgd2luZG93czoge1xuICAgICAgc3RhcnQ6IHJlZignV2luZG93cyBzdGFydCcsIFs5MSwgOTJdKSxcbiAgICAgIG1lbnU6IHJlZignV2luZG93cyBtZW51JywgOTMpXG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gYnJhbmQ7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4zXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcHVuY3R1YXRpb24sIHJlZjtcblxuICByZWYgPSByZXF1aXJlKCcuLi9yZWYnKS5yZWY7XG5cbiAgcHVuY3R1YXRpb24gPSB7XG4gICAgY29sb246IHJlZignQ29sb24vU2VtaWNvbG9uJywgWzU5LCAxODZdKSxcbiAgICBlcXVhbDogcmVmKCdFcXVhbC9QbHVzJywgWzYxLCAxODddKSxcbiAgICBjb21tYTogcmVmKCdDb21tYS9MZXNzIFRoYW4nLCBbNDQsIDE4OF0pLFxuICAgIGh5cGhlbjogcmVmKCdIeXBoZW4vVW5kZXJzY29yZScsIFs0NSwgMTA5LCAxODldKSxcbiAgICBwZXJpb2Q6IHJlZignUGVyaW9kL0dyZWF0ZXIgVGhhbicsIFs0NiwgMTkwXSksXG4gICAgdGlsZGU6IHJlZignVGlsZGUvQmFjayBUaWNrJywgWzk2LCAxOTJdKSxcbiAgICBhcG9zdHJvcGhlOiByZWYoJ0Fwb3N0cm9waGUvUXVvdGUnLCBbMzksIDIyMl0pLFxuICAgIHNsYXNoOiB7XG4gICAgICBmb3J3YXJkOiByZWYoJ0ZvcndhcmQgU2xhc2gvUXVlc3Rpb24gTWFyaycsIFs0NywgMTkxXSksXG4gICAgICBiYWNrd2FyZDogcmVmKCdCYWNrd2FyZCBTbGFzaC9QaXBlJywgMjIwKVxuICAgIH0sXG4gICAgYnJhY2U6IHtcbiAgICAgIHNxdWFyZToge1xuICAgICAgICBvcGVuOiByZWYoJ09wZW4gU3F1YXJlL0N1cmx5IEJyYWNlJywgMjE5KSxcbiAgICAgICAgY2xvc2U6IHJlZignQ2xvc2UgU3F1YXJlL0N1cmx5IEJyYWNlJywgMjIxKVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdW5jdHVhdGlvbi5zZW1pY29sb24gPSBwdW5jdHVhdGlvbi5jb2xvbjtcblxuICBwdW5jdHVhdGlvbi5wbHVzID0gcHVuY3R1YXRpb24uZXF1YWw7XG5cbiAgcHVuY3R1YXRpb24ubGVzc3RoYW4gPSBwdW5jdHVhdGlvbi5jb21tYTtcblxuICBwdW5jdHVhdGlvbi51bmRlcnNjb3JlID0gcHVuY3R1YXRpb24uaHlwaGVuO1xuXG4gIHB1bmN0dWF0aW9uLmdyZWF0ZXJ0aGFuID0gcHVuY3R1YXRpb24ucGVyaW9kO1xuXG4gIHB1bmN0dWF0aW9uLnF1ZXN0aW9uID0gcHVuY3R1YXRpb24uc2xhc2guZm9yd2FyZDtcblxuICBwdW5jdHVhdGlvbi5iYWNrdGljayA9IHB1bmN0dWF0aW9uLnRpbGRlO1xuXG4gIHB1bmN0dWF0aW9uLnBpcGUgPSBwdW5jdHVhdGlvbi5zbGFzaC5iYWNrd2FyZDtcblxuICBwdW5jdHVhdGlvbi5xdW90ZSA9IHB1bmN0dWF0aW9uLmFwb3N0cm9waGU7XG5cbiAgcHVuY3R1YXRpb24uYnJhY2UuY3VybHkgPSBwdW5jdHVhdGlvbi5icmFjZS5zcXVhcmU7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBwdW5jdHVhdGlvbjtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4zLjNcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciByZWYsIHNwZWNpYWw7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi4vcmVmJykucmVmO1xuXG4gIHNwZWNpYWwgPSB7XG4gICAgYmFja3NwYWNlOiByZWYoJ0JhY2tzcGFjZScsIDgpLFxuICAgIHRhYjogcmVmKCdUYWInLCA5KSxcbiAgICBlbnRlcjogcmVmKCdFbnRlcicsIDEzKSxcbiAgICBzaGlmdDogcmVmKCdTaGlmdCcsIDE2KSxcbiAgICBjdHJsOiByZWYoJ0N0cmwnLCAxNyksXG4gICAgYWx0OiByZWYoJ0FsdCcsIDE4KSxcbiAgICBjYXBzOiByZWYoJ0NhcHMgTG9jaycsIDIwKSxcbiAgICBlc2M6IHJlZignRXNjYXBlJywgMjcpLFxuICAgIHNwYWNlOiByZWYoJ1NwYWNlJywgMzIpLFxuICAgIG51bTogcmVmKCdOdW0gTG9jaycsIDE0NClcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHNwZWNpYWw7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4zXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaXNSZWYsIGl0ZXJhdG9yLCBrZXksXG4gICAgX3RoaXMgPSB0aGlzLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzUmVmID0gcmVxdWlyZSgnLi9yZWYnKS5pc1JlZjtcblxuICBrZXkgPSB7fTtcblxuICBrZXkuY29kZSA9IHtcbiAgICBzcGVjaWFsOiByZXF1aXJlKCcuL2NvZGUvc3BlY2lhbCcpLFxuICAgIGFycm93OiByZXF1aXJlKCcuL2NvZGUvYXJyb3cnKSxcbiAgICBwdW5jdHVhdGlvbjogcmVxdWlyZSgnLi9jb2RlL3B1bmN0dWF0aW9uJyksXG4gICAgYWxudW06IHJlcXVpcmUoJy4vY29kZS9hbG51bScpLFxuICAgIGJyYW5kOiByZXF1aXJlKCcuL2NvZGUvYnJhbmQnKVxuICB9O1xuXG4gIGtleS5nZXQgPSBmdW5jdGlvbihwcmVzc2VkKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKGtleS5jb2RlLCBwcmVzc2VkKTtcbiAgfTtcblxuICBrZXkuaXMgPSBmdW5jdGlvbihyZWYsIHByZXNzZWQpIHtcbiAgICBpZiAoIWlzUmVmKHJlZikpIHtcbiAgICAgIHJlZiA9IGl0ZXJhdG9yKHJlZiwgcHJlc3NlZCk7XG4gICAgfVxuICAgIGlmIChpc1JlZihyZWYpKSB7XG4gICAgICBpZiAoaXNSZWYocHJlc3NlZCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXNzZWQgPT09IHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmVzc2VkID09PSByZWYuY29kZSB8fCBfX2luZGV4T2YuY2FsbChyZWYuY29kZSwgcHJlc3NlZCkgPj0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXNzZWQgPT09IHJlZjtcbiAgICB9XG4gIH07XG5cbiAgaXRlcmF0b3IgPSBmdW5jdGlvbihjb250ZXh0LCBwcmVzc2VkKSB7XG4gICAgdmFyIGksIG91dCwgcmVmO1xuICAgIGZvciAoaSBpbiBjb250ZXh0KSB7XG4gICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKGNvbnRleHQsIGkpKSBjb250aW51ZTtcbiAgICAgIHJlZiA9IGNvbnRleHRbaV07XG4gICAgICBpZiAoaXNSZWYocmVmKSkge1xuICAgICAgICBpZiAoa2V5LmlzKHJlZiwgcHJlc3NlZCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgPSBpdGVyYXRvcihyZWYsIHByZXNzZWQpO1xuICAgICAgICBpZiAoaXNSZWYob3V0KSkge1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LmtleSA9IGtleTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0ga2V5O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjMuM1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFJlZmVyZW5jZSwgYXNzZXJ0UmVmLCBpc1JlZiwgcmVmO1xuXG4gIFJlZmVyZW5jZSA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShuYW1lLCBjb2RlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVmZXJlbmNlO1xuXG4gIH0pKCk7XG5cbiAgcmVmID0gZnVuY3Rpb24obmFtZSwgY29kZSkge1xuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKG5hbWUsIGNvZGUpO1xuICB9O1xuXG4gIGlzUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgcmV0dXJuIHJlZiBpbnN0YW5jZW9mIFJlZmVyZW5jZTtcbiAgfTtcblxuICBhc3NlcnRSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAoIWlzUmVmKHJlZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWZlcmVuY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZWY6IHJlZixcbiAgICBpc1JlZjogaXNSZWYsXG4gICAgYXNzZXJ0UmVmOiBhc3NlcnRSZWZcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBhZGREaXJ0eVByb3BzID0gcmVxdWlyZSgnLi4vYWRkLWRpcnR5LXByb3BzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBub29wID0gcmVxdWlyZSgnLi4vbm8tb3AnKTtcbnZhciBwYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4uL3Bhc3MtdGhyb3VnaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCwgbmFtZSwgbGVuZ3RoTmFtZSwgZGVmYXVsdFNpemUpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGRlc2NyaXB0b3JzID0gW107XG4gICAgdmFyIG51bUZpeGVkID0gMDtcbiAgICB2YXIgbnVtSGVhZGVycyA9IDA7XG4gICAgdmFyIG1ha2VEaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKTtcbiAgICB2YXIgZGlydHlDbGVhbiA9IG1ha2VEaXJ0eUNsZWFuKGdyaWQpO1xuICAgIHZhciBidWlsZGVyRGlydHlDbGVhbiA9IG1ha2VEaXJ0eUNsZWFuKGdyaWQpO1xuICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc2V0RGVzY3JpcHRvcnNEaXJ0eShldmVudE9wdGlvbmFsKSB7XG4gICAgICAgIHZhciBldmVudCA9IGV2ZW50T3B0aW9uYWwgfHwge307XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnZ3JpZC0nICsgbmFtZSArICctY2hhbmdlJztcbiAgICAgICAgZ3JpZC5ldmVudExvb3AuZmlyZShldmVudCk7XG4gICAgICAgIGRpcnR5Q2xlYW4uc2V0RGlydHkoKTtcbiAgICAgICAgYnVpbGRlckRpcnR5Q2xlYW4uc2V0RGlydHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJlU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKCdncmlkLScgKyBuYW1lICsgJy1zZWxlY3Rpb24tY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlRGVzY3JpcHRvckluZGljZXMoKSB7XG4gICAgICAgIGRlc2NyaXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKGRlc2NyaXB0b3IsIGkpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuaW5kZXggPSBpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgICBhcmVCdWlsZGVyc0RpcnR5OiBidWlsZGVyRGlydHlDbGVhbi5pc0RpcnR5LFxuICAgICAgICBpc0RpcnR5OiBkaXJ0eUNsZWFuLmlzRGlydHksXG4gICAgICAgIGRlZmF1bHRTaXplOiBkZWZhdWx0U2l6ZSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAodG9BZGQpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc0FycmF5KHRvQWRkKSkge1xuICAgICAgICAgICAgICAgIHRvQWRkID0gW3RvQWRkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvQWRkLmZvckVhY2goZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMuc3BsaWNlKG51bUhlYWRlcnMsIDAsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgICAgICBudW1GaXhlZCsrO1xuICAgICAgICAgICAgICAgICAgICBudW1IZWFkZXJzKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGNvbHVtbiBpcyBmaXhlZCBhbmQgdGhlIGxhc3Qgb25lIGFkZGVkIGlzIGZpeGVkICh3ZSBvbmx5IGFsbG93IGZpeGVkIGF0IHRoZSBiZWdpbm5pbmcgZm9yIG5vdylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzY3JpcHRvcnMubGVuZ3RoIHx8IGRlc2NyaXB0b3JzW2Rlc2NyaXB0b3JzLmxlbmd0aCAtIDFdLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRml4ZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBhZGQgYSBmaXhlZCBjb2x1bW4gYWZ0ZXIgYW4gdW5maXhlZCBvbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2goZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVEZXNjcmlwdG9ySW5kaWNlcygpO1xuICAgICAgICAgICAgc2V0RGVzY3JpcHRvcnNEaXJ0eSh7YWN0aW9uOiAnYWRkJywgZGVzY3JpcHRvcnM6IHRvQWRkfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEhlYWRlcnM6IGZ1bmN0aW9uICh0b0FkZCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzQXJyYXkodG9BZGQpKSB7XG4gICAgICAgICAgICAgICAgdG9BZGQgPSBbdG9BZGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9BZGQuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyLmhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaS5hZGQodG9BZGQpO1xuICAgICAgICB9LFxuICAgICAgICBoZWFkZXI6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzW2luZGV4XTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yc1tpbmRleF07XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgICAgICB2YXIgc3VidHJhY3QgPSBpbmNsdWRlSGVhZGVycyA/IDAgOiBudW1IZWFkZXJzO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzLmxlbmd0aCAtIHN1YnRyYWN0O1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChkZXNjcmlwdG9yLCBkb250VXBkYXRlSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGRlc2NyaXB0b3JzLmluZGV4T2YoZGVzY3JpcHRvcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtRml4ZWQtLTtcbiAgICAgICAgICAgICAgICAgICAgbnVtSGVhZGVycy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRvci5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICBudW1GaXhlZC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGVzY3JpcHRvckluZGljZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChpbmNsdWRlSGVhZGVycykge1xuICAgICAgICAgICAgZGVzY3JpcHRvcnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlSGVhZGVycyB8fCAhZGVzY3JpcHRvci5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnJlbW92ZShkZXNjcmlwdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZTogZnVuY3Rpb24gKHN0YXJ0LCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzLnNwbGljZSh0YXJnZXQsIDAsIGRlc2NyaXB0b3JzLnNwbGljZShzdGFydCwgMSlbMF0pO1xuICAgICAgICAgICAgdXBkYXRlRGVzY3JpcHRvckluZGljZXMoKTtcbiAgICAgICAgICAgIHNldERlc2NyaXB0b3JzRGlydHkoe2FjdGlvbjogJ21vdmUnLCBkZXNjcmlwdG9yczogW2FwaS5nZXQoc3RhcnQpLCBhcGkuZ2V0KHRhcmdldCldfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG51bUhlYWRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1IZWFkZXJzO1xuICAgICAgICB9LFxuICAgICAgICBudW1GaXhlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bUZpeGVkO1xuICAgICAgICB9LFxuICAgICAgICB0b1ZpcnR1YWw6IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhSW5kZXggKyBhcGkubnVtSGVhZGVycygpO1xuICAgICAgICB9LFxuICAgICAgICB0b0RhdGE6IGZ1bmN0aW9uICh2aXJ0dWFsSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsSW5kZXggLSBhcGkubnVtSGVhZGVycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKGluZGV4KSB7XG5cbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gYXBpW25hbWVdKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghZGVzY3JpcHRvci5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIGZpcmVTZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIChpbmRleCwgZG9udE5vdGlmeSkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBhcGlbbmFtZV0oaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKHNlbGVjdGVkLmluZGV4T2YoaW5kZXgpLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbnROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZVNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlU2VsZWN0OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gYXBpW25hbWVdKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYXBpLmRlc2VsZWN0KGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBpLnNlbGVjdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzZWxlY3RlZC5sZW5ndGg7XG4gICAgICAgICAgICBzZWxlY3RlZC5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGFwaS5kZXNlbGVjdChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaXJlU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGJ1aWxkZXIpIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0ge307XG4gICAgICAgICAgICB2YXIgZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXNjcmlwdG9yLCAnZml4ZWQnLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuaGVhZGVyIHx8IGZpeGVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2ZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkID0gX2ZpeGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuLy9cbi8vICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc2NyaXB0b3IsICdpbmRleCcsIHtcbi8vICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4vLyAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnMuaW5kZXhPZihkZXNjcmlwdG9yKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFkZERpcnR5UHJvcHMoZGVzY3JpcHRvciwgWydidWlsZGVyJ10sIFtidWlsZGVyRGlydHlDbGVhbl0pO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5idWlsZGVyID0gYnVpbGRlcjtcblxuICAgICAgICAgICAgcmV0dXJuIGFkZERpcnR5UHJvcHMoZGVzY3JpcHRvciwgW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbGVuZ3RoTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb25EaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGVzY3JpcHRvcnNEaXJ0eSh7YWN0aW9uOiAnc2l6ZScsIGRlc2NyaXB0b3JzOiBbZGVzY3JpcHRvcl19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgb25EaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGVzY3JpcHRvcnNEaXJ0eSh7YWN0aW9uOiAnaGlkZScsIGRlc2NyaXB0b3JzOiBbZGVzY3JpcHRvcl19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sIFtkaXJ0eUNsZWFuXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUJ1aWxkZXI6IGZ1bmN0aW9uIChyZW5kZXIsIHVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtyZW5kZXI6IHJlbmRlciB8fCBub29wLCB1cGRhdGU6IHVwZGF0ZSB8fCBwYXNzVGhyb3VnaH07XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvL2Jhc2ljYWxseSBoZWlnaHQgb3Igd2lkdGhcbiAgICBhcGlbbGVuZ3RoTmFtZV0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpbmRleF07XG4gICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuaGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yW2xlbmd0aE5hbWVdIHx8IGFwaS5kZWZhdWx0U2l6ZTtcbiAgICB9O1xuXG4gICAgLy9yb3cgb3IgY29sIGdldFxuICAgIGFwaVtuYW1lXSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnNbaW5kZXggKyBudW1IZWFkZXJzXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBwcm9wcywgZGlydHlDbGVhbnMpIHtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lIHx8IHByb3A7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoX3ZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgPSBfdmFsICE9PSB2YWw7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFsID0gX3ZhbDtcblxuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHlDbGVhbnMuZm9yRWFjaChmdW5jdGlvbiAoZGlydHlDbGVhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlydHlDbGVhbi5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3Aub25EaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC5vbkRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gYW5ndWxhci5tb2R1bGUoJ2dyaWQtZGVjb3JhdG9yJywgW10pXG4gICAgLmZhY3RvcnkoJ0dyaWREZWNvcmF0b3JTcnZjJywgZnVuY3Rpb24gKCRjb21waWxlKSB7XG4gICAgICAgIHZhciBHcmlkRGVjb3JhdG9yU3J2YyA9IHtcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGlsZWQgPSAkY29tcGlsZShvcHRzLnRlbXBsYXRlKShvcHRzLiRzY29wZSk7XG4gICAgICAgICAgICAgICAgY29tcGlsZWQub24oJ2RlY29yYXRvci1kZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLiRzY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAvL3VuYmluZCBpbiBhIHRpbWVvdXQgdG8gYWxsb3cgYW55IG90aGVyIGxpc3RlbmVycyB0byBmaXJlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQub2ZmKCdkZWNvcmF0b3ItZGVzdHJveScpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcHRzLiRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZWRbMF0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZWRbMF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yczogZnVuY3Rpb24gKGdyaWQsIG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdBbm5vdGF0ZSA9IG1vZGVsLmFubm90YXRlRGVjb3JhdG9yO1xuICAgICAgICAgICAgICAgIG1vZGVsLmFubm90YXRlRGVjb3JhdG9yID0gZnVuY3Rpb24gKGRlYykge1xuICAgICAgICAgICAgICAgICAgICBkZWMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdyaWREZWNvcmF0b3JTcnZjLnJlbmRlcihkZWMucmVuZGVyT3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnQW5ub3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdBbm5vdGF0ZShkZWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4uL2hlYWRlci1kZWNvcmF0b3JzJykoZ3JpZCwgbW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gR3JpZERlY29yYXRvclNydmNcbiAgICB9KVxuXG47IiwidmFyIHBvc2l0aW9uUmFuZ2UgPSByZXF1aXJlKCcuLi9wb3NpdGlvbi1yYW5nZScpO1xudmFyIG1ha2VEaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKTtcbnZhciBhZGREaXJ0eVByb3BzID0gcmVxdWlyZSgnLi4vYWRkLWRpcnR5LXByb3BzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBkaXJ0eUNsZWFuID0gbWFrZURpcnR5Q2xlYW4oZ3JpZCk7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0gW107XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgZGlydHlDbGVhbi5zZXREaXJ0eSgpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9ycy5zcGxpY2UoZGVzY3JpcHRvcnMuaW5kZXhPZihkZXNjcmlwdG9yKSwgMSk7XG4gICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzLnNsaWNlKDApO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICh0b3AsIGxlZnQsIGNsYXNzTmFtZSwgaGVpZ2h0LCB3aWR0aCwgc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciB0aGlzRGlydHlDbGVhbiA9IG1ha2VEaXJ0eUNsZWFuKGdyaWQpO1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7fTtcbiAgICAgICAgICAgIC8vbWl4aW5zXG4gICAgICAgICAgICBwb3NpdGlvblJhbmdlKGRlc2NyaXB0b3IsIHRoaXNEaXJ0eUNsZWFuLCBkaXJ0eUNsZWFuKTtcbiAgICAgICAgICAgIGFkZERpcnR5UHJvcHMoZGVzY3JpcHRvciwgWydjbGFzcyddLCBbdGhpc0RpcnR5Q2xlYW4sIGRpcnR5Q2xlYW5dKTtcblxuICAgICAgICAgICAgLy9hbGwgb2YgdGhlc2UgYXJlIG9wdGlvbmFsXG4gICAgICAgICAgICBkZXNjcmlwdG9yLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAvL2RlZmF1bHQgdG8gc2luZ2xlIGNlbGwgcmFuZ2VzXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmhlaWdodCA9IGhlaWdodCB8fCAxO1xuICAgICAgICAgICAgZGVzY3JpcHRvci53aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNsYXNzID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5zcGFjZSA9IHNwYWNlIHx8IGRlc2NyaXB0b3Iuc3BhY2U7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXJ0eTogZGlydHlDbGVhbi5pc0RpcnR5XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGFwaTtcbn07IiwidmFyIGN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tLWV2ZW50Jyk7XG5cbnZhciBQUk9QU19UT19DT1BZX0ZST01fTU9VU0VfRVZFTlRTID0gWydjbGllbnRYJywgJ2NsaWVudFknLCAnZ3JpZFgnLCAnZ3JpZFknLCAnbGF5ZXJYJywgJ2xheWVyWScsICdyb3cnLCAnY29sJywgJ3JlYWxSb3cnLCAncmVhbENvbCddO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBtb2RlbCA9IHt9O1xuXG4gICAgdmFyIHdhc0RyYWdnZWQgPSBmYWxzZTtcblxuICAgIG1vZGVsLl9hbm5vdGF0ZUV2ZW50ID0gZnVuY3Rpb24gYW5ub3RhdGVFdmVudChlKSB7XG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgZS53YXNEcmFnZ2VkID0gd2FzRHJhZ2dlZDtcbiAgICAgICAgICAgIC8qIGpzaGludCAtVzA4NiAqL1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgIC8qIGpzaGludCArVzA4NiAqL1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgY2FzZSAnZGJsY2xpY2snOlxuICAgICAgICAgICAgICAgIG1vZGVsLl9hbm5vdGF0ZUV2ZW50SW50ZXJuYWwoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2RlbC5fYW5ub3RhdGVFdmVudEZyb21WaWV3Q29vcmRzID0gZnVuY3Rpb24gKGUsIHZpZXdSb3csIHZpZXdDb2wpIHtcbiAgICAgICAgZS5yZWFsUm93ID0gdmlld1JvdztcbiAgICAgICAgZS5yZWFsQ29sID0gdmlld0NvbDtcbiAgICAgICAgZS52aXJ0dWFsUm93ID0gZ3JpZC52aWV3UG9ydC50b1ZpcnR1YWxSb3coZS5yZWFsUm93KTtcbiAgICAgICAgZS52aXJ0dWFsQ29sID0gZ3JpZC52aWV3UG9ydC50b1ZpcnR1YWxDb2woZS5yZWFsQ29sKTtcbiAgICAgICAgZS5yb3cgPSBlLnZpcnR1YWxSb3cgLSBncmlkLnJvd01vZGVsLm51bUhlYWRlcnMoKTtcbiAgICAgICAgZS5jb2wgPSBlLnZpcnR1YWxDb2wgLSBncmlkLmNvbE1vZGVsLm51bUhlYWRlcnMoKTtcbiAgICB9XG5cbiAgICBtb2RlbC5fYW5ub3RhdGVFdmVudEludGVybmFsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHkgPSBncmlkLnZpZXdQb3J0LnRvR3JpZFkoZS5jbGllbnRZKTtcbiAgICAgICAgdmFyIHggPSBncmlkLnZpZXdQb3J0LnRvR3JpZFgoZS5jbGllbnRYKTtcbiAgICAgICAgdmFyIHZpZXdSb3cgPSBncmlkLnZpZXdQb3J0LmdldFJvd0J5VG9wKHkpO1xuICAgICAgICB2YXIgdmlld0NvbCA9IGdyaWQudmlld1BvcnQuZ2V0Q29sQnlMZWZ0KHgpO1xuICAgICAgICBtb2RlbC5fYW5ub3RhdGVFdmVudEZyb21WaWV3Q29vcmRzKGUsIHZpZXdSb3csIHZpZXdDb2wpO1xuICAgICAgICBlLmdyaWRYID0geDtcbiAgICAgICAgZS5ncmlkWSA9IHk7XG4gICAgfTtcblxuICAgIGdyaWQuZXZlbnRMb29wLmFkZEludGVyY2VwdG9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIG1vZGVsLl9hbm5vdGF0ZUV2ZW50KGUpO1xuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICBzZXR1cERyYWdFdmVudEZvck1vdXNlRG93bihlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0dXBEcmFnRXZlbnRGb3JNb3VzZURvd24oZG93bkV2ZW50KSB7XG4gICAgICAgIHdhc0RyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxhc3REcmFnUm93ID0gZG93bkV2ZW50LnJvdztcbiAgICAgICAgdmFyIGxhc3REcmFnQ29sID0gZG93bkV2ZW50LmNvbDtcbiAgICAgICAgdmFyIGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB1bmJpbmRNb3ZlID0gZ3JpZC5ldmVudExvb3AuYmluZCgnbW91c2Vtb3ZlJywgd2luZG93LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGRyYWdTdGFydGVkICYmICFlLndoaWNoKSB7XG4gICAgICAgICAgICAgICAgLy9nb3QgYSBtb3ZlIGV2ZW50IHdpdGhvdXQgbW91c2UgZG93biB3aGljaCBtZWFucyB3ZSBzb21laG93IG1pc3NlZCB0aGUgbW91c2V1cFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3VzZW1vdmUgdW5iaW5kLCBob3cgb24gZWFydGggZG8gdGhlc2UgaGFwcGVuPycpO1xuICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlVXAoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgd2FzRHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3JlYXRlQW5kRmlyZURyYWdFdmVudCgnZ3JpZC1kcmFnLXN0YXJ0JywgZG93bkV2ZW50KTtcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNyZWF0ZUFuZEZpcmVEcmFnRXZlbnQoJ2dyaWQtZHJhZycsIGUpO1xuXG4gICAgICAgICAgICBpZiAoZS5yb3cgIT09IGxhc3REcmFnUm93IHx8IGUuY29sICE9PSBsYXN0RHJhZ0NvbCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUFuZEZpcmVEcmFnRXZlbnQoJ2dyaWQtY2VsbC1kcmFnJywgZSk7XG5cbiAgICAgICAgICAgICAgICBsYXN0RHJhZ1JvdyA9IGUucm93O1xuICAgICAgICAgICAgICAgIGxhc3REcmFnQ29sID0gZS5jb2w7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVuYmluZFVwID0gZ3JpZC5ldmVudExvb3AuYmluZCgnbW91c2V1cCcsIHdpbmRvdywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VVcChlKSB7XG4gICAgICAgICAgICB1bmJpbmRNb3ZlKCk7XG4gICAgICAgICAgICB1bmJpbmRVcCgpO1xuXG4gICAgICAgICAgICB2YXIgZHJhZ0VuZCA9IGNyZWF0ZURyYWdFdmVudEZyb21Nb3VzZUV2ZW50KCdncmlkLWRyYWctZW5kJywgZSk7XG5cbiAgICAgICAgICAgIC8vcm93LCBjb2wsIHgsIGFuZCB5IHNob3VsZCBpbmhlcml0XG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKGRyYWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhZ0V2ZW50RnJvbU1vdXNlRXZlbnQodHlwZSwgZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjdXN0b21FdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgUFJPUFNfVE9fQ09QWV9GUk9NX01PVVNFX0VWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBldmVudFtwcm9wXSA9IGVbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gZTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFuZEZpcmVEcmFnRXZlbnQodHlwZSwgZSkge1xuICAgICAgICB2YXIgZHJhZyA9IGNyZWF0ZURyYWdFdmVudEZyb21Nb3VzZUV2ZW50KHR5cGUsIGUpO1xuICAgICAgICBpZiAoZS50YXJnZXQpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZHJhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKGRyYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcmFnO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbDtcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcbiAgICB2YXIgZGlydHlDbGVhbiA9IHJlcXVpcmUoJy4uL2RpcnR5LWNsZWFuJykoZ3JpZCk7XG5cblxuICAgIHZhciByb3c7XG4gICAgdmFyIG1vZGVsID0ge2NvbDogMH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVsLCAncm93Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJvdyA9IHI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtb2RlbC5yb3cgPSAwO1xuXG4gICAgbW9kZWwuaXNEaXJ0eSA9IGRpcnR5Q2xlYW4uaXNEaXJ0eTtcblxuICAgIG1vZGVsLnNjcm9sbFRvID0gZnVuY3Rpb24gKHIsIGMsIGRvbnRGaXJlLCBmcm9tUGl4ZWxNb2RlbCkge1xuICAgICAgICBpZiAoaXNOYU4ocikgfHwgaXNOYU4oYykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4Um93ID0gKGdyaWQucm93TW9kZWwubGVuZ3RoKCkgfHwgMSkgLSAxO1xuICAgICAgICB2YXIgbWF4Q29sID0gKGdyaWQuY29sTW9kZWwubGVuZ3RoKCkgfHwgMSkgLSAxO1xuICAgICAgICB2YXIgbGFzdFJvdyA9IG1vZGVsLnJvdztcbiAgICAgICAgdmFyIGxhc3RDb2wgPSBtb2RlbC5jb2w7XG4gICAgICAgIG1vZGVsLnJvdyA9IHV0aWwuY2xhbXAociwgMCwgbWF4Um93KTtcbiAgICAgICAgbW9kZWwuY29sID0gdXRpbC5jbGFtcChjLCAwLCBtYXhDb2wpO1xuICAgICAgICBpZiAobGFzdFJvdyAhPT0gbW9kZWwucm93IHx8IGxhc3RDb2wgIT09IG1vZGVsLmNvbCkge1xuICAgICAgICAgICAgZGlydHlDbGVhbi5zZXREaXJ0eSgpO1xuXG4gICAgICAgICAgICBpZiAoIWRvbnRGaXJlKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuZmlyZSgnZ3JpZC1jZWxsLXNjcm9sbCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZyb21QaXhlbE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLmhlaWdodCgwLCBtb2RlbC5yb3cgLSAxKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLndpZHRoKDAsIG1vZGVsLmNvbCAtIDEpO1xuICAgICAgICAgICAgICAgIGdyaWQucGl4ZWxTY3JvbGxNb2RlbC5zY3JvbGxUbyh0b3AsIGxlZnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRWaXJ0dWFsVG9TY3JvbGwodmlydHVhbENvb3JkLCByb3dPckNvbCkge1xuICAgICAgICByZXR1cm4gdmlydHVhbENvb3JkIC0gZ3JpZFtyb3dPckNvbCArICdNb2RlbCddLm51bUZpeGVkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9Sb3dPckNvbCh2aXJ0dWFsQ29vcmQsIHJvd09yQ29sLCBoZWlnaHRXaWR0aCkge1xuICAgICAgICB2YXIgY3VycmVudFNjcm9sbCA9IG1vZGVsW3Jvd09yQ29sXTtcbiAgICAgICAgdmFyIHNjcm9sbFRvID0gY3VycmVudFNjcm9sbDtcbiAgICAgICAgaWYgKGdyaWQudmlld1BvcnRbcm93T3JDb2wgKyAnSXNJblZpZXcnXSh2aXJ0dWFsQ29vcmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG87XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0U2Nyb2xsID0gY29udmVydFZpcnR1YWxUb1Njcm9sbCh2aXJ0dWFsQ29vcmQsIHJvd09yQ29sKTtcbiAgICAgICAgaWYgKHRhcmdldFNjcm9sbCA8IGN1cnJlbnRTY3JvbGwpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvID0gdGFyZ2V0U2Nyb2xsO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFNjcm9sbCA+IGN1cnJlbnRTY3JvbGwpIHtcblxuICAgICAgICAgICAgdmFyIGxlbmd0aFRvQ2VsbCA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsW2hlaWdodFdpZHRoXSgwLCB2aXJ0dWFsQ29vcmQpO1xuICAgICAgICAgICAgdmFyIG51bUZpeGVkID0gZ3JpZFtyb3dPckNvbCArICdNb2RlbCddLm51bUZpeGVkKCk7XG4gICAgICAgICAgICBzY3JvbGxUbyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbnVtRml4ZWQ7IGkgPCB2aXJ0dWFsQ29vcmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxlbmd0aFRvQ2VsbCAtPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFtoZWlnaHRXaWR0aF0oaSk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG8gPSBpIC0gKG51bUZpeGVkIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aFRvQ2VsbCA8PSBncmlkLnZpZXdQb3J0W2hlaWdodFdpZHRoXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2Nyb2xsVG87XG4gICAgfVxuXG4gICAgbW9kZWwuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbiAodnIsIHZjKSB7XG4gICAgICAgIHZyID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuY2xhbXBSb3codnIpO1xuICAgICAgICB2YyA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLmNsYW1wQ29sKHZjKTtcbiAgICAgICAgdmFyIG5ld1JvdyA9IGdldFNjcm9sbFRvUm93T3JDb2wodnIsICdyb3cnLCAnaGVpZ2h0Jyk7XG4gICAgICAgIHZhciBuZXdDb2wgPSBnZXRTY3JvbGxUb1Jvd09yQ29sKHZjLCAnY29sJywgJ3dpZHRoJyk7XG4gICAgICAgIG1vZGVsLnNjcm9sbFRvKG5ld1JvdywgbmV3Q29sKTtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gbW9kZWw7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBhcGkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC1yb3ctY29sLW1vZGVsJykoZ3JpZCwgJ2NvbCcsICd3aWR0aCcsIDEwMCk7XG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCJ2YXIgZWxlbWVudENsYXNzID0gcmVxdWlyZSgnZWxlbWVudC1jbGFzcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGFwaSA9IHthbm5vdGF0ZURlY29yYXRvcjogbWFrZVJlb3JkZXJEZWNvcmF0b3J9O1xuXG4gICAgZnVuY3Rpb24gbWFrZVJlb3JkZXJEZWNvcmF0b3IoaGVhZGVyRGVjb3JhdG9yKSB7XG4gICAgICAgIHZhciBjb2wgPSBoZWFkZXJEZWNvcmF0b3IubGVmdDtcbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdCA9IGdyaWQuZGVjb3JhdG9ycy5jcmVhdGUoMCwgdW5kZWZpbmVkLCBJbmZpbml0eSwgdW5kZWZpbmVkLCAncHgnLCAncmVhbCcpO1xuXG4gICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3QucG9zdFJlbmRlciA9IGZ1bmN0aW9uIChkaXYpIHtcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dyaWQtZHJhZy1yZWN0Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5yZWFsQ29sIDwgZ3JpZC5jb2xNb2RlbC5udW1GaXhlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGdyaWQuZGVjb3JhdG9ycy5hZGQoaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdCk7XG5cbiAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3Qud2lkdGggPSBncmlkLnZpZXdQb3J0LmdldENvbFdpZHRoKGNvbCk7XG4gICAgICAgICAgICB2YXIgY29sT2Zmc2V0ID0gZS5ncmlkWCAtIGhlYWRlckRlY29yYXRvci5nZXREZWNvcmF0b3JMZWZ0KCk7XG5cbiAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3QuX3RhcmdldENvbCA9IGdyaWQuZGVjb3JhdG9ycy5jcmVhdGUoMCwgdW5kZWZpbmVkLCBJbmZpbml0eSwgMSwgJ2NlbGwnLCAncmVhbCcpO1xuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sLnBvc3RSZW5kZXIgPSBmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1yZW9yZGVyLXRhcmdldCcpO1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3QuX3RhcmdldENvbC5fcmVuZGVyZWRFbGVtID0gZGl2O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdyaWQuZGVjb3JhdG9ycy5hZGQoaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sKTtcblxuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl91bmJpbmREcmFnID0gZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0LmxlZnQgPSB1dGlsLmNsYW1wKGUuZ3JpZFggLSBjb2xPZmZzZXQsIGdyaWQudmlld1BvcnQuZ2V0Q29sTGVmdChncmlkLmNvbE1vZGVsLm51bUZpeGVkKCkpLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sLmxlZnQgPSB1dGlsLmNsYW1wKGUucmVhbENvbCwgZ3JpZC5jb2xNb2RlbC5udW1GaXhlZCgpLCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgaWYgKGUucmVhbENvbCA+IGNvbCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Q2xhc3MoaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sLl9yZW5kZXJlZEVsZW0pLmFkZCgncmlnaHQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Q2xhc3MoaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sLl9yZW5kZXJlZEVsZW0pLnJlbW92ZSgncmlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fdW5iaW5kRHJhZ0VuZCA9IGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhZy1lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDb2wgPSBoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wubGVmdDtcblxuICAgICAgICAgICAgICAgIGdyaWQuY29sTW9kZWwubW92ZShncmlkLnZpZXdQb3J0LnRvVmlydHVhbENvbChjb2wpLCBncmlkLnZpZXdQb3J0LnRvVmlydHVhbENvbCh0YXJnZXRDb2wpKTtcbiAgICAgICAgICAgICAgICBncmlkLmRlY29yYXRvcnMucmVtb3ZlKFtoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wsIGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3RdKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWcoKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWdFbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhlYWRlckRlY29yYXRvci5wb3N0UmVuZGVyID0gZnVuY3Rpb24gKGRpdikge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1jb2wtcmVvcmRlcicpO1xuICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnLXN0YXJ0JywgZGl2LCBoZWFkZXJEZWNvcmF0b3IuX29uRHJhZ1N0YXJ0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gaGVhZGVyRGVjb3JhdG9yO1xuICAgIH1cblxuICAgIHJlcXVpcmUoJy4uL2hlYWRlci1kZWNvcmF0b3JzJykoZ3JpZCwgYXBpKTtcblxuICAgIHJldHVybiBhcGk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBhcGkgPSB7YW5ub3RhdGVEZWNvcmF0b3I6IGFubm90YXRlRGVjb3JhdG9yfTtcblxuICAgIGZ1bmN0aW9uIGFubm90YXRlRGVjb3JhdG9yKGhlYWRlckRlY29yYXRvcikge1xuICAgICAgICB2YXIgY29sID0gaGVhZGVyRGVjb3JhdG9yLmxlZnQ7XG4gICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ0xpbmUgPSBncmlkLmRlY29yYXRvcnMuY3JlYXRlKDAsIHVuZGVmaW5lZCwgSW5maW5pdHksIDEsICdweCcsICdyZWFsJyk7XG5cbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnTGluZS5wb3N0UmVuZGVyID0gZnVuY3Rpb24gKGRpdikge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1kcmFnLWxpbmUnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLmFkZChoZWFkZXJEZWNvcmF0b3IuX2RyYWdMaW5lKTtcblxuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl91bmJpbmREcmFnID0gZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluWCA9IGhlYWRlckRlY29yYXRvci5nZXREZWNvcmF0b3JMZWZ0KCkgKyAxMDtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX2RyYWdMaW5lLmxlZnQgPSBNYXRoLm1heChlLmdyaWRYLCBtaW5YKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWdFbmQgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWctZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBncmlkLmNvbE1vZGVsLmdldChncmlkLnZpZXdQb3J0LnRvVmlydHVhbENvbChjb2wpKS53aWR0aCA9IGhlYWRlckRlY29yYXRvci5fZHJhZ0xpbmUubGVmdCAtIGhlYWRlckRlY29yYXRvci5nZXREZWNvcmF0b3JMZWZ0KCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLnJlbW92ZShoZWFkZXJEZWNvcmF0b3IuX2RyYWdMaW5lKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWcoKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWdFbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhlYWRlckRlY29yYXRvci5wb3N0UmVuZGVyID0gZnVuY3Rpb24gKGRpdikge1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKDUwJSknO1xuICAgICAgICAgICAgZGl2LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKDUwJSknO1xuXG4gICAgICAgICAgICBkaXYuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2xlZnQnKTtcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2NvbC1yZXNpemUnKTtcblxuICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnLXN0YXJ0JywgZGl2LCBoZWFkZXJEZWNvcmF0b3IuX29uRHJhZ1N0YXJ0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXF1aXJlKCcuLi9oZWFkZXItZGVjb3JhdG9ycycpKGdyaWQsIGFwaSk7XG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCJ2YXIgY3RybE9yQ21kID0gcmVxdWlyZSgnLi4vY3RybC1vci1jbWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgaWYgKGN0cmxPckNtZChlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LmlzKGtleS5jb2RlLmFsbnVtLmMsIGUud2hpY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ByZXBhcmUgZm9yIGNvcHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3B5RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gZ3JpZC5uYXZpZ2F0aW9uTW9kZWwuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YWxpZCBzZWxlY3Rpb24gcmFuZ2UgY2Fubm90IGdvIHRvIC0xXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uUmFuZ2UudG9wID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGdyaWQubmF2aWdhdGlvbk1vZGVsLmZvY3VzLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZ3JpZC5uYXZpZ2F0aW9uTW9kZWwuZm9jdXMuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBzZWxlY3Rpb25SYW5nZS50b3A7IHIgPD0gc2VsZWN0aW9uUmFuZ2UudG9wICsgc2VsZWN0aW9uUmFuZ2UuaGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGEucHVzaChyb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IHNlbGVjdGlvblJhbmdlLmxlZnQ7IGMgPD0gc2VsZWN0aW9uUmFuZ2UubGVmdCArIHNlbGVjdGlvblJhbmdlLndpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZ3JpZC5kYXRhTW9kZWwuZ2V0Q29weURhdGEociwgYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xufTsiLCJ2YXIgZWxlbWVudENsYXNzID0gcmVxdWlyZSgnZWxlbWVudC1jbGFzcycpO1xudmFyIGRpcnR5Q2xlYW4gPSByZXF1aXJlKCcuLi9kaXJ0eS1jbGVhbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBncmlkID0ge307XG5cbiAgICAvL3RoZSBvcmRlciBoZXJlIG1hdHRlcnMgYmVjYXVzZSBzb21lIG9mIHRoZXNlIGRlcGVuZCBvbiBlYWNoIG90aGVyXG4gICAgZ3JpZC5ldmVudExvb3AgPSByZXF1aXJlKCcuLi9ldmVudC1sb29wJykoZ3JpZCk7XG4gICAgZ3JpZC5kZWNvcmF0b3JzID0gcmVxdWlyZSgnLi4vZGVjb3JhdG9ycycpKGdyaWQpO1xuICAgIGdyaWQuY2VsbENsYXNzZXMgPSByZXF1aXJlKCcuLi9jZWxsLWNsYXNzZXMnKShncmlkKTtcbiAgICBncmlkLnJvd01vZGVsID0gcmVxdWlyZSgnLi4vcm93LW1vZGVsJykoZ3JpZCk7XG4gICAgZ3JpZC5jb2xNb2RlbCA9IHJlcXVpcmUoJy4uL2NvbC1tb2RlbCcpKGdyaWQpO1xuICAgIGdyaWQuZGF0YU1vZGVsID0gcmVxdWlyZSgnLi4vc2ltcGxlLWRhdGEtbW9kZWwnKShncmlkKTtcbiAgICBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbCA9IHJlcXVpcmUoJy4uL3ZpcnR1YWwtcGl4ZWwtY2VsbC1tb2RlbCcpKGdyaWQpO1xuICAgIGdyaWQuY2VsbFNjcm9sbE1vZGVsID0gcmVxdWlyZSgnLi4vY2VsbC1zY3JvbGwtbW9kZWwnKShncmlkKTtcbiAgICBncmlkLmNlbGxNb3VzZU1vZGVsID0gcmVxdWlyZSgnLi4vY2VsbC1tb3VzZS1tb2RlbCcpKGdyaWQpO1xuXG4gICAgZ3JpZC52aWV3UG9ydCA9IHJlcXVpcmUoJy4uL3ZpZXctcG9ydCcpKGdyaWQpO1xuICAgIGdyaWQudmlld0xheWVyID0gcmVxdWlyZSgnLi4vdmlldy1sYXllcicpKGdyaWQpO1xuXG4gICAgLy90aGluZ3Mgd2l0aCBsb2dpYyB0aGF0IGFsc28gcmVnaXN0ZXIgZGVjb3JhdG9ycyAoc2xpZ2h0bHkgbGVzcyBjb3JlIHRoYW4gdGhlIG90aGVyIG1vZGVscylcbiAgICBncmlkLm5hdmlnYXRpb25Nb2RlbCA9IHJlcXVpcmUoJy4uL25hdmlnYXRpb24tbW9kZWwnKShncmlkKTtcbiAgICBncmlkLnBpeGVsU2Nyb2xsTW9kZWwgPSByZXF1aXJlKCcuLi9waXhlbC1zY3JvbGwtbW9kZWwnKShncmlkKTtcbiAgICBncmlkLmNvbFJlc2l6ZSA9IHJlcXVpcmUoJy4uL2NvbC1yZXNpemUnKShncmlkKTtcbiAgICBncmlkLmNvbFJlb3JkZXIgPSByZXF1aXJlKCcuLi9jb2wtcmVvcmRlcicpKGdyaWQpO1xuICAgIGdyaWQuc2hvd0hpZGRlbkNvbHMgPSByZXF1aXJlKCcuLi9zaG93LWhpZGRlbi1jb2xzJykoZ3JpZCk7XG4gICAgcmVxdWlyZSgnLi4vY29weS1wYXN0ZScpKGdyaWQpO1xuXG4gICAgdmFyIGRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBncmlkLnJlcXVlc3REcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWdyaWQuZXZlbnRMb29wLmlzUnVubmluZykge1xuICAgICAgICAgICAgZ3JpZC52aWV3TGF5ZXIuZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmF3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5hZGRFeGl0TGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZHJhd1JlcXVlc3RlZCkge1xuICAgICAgICAgICAgZ3JpZC52aWV3TGF5ZXIuZHJhdygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGb2N1c1RleHRBcmVhKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2R0cycsICdncmlkLXRleHRhcmVhJyk7XG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9ICctMTAwMDAwcHgnO1xuICAgICAgICB0ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Q2xhc3MoY29udGFpbmVyKS5hZGQoJ2ZvY3VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0YXJlYS5zZWxlY3QoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Q2xhc3MoY29udGFpbmVyKS5yZW1vdmUoJ2ZvY3VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRleHRhcmVhKSB7XG4gICAgICAgICAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRleHRhcmVhO1xuICAgIH1cblxuICAgIGdyaWQuYnVpbGQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIGdyaWQudGV4dGFyZWEgPSBjcmVhdGVGb2N1c1RleHRBcmVhKGNvbnRhaW5lcik7XG4gICAgICAgIGdyaWQudmlld1BvcnQuc2l6ZVRvQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIGdyaWQudmlld0xheWVyLmJ1aWxkKGNvbnRhaW5lcik7XG4gICAgICAgIGdyaWQuZXZlbnRMb29wLnNldENvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH07XG5cbiAgICBncmlkLm1ha2VEaXJ0eUNsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGlydHlDbGVhbihncmlkKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGdyaWQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC93aW4vaSkgPyBlLmN0cmxLZXkgOiBlLm1ldGFLZXkpXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCkge1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpOyAgLy8gTVVTVCBiZSAnQ3VzdG9tRXZlbnQnXG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgcmV0dXJuIGV2ZW50O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgZGVsYXkpIHtcbiAgICB2YXIgZiA9IGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgaWYgKGYudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGYudGltZW91dCk7XG4gICAgICAgICAgICBmLnRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZi50aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIGY7XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIG1ha2VEaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKTtcbnZhciBwb3NpdGlvblJhbmdlID0gcmVxdWlyZSgnLi4vcG9zaXRpb24tcmFuZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGRpcnR5Q2xlYW4gPSBtYWtlRGlydHlDbGVhbihncmlkKTtcblxuICAgIHZhciBhbGl2ZURlY29yYXRvcnMgPSBbXTtcbiAgICB2YXIgZGVhZERlY29yYXRvcnMgPSBbXTtcblxuICAgIHZhciBkZWNvcmF0b3JzID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGFsaXZlRGVjb3JhdG9ycy5wdXNoKGRlY29yYXRvcik7XG4gICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc0FycmF5KGRlY29yYXRvcnMpKSB7XG4gICAgICAgICAgICAgICAgZGVjb3JhdG9ycyA9IFtkZWNvcmF0b3JzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29yYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxpdmVEZWNvcmF0b3JzLmluZGV4T2YoZGVjb3JhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaXZlRGVjb3JhdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkZWFkRGVjb3JhdG9ycy5wdXNoKGRlY29yYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5Q2xlYW4uc2V0RGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QWxpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGl2ZURlY29yYXRvcnMuc2xpY2UoMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvcEFsbERlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbGREZWFkID0gZGVhZERlY29yYXRvcnM7XG4gICAgICAgICAgICBkZWFkRGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG9sZERlYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGRpcnR5Q2xlYW4uaXNEaXJ0eSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAodCwgbCwgaCwgdywgdSwgcykge1xuICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IHt9O1xuICAgICAgICAgICAgdmFyIHRoaXNEaXJ0eUNsZWFuID0gbWFrZURpcnR5Q2xlYW4oZ3JpZCk7XG5cbiAgICAgICAgICAgIC8vbWl4aW4gdGhlIHBvc2l0aW9uIHJhbmdlIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgIHBvc2l0aW9uUmFuZ2UoZGVjb3JhdG9yLCB0aGlzRGlydHlDbGVhbiwgZGlydHlDbGVhbik7XG4gICAgICAgICAgICBkZWNvcmF0b3IudG9wID0gdDtcbiAgICAgICAgICAgIGRlY29yYXRvci5sZWZ0ID0gbDtcbiAgICAgICAgICAgIGRlY29yYXRvci5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgZGVjb3JhdG9yLndpZHRoID0gdztcbiAgICAgICAgICAgIGRlY29yYXRvci51bml0cyA9IHUgfHwgZGVjb3JhdG9yLnVuaXRzO1xuICAgICAgICAgICAgZGVjb3JhdG9yLnNwYWNlID0gcyB8fCBkZWNvcmF0b3Iuc3BhY2U7XG5cbiAgICAgICAgICAgIC8vdGhleSBjYW4gb3ZlcnJpZGUgYnV0IHdlIHNob3VsZCBoYXZlIGFuIGVtcHR5IGRlZmF1bHQgdG8gcHJldmVudCBucGVzXG4gICAgICAgICAgICBkZWNvcmF0b3IucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUucmlnaHQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdG9yLnBvc3RSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yLnBvc3RSZW5kZXIoZGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIHJldHVybiBkZWNvcmF0b3JzO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG4gICAgdmFyIGRpcnR5ID0gdHJ1ZTtcblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBpLnNldENsZWFuKCk7XG4gICAgfSk7XG5cblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNDbGVhbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICFkaXJ0eTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vd2hlbiB0aGluZ3MgYXJlIGluaXRhbGl6aW5nIHNvbWV0aW1lcyB0aGlzIGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgICAvL3dlIGhhdmUgdG8gaG9wZSB0aGF0IGF0IHRoZSBlbmQgb2YgaW5pdGlhbGl6YXRpb24gdGhlIGdyaWQgd2lsbCBjYWxsIHJlcXVlc3QgZHJhdyBpdHNlbGZcbiAgICAgICAgICAgIGlmIChncmlkLnJlcXVlc3REcmF3KSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZXF1ZXN0RHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRDbGVhbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbn07IiwidmFyIG1vdXNld2hlZWwgPSByZXF1aXJlKCcuLi9tb3VzZXdoZWVsJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsaXN0ZW5lcnMgPSByZXF1aXJlKCcuLi9saXN0ZW5lcnMnKTtcblxudmFyIEVWRU5UUyA9IFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2Vtb3ZlJywgJ2RibGNsaWNrJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnXTtcblxudmFyIEdSSURfRVZFTlRTID0gWydncmlkLWRyYWctc3RhcnQnLCAnZ3JpZC1kcmFnJywgJ2dyaWQtY2VsbC1kcmFnJywgJ2dyaWQtZHJhZy1lbmQnXTtcblxudmFyIGV2ZW50TG9vcCA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG4gICAgdmFyIGVsb29wID0ge1xuICAgICAgICBpc1J1bm5pbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVyc0J5TmFtZSA9IHt9O1xuICAgIHZhciBkb21VbmJpbmRGbnMgPSBbXTtcblxuICAgIHZhciB1bmJpbmRBbGw7XG5cbiAgICBlbG9vcC5zZXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB1bmJpbmRNb3VzZVdoZWVsRm4gPSBtb3VzZXdoZWVsLmJpbmQoY29udGFpbmVyLCBtYWluTG9vcCk7XG5cbiAgICAgICAgRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGJpbmRUb0RvbUVsZW1lbnQoY29udGFpbmVyLCBuYW1lLCBtYWluTG9vcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEdSSURfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGJpbmRUb0RvbUVsZW1lbnQod2luZG93LCBuYW1lLCBtYWluTG9vcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVuYmluZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVuYmluZE1vdXNlV2hlZWxGbigpO1xuXG4gICAgICAgICAgICAvL2hhdmUgdG8gY29weSB0aGUgYXJyYXkgc2luY2UgdGhlIHVuYmluZCB3aWxsIGFjdHVhbGx5IHJlbW92ZSBpdHNlbGYgZnJvbSB0aGUgYXJyYXkgd2hpY2ggbW9kaWZpZXMgaXQgbWlkIGl0ZXJhdGlvblxuICAgICAgICAgICAgZG9tVW5iaW5kRm5zLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHVuYmluZCkge1xuICAgICAgICAgICAgICAgIHVuYmluZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEhhbmRsZXJzKG5hbWUpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gaGFuZGxlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnNCeU5hbWVbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZFRvRG9tRWxlbWVudChlbGVtLCBuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB2YXIgdW5iaW5kRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgZG9tVW5iaW5kRm5zLnNwbGljZShkb21VbmJpbmRGbnMuaW5kZXhPZih1bmJpbmRGbiksIDEpO1xuICAgICAgICB9O1xuICAgICAgICBkb21VbmJpbmRGbnMucHVzaCh1bmJpbmRGbik7XG4gICAgICAgIHJldHVybiB1bmJpbmRGbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIYW5kbGVyRnJvbUFyZ3MoYXJncykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgZWxvb3AuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB2YXIgbmFtZSA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBoYW5kbGVyID0gZ2V0SGFuZGxlckZyb21BcmdzKGFyZ3MpO1xuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93ICdjYW5ub3QgYmluZCB3aXRob3V0IGF0IGxlYXN0IG5hbWUgYW5kIGZ1bmN0aW9uJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGVsZW0gPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbC5pc0VsZW1lbnQoYXJnKSB8fCBhcmcgPT09IHdpbmRvdyB8fCBhcmcgPT09IGRvY3VtZW50O1xuICAgICAgICB9KVswXTtcblxuICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgIGdldEhhbmRsZXJzKG5hbWUpLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKG5hbWUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsb29wV2l0aChoYW5kbGVyKTtcbiAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRoZSBlbGVtIGNhbiByZWNlaXZlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKGVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaW5kVG9Eb21FbGVtZW50KGVsZW0sIG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBlbG9vcC5iaW5kT25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGdldEhhbmRsZXJGcm9tQXJncyhhcmdzKTtcbiAgICAgICAgYXJncy5zcGxpY2UoYXJncy5pbmRleE9mKGhhbmRsZXIpLCAxLCBmdW5jdGlvbiBiaW5kT25jZUhhbmRsZXIoZSkge1xuICAgICAgICAgICAgdW5iaW5kKCk7XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVuYmluZCA9IGVsb29wLmJpbmQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB1bmJpbmQ7XG4gICAgfVxuXG4gICAgZWxvb3AuZmlyZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudCA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycgPyB7dHlwZTogZXZlbnR9IDogZXZlbnQ7XG4gICAgICAgIG1haW5Mb29wKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIGludGVyY2VwdG9ycyA9IGxpc3RlbmVycygpO1xuICAgIHZhciBleGl0TGlzdGVuZXJzID0gbGlzdGVuZXJzKCk7XG5cbiAgICBlbG9vcC5hZGRJbnRlcmNlcHRvciA9IGludGVyY2VwdG9ycy5hZGRMaXN0ZW5lcjtcbiAgICBlbG9vcC5hZGRFeGl0TGlzdGVuZXIgPSBleGl0TGlzdGVuZXJzLmFkZExpc3RlbmVyO1xuXG4gICAgZnVuY3Rpb24gbG9vcFdpdGgoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBsb29wKGUsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWFpbkxvb3AgPSBsb29wV2l0aChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvL2hhdmUgdG8gY29weSB0aGUgYXJyYXkgYmVjYXVzZSBoYW5kbGVycyBjYW4gdW5iaW5kIHRoZW1zZWx2ZXMgd2hpY2ggbW9kaWZpZXMgdGhlIGFycmF5XG4gICAgICAgIC8vd2UgdXNlIHNvbWUgc28gdGhhdCB3ZSBjYW4gYnJlYWsgb3V0IG9mIHRoZSBsb29wIGlmIG5lZWQgYmVcbiAgICAgICAgZ2V0SGFuZGxlcnMoZS50eXBlKS5zbGljZSgwKS5zb21lKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICAgICAgaWYgKGUuZ3JpZFN0b3BCdWJibGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxvb3AoZSwgYm9keUZuKSB7XG4gICAgICAgIHZhciBpc091dGVyTG9vcFJ1bm5pbmcgPSBlbG9vcC5pc1J1bm5pbmc7XG4gICAgICAgIGVsb29wLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIGludGVyY2VwdG9ycy5ub3RpZnkoZSk7XG4gICAgICAgIGlmICghZS5ncmlkU3RvcEJ1YmJsaW5nKSB7XG4gICAgICAgICAgICBib2R5Rm4oZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzT3V0ZXJMb29wUnVubmluZykge1xuICAgICAgICAgICAgZWxvb3AuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBleGl0TGlzdGVuZXJzLm5vdGlmeShlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsb29wLmJpbmQoJ2dyaWQtZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5iaW5kQWxsKCk7XG4gICAgICAgIGVsb29wLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBlbG9vcC5zdG9wQnViYmxpbmcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmdyaWRTdG9wQnViYmxpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVsb29wO1xufTtcblxuXG5ldmVudExvb3AuRVZFTlRTID0gRVZFTlRTO1xuZXZlbnRMb29wLkdSSURfRVZFTlRTID0gR1JJRF9FVkVOVFM7XG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50TG9vcDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCwgbW9kZWwpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGFwaSA9IG1vZGVsIHx8IHt9O1xuICAgIGFwaS5fZGVjb3JhdG9ycyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gbWFrZURlY29yYXRvcihjb2wpIHtcbiAgICAgICAgdmFyIGRlY29yYXRvciA9IGdyaWQuZGVjb3JhdG9ycy5jcmVhdGUoMCwgY29sLCAxLCAxLCAnY2VsbCcsICdyZWFsJyk7XG5cblxuICAgICAgICBkZWNvcmF0b3IuZ2V0RGVjb3JhdG9yTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFJlY3QgPSBkZWNvcmF0b3IuYm91bmRpbmdCb3ggJiYgZGVjb3JhdG9yLmJvdW5kaW5nQm94LmdldENsaWVudFJlY3RzKCkgJiYgZGVjb3JhdG9yLmJvdW5kaW5nQm94LmdldENsaWVudFJlY3RzKClbMF0gfHwge307XG4gICAgICAgICAgICByZXR1cm4gZ3JpZC52aWV3UG9ydC50b0dyaWRYKGZpcnN0UmVjdC5sZWZ0KSB8fCAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhcGkuYW5ub3RhdGVEZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGFwaS5hbm5vdGF0ZURlY29yYXRvcihkZWNvcmF0b3IpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgIH1cblxuICAgIGFwaS5tYWtlRGVjb3JhdG9yID0gYXBpLm1ha2VEZWNvcmF0b3IgfHwgbWFrZURlY29yYXRvcjtcblxuICAgIGZ1bmN0aW9uIGVuc3VyZURlY29yYXRvclBlckNvbCgpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBncmlkLnZpZXdQb3J0LmNvbHM7IGMrKykge1xuICAgICAgICAgICAgaWYgKCFhcGkuX2RlY29yYXRvcnNbY10pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpLmlzTmVlZGVkICYmICFhcGkuaXNOZWVkZWQoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBhcGkubWFrZURlY29yYXRvcihjKTtcbiAgICAgICAgICAgICAgICBhcGkuX2RlY29yYXRvcnNbY10gPSBkZWNvcmF0b3I7XG4gICAgICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLmFkZChkZWNvcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC12aWV3cG9ydC1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVuc3VyZURlY29yYXRvclBlckNvbCgpO1xuICAgIH0pO1xuICAgIGVuc3VyZURlY29yYXRvclBlckNvbCgpO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07IiwiLypcbiBBIHNpbXBsZSBwYWNrYWdlIGZvciBjcmVhdGluZyBhIGxpc3Qgb2YgbGlzdGVuZXJzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuZCBub3RpZmllZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvL3JldHVybnMgYSByZW1vdmFsIGZ1bmN0aW9uIHRvIHVuYmluZCB0aGUgbGlzdGVuZXJcbiAgICAgICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goZm4pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVycy5pbmRleE9mKGZuKSwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBub3RpZnk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn07IiwidmFyIEVWRU5UX05BTUVTID0gWydtb3VzZXdoZWVsJywgJ3doZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJ107XG5cbnZhciBhcGkgPSB7XG4gICAgZ2V0RGVsdGE6IGZ1bmN0aW9uIChldmVudCwgeGF4aXMpIHtcbiAgICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHsgLy9mb3IgZXZlcnl0aGluZyBidXQgZmlyZWZveFxuICAgICAgICAgICAgdmFyIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YVk7XG4gICAgICAgICAgICBpZiAoeGF4aXMpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7IC8vZm9yIGZpcmVmb3ggcHJlIHZlcnNpb24gMTdcbiAgICAgICAgICAgIGlmIChldmVudC5heGlzICYmICgoZXZlbnQuYXhpcyA9PT0gMSAmJiB4YXhpcykgfHwgKGV2ZW50LmF4aXMgPT09IDIgJiYgIXhheGlzKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBldmVudC5kZXRhaWwgKiAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZWx0YVggfHwgZXZlbnQuZGVsdGFZKSB7XG4gICAgICAgICAgICBpZiAoeGF4aXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBldmVudC5kZWx0YVg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIGV2ZW50LmRlbHRhWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLy9iaW5kcyBhIGNyb3NzIGJyb3dzZXIgbm9ybWFsaXplZCBtb3VzZXdoZWVsIGV2ZW50LCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB1bmJpbmQgdGhlIGxpc3RlbmVyO1xuICAgIGJpbmQ6IGZ1bmN0aW9uIChlbGVtLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG5vcm1hbGl6ZVdoZWVsRXZlbnQoZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIEVWRU5UX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBub3JtYWxpemVkTGlzdGVuZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgRVZFTlRfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBub3JtYWxpemVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplV2hlZWxFdmVudFxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplV2hlZWxFdmVudChlKSB7XG4gICAgdmFyIGRlbHRhWCA9IGFwaS5nZXREZWx0YShlLCB0cnVlKTtcbiAgICB2YXIgZGVsdGFZID0gYXBpLmdldERlbHRhKGUpO1xuICAgIHZhciBuZXdFdmVudCA9IE9iamVjdC5jcmVhdGUoZSxcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsdGFZOiB7dmFsdWU6IGRlbHRhWX0sXG4gICAgICAgICAgICBkZWx0YVg6IHt2YWx1ZTogZGVsdGFYfSxcbiAgICAgICAgICAgIHR5cGU6IHt2YWx1ZTogJ21vdXNld2hlZWwnfVxuICAgICAgICB9KTtcblxuICAgIG5ld0V2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXdFdmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV3RXZlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBpOyIsInZhciBrZXkgPSByZXF1aXJlKCdrZXknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHJhbmdlVXRpbCA9IHJlcXVpcmUoJy4uL3JhbmdlLXV0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIG1vZGVsID0ge1xuICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgcm93OiAwLFxuICAgICAgICAgICAgY29sOiAwXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGZvY3VzQ2xhc3MgPSBncmlkLmNlbGxDbGFzc2VzLmNyZWF0ZSgwLCAwLCAnZm9jdXMnKTtcbiAgICBncmlkLmNlbGxDbGFzc2VzLmFkZChmb2N1c0NsYXNzKTtcblxuICAgIG1vZGVsLmZvY3VzRGVjb3JhdG9yID0gZ3JpZC5kZWNvcmF0b3JzLmNyZWF0ZSgwLCAwLCAxLCAxKTtcbiAgICBtb2RlbC5mb2N1c0RlY29yYXRvci5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkZWZhdWx0UmVuZGVyKCk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dyaWQtZm9jdXMtZGVjb3JhdG9yJyk7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfTtcbiAgICBncmlkLmRlY29yYXRvcnMuYWRkKG1vZGVsLmZvY3VzRGVjb3JhdG9yKTtcblxuXG4gICAgZnVuY3Rpb24gY2xhbXBSb3dUb01pbk1heChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xhbXAocm93LCAwLCBncmlkLnJvd01vZGVsLmxlbmd0aCgpIC0gMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDb2xUb01pbk1heChjb2wpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xhbXAoY29sLCAwLCBncmlkLmNvbE1vZGVsLmxlbmd0aCgpIC0gMSk7XG4gICAgfVxuXG4gICAgbW9kZWwuc2V0Rm9jdXMgPSBmdW5jdGlvbiBzZXRGb2N1cyhyb3csIGNvbCwgb3B0aW9uYWxFdmVudCkge1xuICAgICAgICByb3cgPSBjbGFtcFJvd1RvTWluTWF4KHJvdyk7XG4gICAgICAgIGNvbCA9IGNsYW1wQ29sVG9NaW5NYXgoY29sKTtcbiAgICAgICAgbW9kZWwuZm9jdXMucm93ID0gcm93O1xuICAgICAgICBtb2RlbC5mb2N1cy5jb2wgPSBjb2w7XG4gICAgICAgIGZvY3VzQ2xhc3MudG9wID0gcm93O1xuICAgICAgICBmb2N1c0NsYXNzLmxlZnQgPSBjb2w7XG4gICAgICAgIG1vZGVsLmZvY3VzRGVjb3JhdG9yLnRvcCA9IHJvdztcbiAgICAgICAgbW9kZWwuZm9jdXNEZWNvcmF0b3IubGVmdCA9IGNvbDtcbiAgICAgICAgZ3JpZC5jZWxsU2Nyb2xsTW9kZWwuc2Nyb2xsSW50b1ZpZXcocm93LCBjb2wpO1xuICAgICAgICAvL2ZvY3VzIGNoYW5nZXMgYWx3YXlzIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBhcnJvdyA9IGtleS5jb2RlLmFycm93O1xuICAgICAgICBpZiAoIWtleS5pcyhhcnJvdywgZS53aGljaCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvY3VzIGxvZ2ljXG5cbiAgICAgICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAvL2lmIG5vdGhpbmcgY2hhbmdlcyBncmVhdCB3ZSdsbCBzdGF5IHdoZXJlIHdlIGFyZVxuICAgICAgICAgICAgdmFyIG5hdlRvUm93ID0gbW9kZWwuZm9jdXMucm93O1xuICAgICAgICAgICAgdmFyIG5hdlRvQ29sID0gbW9kZWwuZm9jdXMuY29sO1xuXG5cbiAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgYXJyb3cuZG93bi5jb2RlOlxuICAgICAgICAgICAgICAgICAgICBuYXZUb1JvdysrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGFycm93LnVwLmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIG5hdlRvUm93LS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYXJyb3cucmlnaHQuY29kZTpcbiAgICAgICAgICAgICAgICAgICAgbmF2VG9Db2wrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBhcnJvdy5sZWZ0LmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIG5hdlRvQ29sLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWwuc2V0Rm9jdXMobmF2VG9Sb3csIG5hdlRvQ29sLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vc2VsZWN0aW9uIGxvZ2ljXG4gICAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uO1xuICAgICAgICAgICAgLy9zdGFuZCBpbiBmb3IgaWYgaXQncyBjbGVhcmVkXG4gICAgICAgICAgICBpZiAobW9kZWwuc2VsZWN0aW9uLnRvcCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24gPSB7dG9wOiBtb2RlbC5mb2N1cy5yb3csIGxlZnQ6IG1vZGVsLmZvY3VzLmNvbCwgaGVpZ2h0OiAxLCB3aWR0aDogMX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBtb2RlbC5zZWxlY3Rpb24udG9wLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtb2RlbC5zZWxlY3Rpb24ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtb2RlbC5zZWxlY3Rpb24uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbW9kZWwuc2VsZWN0aW9uLndpZHRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBhcnJvdy5kb3duLmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5mb2N1cy5yb3cgPT09IG5ld1NlbGVjdGlvbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5oZWlnaHQrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi50b3ArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5oZWlnaHQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGFycm93LnVwLmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5mb2N1cy5yb3cgPT09IG5ld1NlbGVjdGlvbi50b3AgKyBuZXdTZWxlY3Rpb24uaGVpZ2h0IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLnRvcC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmhlaWdodCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmhlaWdodC0tO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBhcnJvdy5yaWdodC5jb2RlOlxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZm9jdXMuY29sID09PSBuZXdTZWxlY3Rpb24ubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLndpZHRoKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24ubGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLndpZHRoLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBhcnJvdy5sZWZ0LmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5mb2N1cy5jb2wgPT09IG5ld1NlbGVjdGlvbi5sZWZ0ICsgbmV3U2VsZWN0aW9uLndpZHRoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmxlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi53aWR0aCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLndpZHRoLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U2VsZWN0aW9uLmhlaWdodCA9PT0gMSAmJiBuZXdTZWxlY3Rpb24ud2lkdGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvdXRzaWRlTWluTWF4KHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiByb3cgPCAwIHx8IHJvdyA+IGdyaWQucm93TW9kZWwubGVuZ3RoKCkgfHwgY29sIDwgMCB8fCBjb2wgPiBncmlkLmNvbE1vZGVsLmxlbmd0aCgpO1xuICAgIH1cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vYXNzdW1lIHRoZSBldmVudCBoYXMgYmVlbiBhbm5vdGF0ZWQgYnkgdGhlIGNlbGwgbW91c2UgbW9kZWwgaW50ZXJjZXB0b3JcbiAgICAgICAgdmFyIHJvdyA9IGUucm93O1xuICAgICAgICB2YXIgY29sID0gZS5jb2w7XG4gICAgICAgIGlmIChyb3cgPCAwICYmIGNvbCA+PSAwKSB7XG4gICAgICAgICAgICBncmlkLmNvbE1vZGVsLnRvZ2dsZVNlbGVjdChjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wgPCAwICYmIHJvdyA+PSAwKSB7XG4gICAgICAgICAgICBncmlkLnJvd01vZGVsLnRvZ2dsZVNlbGVjdChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdyA8IDAgJiYgY29sIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBtb2RlbC5zZXRGb2N1cyhyb3csIGNvbCwgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25Gcm9tUG9pbnRzKG1vZGVsLmZvY3VzLnJvdywgbW9kZWwuZm9jdXMuY29sLCByb3csIGNvbCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kZWwuX3Jvd1NlbGVjdGlvbkNsYXNzZXMgPSBbXTtcbiAgICBtb2RlbC5fY29sU2VsZWN0aW9uQ2xhc3NlcyA9IFtdO1xuICAgIC8vcm93IGNvbCBzZWxlY3Rpb25cbiAgICBmdW5jdGlvbiBoYW5kbGVSb3dDb2xTZWxlY3Rpb25DaGFuZ2Uocm93T3JDb2wpIHtcbiAgICAgICAgdmFyIGRlY29yYXRvcnNGaWVsZCA9ICgnXycgKyByb3dPckNvbCArICdTZWxlY3Rpb25DbGFzc2VzJyk7XG4gICAgICAgIG1vZGVsW2RlY29yYXRvcnNGaWVsZF0uZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uRGVjb3JhdG9yKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxDbGFzc2VzLnJlbW92ZShzZWxlY3Rpb25EZWNvcmF0b3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kZWxbZGVjb3JhdG9yc0ZpZWxkXSA9IFtdO1xuXG4gICAgICAgIGdyaWRbcm93T3JDb2wgKyAnTW9kZWwnXS5nZXRTZWxlY3RlZCgpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmlydHVhbEluZGV4ID0gZ3JpZFtyb3dPckNvbCArICdNb2RlbCddLnRvVmlydHVhbChpbmRleCk7XG4gICAgICAgICAgICB2YXIgdG9wID0gcm93T3JDb2wgPT09ICdyb3cnID8gdmlydHVhbEluZGV4IDogMDtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcm93T3JDb2wgPT09ICdjb2wnID8gdmlydHVhbEluZGV4IDogMDtcbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBncmlkLmNlbGxDbGFzc2VzLmNyZWF0ZSh0b3AsIGxlZnQsICdzZWxlY3RlZCcsIDEsIDEsICd2aXJ0dWFsJyk7XG4gICAgICAgICAgICBncmlkLmNlbGxDbGFzc2VzLmFkZChkZWNvcmF0b3IpO1xuICAgICAgICAgICAgbW9kZWxbZGVjb3JhdG9yc0ZpZWxkXS5wdXNoKGRlY29yYXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtcm93LXNlbGVjdGlvbi1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbmRsZVJvd0NvbFNlbGVjdGlvbkNoYW5nZSgncm93Jyk7XG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWNvbC1zZWxlY3Rpb24tY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW5kbGVSb3dDb2xTZWxlY3Rpb25DaGFuZ2UoJ2NvbCcpO1xuICAgIH0pO1xuXG4gICAgdmFyIHNlbGVjdGlvbiA9IGdyaWQuZGVjb3JhdG9ycy5jcmVhdGUoKTtcblxuICAgIHZhciBkZWZhdWx0UmVuZGVyID0gc2VsZWN0aW9uLnJlbmRlcjtcbiAgICBzZWxlY3Rpb24ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGl2ID0gZGVmYXVsdFJlbmRlcigpO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdncmlkLXNlbGVjdGlvbicpO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH07XG5cbiAgICBncmlkLmRlY29yYXRvcnMuYWRkKHNlbGVjdGlvbik7XG5cbiAgICBtb2RlbC5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi50b3AgPSBuZXdTZWxlY3Rpb24udG9wO1xuICAgICAgICBzZWxlY3Rpb24ubGVmdCA9IG5ld1NlbGVjdGlvbi5sZWZ0O1xuICAgICAgICBzZWxlY3Rpb24uaGVpZ2h0ID0gbmV3U2VsZWN0aW9uLmhlaWdodDtcbiAgICAgICAgc2VsZWN0aW9uLndpZHRoID0gbmV3U2VsZWN0aW9uLndpZHRoO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgbW9kZWwuc2V0U2VsZWN0aW9uKHt0b3A6IC0xLCBsZWZ0OiAtMSwgaGVpZ2h0OiAtMSwgd2lkdGg6IC0xfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uRnJvbVBvaW50cyhmcm9tUm93LCBmcm9tQ29sLCB0b1JvdywgdG9Db2wpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHJhbmdlVXRpbC5jcmVhdGVGcm9tUG9pbnRzKGZyb21Sb3csIGZyb21Db2wsIGNsYW1wUm93VG9NaW5NYXgodG9Sb3cpLCBjbGFtcENvbFRvTWluTWF4KHRvQ29sKSk7XG4gICAgICAgIG1vZGVsLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAob3V0c2lkZU1pbk1heChlLnJvdywgZS5jb2wpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21Sb3cgPSBtb2RlbC5mb2N1cy5yb3c7XG4gICAgICAgIHZhciBmcm9tQ29sID0gbW9kZWwuZm9jdXMuY29sO1xuICAgICAgICB2YXIgdW5iaW5kRHJhZyA9IGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtY2VsbC1kcmFnJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbkZyb21Qb2ludHMoZnJvbVJvdywgZnJvbUNvbCwgZS5yb3csIGUuY29sKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVuYmluZERyYWdFbmQgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWctZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW5iaW5kRHJhZygpO1xuICAgICAgICAgICAgdW5iaW5kRHJhZ0VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnLXN0YXJ0Jywgc2VsZWN0aW9uLl9vbkRyYWdTdGFydCk7XG4gICAgY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgIG1vZGVsLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblxuICAgIHJldHVybiBtb2RlbDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9hIG5vb3AgZnVuY3Rpb24gdG8gdXNlXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmd1bWVudHNbMF07XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi4vZGVib3VuY2UnKTtcbnZhciBjYXBpdGFsaXplID0gcmVxdWlyZSgnY2FwaXRhbGl6ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG4gICAgdmFyIG1vZGVsID0ge3RvcDogMCwgbGVmdDogMCwgbWF4U2Nyb2xsOiB7fX07XG4gICAgdmFyIHNjcm9sbEJhcldpZHRoID0gMTA7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLXZpcnR1YWwtcGl4ZWwtY2VsbC1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC50b3RhbEhlaWdodCgpIC0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuZml4ZWRIZWlnaHQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFdpZHRoID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwudG90YWxXaWR0aCgpIC0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuZml4ZWRXaWR0aCgpO1xuICAgICAgICBtb2RlbC5zZXRTY3JvbGxTaXplKHNjcm9sbEhlaWdodCwgc2Nyb2xsV2lkdGgpO1xuICAgICAgICBjYWNoZU1heFNjcm9sbCgpO1xuICAgICAgICBzaXplU2Nyb2xsQmFycygpO1xuICAgIH0pO1xuXG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLXZpZXdwb3J0LWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FjaGVNYXhTY3JvbGwoKTtcbiAgICAgICAgc2l6ZVNjcm9sbEJhcnMoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNhY2hlTWF4U2Nyb2xsKCkge1xuICAgICAgICBtb2RlbC5tYXhTY3JvbGwuaGVpZ2h0ID0gZ2V0TWF4U2Nyb2xsKCdoZWlnaHQnKTtcbiAgICAgICAgbW9kZWwubWF4U2Nyb2xsLndpZHRoID0gZ2V0TWF4U2Nyb2xsKCd3aWR0aCcpO1xuICAgIH1cblxuICAgIC8vYXNzdW1lcyBhIHN0YW5kYXJkaXplZCB3aGVlbCBldmVudCB0aGF0IHdlIGNyZWF0ZSB0aHJvdWdoIHRoZSBtb3VzZXdoZWVsIHBhY2thZ2VcbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24gaGFuZGxlTW91c2VXaGVlbChlKSB7XG4gICAgICAgIHZhciBkZWx0YVkgPSBlLmRlbHRhWTtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGUuZGVsdGFYO1xuICAgICAgICBtb2RlbC5zY3JvbGxUbyhtb2RlbC50b3AgLSBkZWx0YVksIG1vZGVsLmxlZnQgLSBkZWx0YVgsIHRydWUpO1xuICAgICAgICBkZWJvdW5jZWROb3RpZnkoKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgbW9kZWwuc2V0U2Nyb2xsU2l6ZSA9IGZ1bmN0aW9uIChoLCB3KSB7XG4gICAgICAgIG1vZGVsLmhlaWdodCA9IGg7XG4gICAgICAgIG1vZGVsLndpZHRoID0gdztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgICAgICAvL1RPRE86IHBvc3NpYmx5IGtlZXAgdHJhY2sgb2YgZGVsdGEgc2luY2UgbGFzdCB1cGRhdGUgYW5kIHNlbmQgaXQgYWxvbmcuIGZvciBub3csIG5vXG4gICAgICAgIGdyaWQuZXZlbnRMb29wLmZpcmUoJ2dyaWQtcGl4ZWwtc2Nyb2xsJyk7XG5cbiAgICAgICAgLy91cGRhdGUgdGhlIGNlbGwgc2Nyb2xsXG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSBtb2RlbC50b3A7XG4gICAgICAgIHZhciByb3cgPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5nZXRSb3coc2Nyb2xsVG9wICsgZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuZml4ZWRIZWlnaHQoKSkgLSBncmlkLnJvd01vZGVsLm51bUZpeGVkKCk7XG5cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBtb2RlbC5sZWZ0O1xuICAgICAgICB2YXIgY29sID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuZ2V0Q29sKHNjcm9sbExlZnQgKyBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5maXhlZFdpZHRoKCkpIC0gZ3JpZC5jb2xNb2RlbC5udW1GaXhlZCgpO1xuXG4gICAgICAgIGdyaWQuY2VsbFNjcm9sbE1vZGVsLnNjcm9sbFRvKHJvdywgY29sLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBkZWJvdW5jZWROb3RpZnkgPSBkZWJvdW5jZShub3RpZnlMaXN0ZW5lcnMsIDEpO1xuXG4gICAgbW9kZWwuc2Nyb2xsVG8gPSBmdW5jdGlvbiAodG9wLCBsZWZ0LCBkb250Tm90aWZ5KSB7XG4gICAgICAgIG1vZGVsLnRvcCA9IHV0aWwuY2xhbXAodG9wLCAwLCBtb2RlbC5tYXhTY3JvbGwuaGVpZ2h0KTtcbiAgICAgICAgbW9kZWwubGVmdCA9IHV0aWwuY2xhbXAobGVmdCwgMCwgbW9kZWwubWF4U2Nyb2xsLndpZHRoKTtcbiAgICAgICAgcG9zaXRpb25TY3JvbGxCYXJzKCk7XG5cbiAgICAgICAgaWYgKCFkb250Tm90aWZ5KSB7XG4gICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuXG5cbiAgICB9O1xuXG5cbiAgICAvKiBTQ1JPTEwgQkFSIExPR0lDICovXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb25Gcm9tUmVhbChzY3JvbGxCYXJSZWFsQ2xpY2tDb29yZCwgaGVpZ2h0V2lkdGgsIHZlcnRIb3J6KSB7XG4gICAgICAgIHZhciBzY3JvbGxCYXJUb3BDbGljayA9IHNjcm9sbEJhclJlYWxDbGlja0Nvb3JkIC0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWxbJ2ZpeGVkJyArIGNhcGl0YWxpemUoaGVpZ2h0V2lkdGgpXSgpO1xuICAgICAgICB2YXIgc2Nyb2xsUmF0aW8gPSBzY3JvbGxCYXJUb3BDbGljayAvIGdldE1heFNjcm9sbEJhckNvb3JkKGhlaWdodFdpZHRoLCB2ZXJ0SG9yeik7XG4gICAgICAgIHZhciBzY3JvbGxDb29yZCA9IHNjcm9sbFJhdGlvICogbW9kZWwubWF4U2Nyb2xsW2hlaWdodFdpZHRoXTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbENvb3JkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VTY3JvbGxCYXJEZWNvcmF0b3IoaXNIb3J6KSB7XG4gICAgICAgIHZhciBkZWNvcmF0b3IgPSBncmlkLmRlY29yYXRvcnMuY3JlYXRlKCk7XG4gICAgICAgIHZhciB4T3JZID0gaXNIb3J6ID8gJ1gnIDogJ1knO1xuICAgICAgICB2YXIgaGVpZ2h0V2lkdGggPSBpc0hvcnogPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIHZhciB2ZXJ0SG9yeiA9IGlzSG9yeiA/ICdob3J6JyA6ICd2ZXJ0JztcbiAgICAgICAgdmFyIGdyaWRDb29yZEZpZWxkID0gJ2dyaWQnICsgeE9yWTtcbiAgICAgICAgdmFyIGxheWVyQ29vcmRGaWVsZCA9ICdsYXllcicgKyB4T3JZO1xuICAgICAgICB2YXIgdmlld1BvcnRDbGFtcEZuID0gZ3JpZC52aWV3UG9ydFsnY2xhbXAnICsgeE9yWV07XG5cbiAgICAgICAgZGVjb3JhdG9yLnBvc3RSZW5kZXIgPSBmdW5jdGlvbiAoc2Nyb2xsQmFyRWxlbSkge1xuICAgICAgICAgICAgc2Nyb2xsQmFyRWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dyaWQtc2Nyb2xsLWJhcicpO1xuICAgICAgICAgICAgZGVjb3JhdG9yLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBzY3JvbGxCYXJFbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEJhck9mZnNldCA9IGVbbGF5ZXJDb29yZEZpZWxkXTtcblxuICAgICAgICAgICAgICAgIGRlY29yYXRvci5fdW5iaW5kRHJhZyA9IGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhZycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmlkQ29vcmQgPSB2aWV3UG9ydENsYW1wRm4oZVtncmlkQ29vcmRGaWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQmFyUmVhbENsaWNrQ29vcmQgPSBncmlkQ29vcmQgLSBzY3JvbGxCYXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxDb29yZCA9IGdldFNjcm9sbFBvc2l0aW9uRnJvbVJlYWwoc2Nyb2xsQmFyUmVhbENsaWNrQ29vcmQsIGhlaWdodFdpZHRoLCB2ZXJ0SG9yeik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hvcnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnNjcm9sbFRvKG1vZGVsLnRvcCwgc2Nyb2xsQ29vcmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2Nyb2xsVG8oc2Nyb2xsQ29vcmQsIG1vZGVsLmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IuX3VuYmluZERyYWdFbmQgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWctZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yLl91bmJpbmREcmFnKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvci5fdW5iaW5kRHJhZ0VuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhZy1zdGFydCcsIHNjcm9sbEJhckVsZW0sIGRlY29yYXRvci5fb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuYmluZCgnbW91c2Vkb3duJywgc2Nyb2xsQmFyRWxlbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5zdG9wQnViYmxpbmcoZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNjcm9sbEJhckVsZW07XG4gICAgICAgIH07XG5cbiAgICAgICAgZGVjb3JhdG9yLnVuaXRzID0gJ3B4JztcbiAgICAgICAgZGVjb3JhdG9yLnNwYWNlID0gJ3JlYWwnO1xuXG4gICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgfVxuXG4gICAgbW9kZWwudmVydFNjcm9sbEJhciA9IG1ha2VTY3JvbGxCYXJEZWNvcmF0b3IoKTtcbiAgICBtb2RlbC5ob3J6U2Nyb2xsQmFyID0gbWFrZVNjcm9sbEJhckRlY29yYXRvcih0cnVlKTtcbiAgICBtb2RlbC52ZXJ0U2Nyb2xsQmFyLndpZHRoID0gc2Nyb2xsQmFyV2lkdGg7XG4gICAgbW9kZWwuaG9yelNjcm9sbEJhci5oZWlnaHQgPSBzY3JvbGxCYXJXaWR0aDtcblxuICAgIGZ1bmN0aW9uIGdldE1heFNjcm9sbChoZWlnaHRXaWR0aCkge1xuICAgICAgICB2YXIgcm93T3JDb2wgPSBoZWlnaHRXaWR0aCA9PT0gJ2hlaWdodCcgPyAncm93JyA6ICdjb2wnO1xuICAgICAgICB2YXIgc2Nyb2xsTGVuZ3RoID0gbW9kZWxbaGVpZ2h0V2lkdGhdO1xuICAgICAgICB2YXIgdmlld1Njcm9sbEhlaWdodE9yV2lkdGggPSBnZXRWaWV3U2Nyb2xsSGVpZ2h0T3JXaWR0aChoZWlnaHRXaWR0aCk7XG4gICAgICAgIHZhciBmaXJzdFNjcm9sbGFibGVDZWxsID0gZ3JpZFtyb3dPckNvbCArICdNb2RlbCddLm51bUZpeGVkKCk7XG4gICAgICAgIHdoaWxlIChzY3JvbGxMZW5ndGggPiB2aWV3U2Nyb2xsSGVpZ2h0T3JXaWR0aCAtIDEwKSB7XG4gICAgICAgICAgICBzY3JvbGxMZW5ndGggLT0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWxbaGVpZ2h0V2lkdGhdKGZpcnN0U2Nyb2xsYWJsZUNlbGwpO1xuICAgICAgICAgICAgZmlyc3RTY3JvbGxhYmxlQ2VsbCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbFtoZWlnaHRXaWR0aF0gLSBzY3JvbGxMZW5ndGg7XG4gICAgfVxuXG4gICAgbW9kZWwuX2dldE1heFNjcm9sbCA9IGdldE1heFNjcm9sbDtcblxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbFJhdGlvRnJvbVZpcnR1YWxTY3JvbGxDb29yZHMoc2Nyb2xsLCBoZWlnaHRXaWR0aCkge1xuICAgICAgICB2YXIgbWF4U2Nyb2xsID0gbW9kZWwubWF4U2Nyb2xsW2hlaWdodFdpZHRoXTtcbiAgICAgICAgdmFyIHNjcm9sbFJhdGlvID0gc2Nyb2xsIC8gbWF4U2Nyb2xsO1xuICAgICAgICByZXR1cm4gc2Nyb2xsUmF0aW87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4U2Nyb2xsQmFyQ29vcmQoaGVpZ2h0V2lkdGgsIHZlcnRIb3J6KSB7XG4gICAgICAgIHJldHVybiBnZXRWaWV3U2Nyb2xsSGVpZ2h0T3JXaWR0aChoZWlnaHRXaWR0aCkgLSBtb2RlbFt2ZXJ0SG9yeiArICdTY3JvbGxCYXInXVtoZWlnaHRXaWR0aF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVhbFNjcm9sbEJhclBvc2l0aW9uKHNjcm9sbCwgaGVpZ2h0V2lkdGgsIHZlcnRIb3J6KSB7XG4gICAgICAgIHZhciBzY3JvbGxSYXRpbyA9IGdldFNjcm9sbFJhdGlvRnJvbVZpcnR1YWxTY3JvbGxDb29yZHMoc2Nyb2xsLCBoZWlnaHRXaWR0aCk7XG4gICAgICAgIHZhciBtYXhTY3JvbGxCYXJTY3JvbGwgPSBnZXRNYXhTY3JvbGxCYXJDb29yZChoZWlnaHRXaWR0aCwgdmVydEhvcnopO1xuICAgICAgICAvL2luIHNjcm9sbCBiYXIgY29vcmRzXG4gICAgICAgIHZhciBzY3JvbGxCYXJDb29yZCA9IHNjcm9sbFJhdGlvICogbWF4U2Nyb2xsQmFyU2Nyb2xsO1xuICAgICAgICAvL2FkZCB0aGUgZml4ZWQgaGVpZ2h0IHRvIHRyYW5zbGF0ZSBiYWNrIGludG8gcmVhbCBjb29yZHNcbiAgICAgICAgcmV0dXJuIHNjcm9sbEJhckNvb3JkICsgZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWxbJ2ZpeGVkJyArIGNhcGl0YWxpemUoaGVpZ2h0V2lkdGgpXSgpO1xuICAgIH1cblxuICAgIG1vZGVsLl9nZXRSZWFsU2Nyb2xsQmFyUG9zaXRpb24gPSBnZXRSZWFsU2Nyb2xsQmFyUG9zaXRpb247XG4gICAgbW9kZWwuX2dldFNjcm9sbFBvc2l0aW9uRnJvbVJlYWwgPSBnZXRTY3JvbGxQb3NpdGlvbkZyb21SZWFsO1xuXG4gICAgZnVuY3Rpb24gY2FsY1Njcm9sbEJhclJlYWxUb3AoKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWFsU2Nyb2xsQmFyUG9zaXRpb24obW9kZWwudG9wLCAnaGVpZ2h0JywgJ3ZlcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjU2Nyb2xsQmFyUmVhbExlZnQoKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWFsU2Nyb2xsQmFyUG9zaXRpb24obW9kZWwubGVmdCwgJ3dpZHRoJywgJ2hvcnonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvblNjcm9sbEJhcnMoKSB7XG4gICAgICAgIG1vZGVsLnZlcnRTY3JvbGxCYXIudG9wID0gY2FsY1Njcm9sbEJhclJlYWxUb3AoKTtcbiAgICAgICAgbW9kZWwuaG9yelNjcm9sbEJhci5sZWZ0ID0gY2FsY1Njcm9sbEJhclJlYWxMZWZ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld1Njcm9sbEhlaWdodE9yV2lkdGgoaGVpZ2h0V2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQudmlld1BvcnRbaGVpZ2h0V2lkdGhdIC0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWxbJ2ZpeGVkJyArIGNhcGl0YWxpemUoaGVpZ2h0V2lkdGgpXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbGFibGVWaWV3V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBnZXRWaWV3U2Nyb2xsSGVpZ2h0T3JXaWR0aCgnd2lkdGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxhYmxlVmlld0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZpZXdTY3JvbGxIZWlnaHRPcldpZHRoKCdoZWlnaHQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaXplU2Nyb2xsQmFycygpIHtcbiAgICAgICAgbW9kZWwudmVydFNjcm9sbEJhci5sZWZ0ID0gZ3JpZC52aWV3UG9ydC53aWR0aCAtIHNjcm9sbEJhcldpZHRoO1xuICAgICAgICBtb2RlbC5ob3J6U2Nyb2xsQmFyLnRvcCA9IGdyaWQudmlld1BvcnQuaGVpZ2h0IC0gc2Nyb2xsQmFyV2lkdGg7XG4gICAgICAgIHZhciBzY3JvbGxhYmxlVmlld0hlaWdodCA9IGdldFNjcm9sbGFibGVWaWV3SGVpZ2h0KCk7XG4gICAgICAgIHZhciBzY3JvbGxhYmxlVmlld1dpZHRoID0gZ2V0U2Nyb2xsYWJsZVZpZXdXaWR0aCgpO1xuICAgICAgICBtb2RlbC52ZXJ0U2Nyb2xsQmFyLmhlaWdodCA9IE1hdGgubWF4KHNjcm9sbGFibGVWaWV3SGVpZ2h0IC8gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwudG90YWxIZWlnaHQoKSAqIHNjcm9sbGFibGVWaWV3SGVpZ2h0LCAyMCk7XG4gICAgICAgIG1vZGVsLmhvcnpTY3JvbGxCYXIud2lkdGggPSBNYXRoLm1heChzY3JvbGxhYmxlVmlld1dpZHRoIC8gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwudG90YWxXaWR0aCgpICogc2Nyb2xsYWJsZVZpZXdXaWR0aCwgMjApO1xuICAgICAgICBwb3NpdGlvblNjcm9sbEJhcnMoKTtcbiAgICB9XG5cbiAgICBncmlkLmRlY29yYXRvcnMuYWRkKG1vZGVsLnZlcnRTY3JvbGxCYXIpO1xuICAgIGdyaWQuZGVjb3JhdG9ycy5hZGQobW9kZWwuaG9yelNjcm9sbEJhcik7XG4gICAgLyogRU5EIFNDUk9MTCBCQVIgTE9HSUMgKi9cblxuICAgIHJldHVybiBtb2RlbDtcbn07IiwidmFyIGFkZERpcnR5UHJvcHMgPSByZXF1aXJlKCcuLi9hZGQtZGlydHktcHJvcHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJhbmdlLCBkaXJ0eUNsZWFuLCBwYXJlbnREaXJ0eUNsZWFuKSB7XG4gICAgcmFuZ2UgPSByYW5nZSB8fCB7fTsgLy9hbGxvdyBtaXhpbiBmdW5jdGlvbmFsaXR5XG4gICAgcmFuZ2UuaXNEaXJ0eSA9IGRpcnR5Q2xlYW4uaXNEaXJ0eTtcblxuICAgIHZhciB3YXRjaGVkUHJvcGVydGllcyA9IFsndG9wJywgJ2xlZnQnLCAnaGVpZ2h0JywgJ3dpZHRoJywgJ3VuaXRzJywgJ3NwYWNlJ107XG4gICAgdmFyIGRpcnR5Q2xlYW5zID0gW2RpcnR5Q2xlYW5dO1xuICAgIGlmIChwYXJlbnREaXJ0eUNsZWFuKSB7XG4gICAgICAgIGRpcnR5Q2xlYW5zLnB1c2gocGFyZW50RGlydHlDbGVhbik7XG4gICAgfVxuXG4gICAgYWRkRGlydHlQcm9wcyhyYW5nZSwgd2F0Y2hlZFByb3BlcnRpZXMsIGRpcnR5Q2xlYW5zKTtcbiAgICAvL2RlZmF1bHRzXG4gICAgcmFuZ2UudW5pdHMgPSAnY2VsbCc7XG4gICAgcmFuZ2Uuc3BhY2UgPSAnZGF0YSc7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vdGFrZXMgYSBwb2ludCBhbmQgYSBsZW5ndGggYXMgdGhlIHJhbmdlcyBpbiBhcnJheSBmb3JtXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAocmFuZ2UxLCByYW5nZTIpIHtcbiAgICAgICAgdmFyIHJhbmdlMlN0YXJ0ID0gcmFuZ2UyWzBdO1xuICAgICAgICB2YXIgcmFuZ2UxU3RhcnQgPSByYW5nZTFbMF07XG4gICAgICAgIHZhciByYW5nZTFFbmQgPSByYW5nZTFTdGFydCArIHJhbmdlMVsxXSAtIDE7XG4gICAgICAgIHZhciByYW5nZTJFbmQgPSByYW5nZTJTdGFydCArIHJhbmdlMlsxXSAtIDE7XG4gICAgICAgIGlmIChyYW5nZTJTdGFydCA+IHJhbmdlMUVuZCB8fCByYW5nZTJFbmQgPCByYW5nZTFTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFN0YXJ0ID0gKHJhbmdlMVN0YXJ0ID4gcmFuZ2UyU3RhcnQgPyByYW5nZTFTdGFydCA6IHJhbmdlMlN0YXJ0KTtcbiAgICAgICAgdmFyIHJlc3VsdEVuZCA9IChyYW5nZTFFbmQgPCByYW5nZTJFbmQgPyByYW5nZTFFbmQgOiByYW5nZTJFbmQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmVzdWx0U3RhcnQsXG4gICAgICAgICAgICByZXN1bHRFbmQgLSByZXN1bHRTdGFydCArIDFcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIC8vdGFrZXMgYSBwb2ludCBhbmQgYSBsZW5ndGggYXMgdGhlIHJhbmdlcyBpbiBhcnJheSBmb3JtXG4gICAgdW5pb246IGZ1bmN0aW9uIChyYW5nZTEsIHJhbmdlMikge1xuICAgICAgICBpZiAoIXJhbmdlMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhbmdlMikge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UyU3RhcnQgPSByYW5nZTJbMF07XG4gICAgICAgIHZhciByYW5nZTJFbmQgPSByYW5nZTJTdGFydCArIHJhbmdlMlsxXSAtIDE7XG4gICAgICAgIHZhciByYW5nZTFTdGFydCA9IHJhbmdlMVswXTtcbiAgICAgICAgdmFyIHJhbmdlMUVuZCA9IHJhbmdlMVN0YXJ0ICsgcmFuZ2UxWzFdIC0gMTtcbiAgICAgICAgdmFyIHJlc3VsdFN0YXJ0ID0gKHJhbmdlMVN0YXJ0IDwgcmFuZ2UyU3RhcnQgPyByYW5nZTFTdGFydCA6IHJhbmdlMlN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0LFxuICAgICAgICAgICAgKHJhbmdlMUVuZCA+IHJhbmdlMkVuZCA/IHJhbmdlMUVuZCA6IHJhbmdlMkVuZCkgLSByZXN1bHRTdGFydCArIDFcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLy90YWtlcyB0d28gcm93LCBjb2wgcG9pbnRzIGFuZCBjcmVhdGVzIGEgbm9ybWFsIHBvc2l0aW9uIHJhbmdlXG4gICAgY3JlYXRlRnJvbVBvaW50czogZnVuY3Rpb24gKHIxLCBjMSwgcjIsIGMyKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHt9O1xuICAgICAgICBpZiAocjEgPCByMikge1xuICAgICAgICAgICAgcmFuZ2UudG9wID0gcjE7XG4gICAgICAgICAgICByYW5nZS5oZWlnaHQgPSByMiAtIHIxICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnRvcCA9IHIyO1xuICAgICAgICAgICAgcmFuZ2UuaGVpZ2h0ID0gcjEgLSByMiArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYzEgPCBjMikge1xuICAgICAgICAgICAgcmFuZ2UubGVmdCA9IGMxO1xuICAgICAgICAgICAgcmFuZ2Uud2lkdGggPSBjMiAtIGMxICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLmxlZnQgPSBjMjtcbiAgICAgICAgICAgIHJhbmdlLndpZHRoID0gYzEgLSBjMiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBhcGkgPSByZXF1aXJlKCcuLi9hYnN0cmFjdC1yb3ctY29sLW1vZGVsJykoZ3JpZCwgJ3JvdycsICdoZWlnaHQnLCAzMCk7XG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG5cbiAgICB2YXIgYXBpID0ge19kZWNvcmF0b3JzOiB7fX07XG5cbiAgICBmdW5jdGlvbiBzZXRDb2xTaG93aW5nKGNvbCkge1xuICAgICAgICBncmlkLmNvbE1vZGVsLmdldChjb2wpLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvV2hpbGVIaWRkZW4oY29sLCBmbikge1xuICAgICAgICB3aGlsZSAoZ3JpZC5jb2xNb2RlbC5nZXQoY29sIC0gMSkuaGlkZGVuKSB7XG4gICAgICAgICAgICBjb2wtLTtcbiAgICAgICAgICAgIGZuICYmIGZuKGNvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEZWNvcmF0b3IoY29sLCByaWdodCkge1xuICAgICAgICB2YXIgaGVhZGVyRGVjb3JhdG9yID0gZ3JpZC5kZWNvcmF0b3JzLmNyZWF0ZSgwLCBjb2wsIDEsIDEsICdjZWxsJywgJ3ZpcnR1YWwnKTtcblxuICAgICAgICBoZWFkZXJEZWNvcmF0b3IucG9zdFJlbmRlciA9IGZ1bmN0aW9uIChkaXYpIHtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoNTAlLCAtNTAlKSc7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoNTAlLCAtNTAlKSc7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdsZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC01MCUsIC01MCUpJztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSc7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGl2LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdib3R0b20nKTtcbiAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAnNTAlJztcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3Nob3ctaGlkZGVuLWNvbHMnKTtcblxuICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuYmluZCgnY2xpY2snLCBkaXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb1doaWxlSGlkZGVuKGNvbCwgc2V0Q29sU2hvd2luZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGhlYWRlckRlY29yYXRvcjtcbiAgICB9XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWNvbC1jaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5hY3Rpb24gPT09ICdoaWRlJyB8fCBlLmFjdGlvbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGUuZGVzY3JpcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBkZXNjcmlwdG9yLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmICghY29sICYmIGNvbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjQ29sID0gY29sICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0U2lkZSA9IGNvbCA9PT0gZ3JpZC5jb2xNb2RlbC5sZW5ndGgodHJ1ZSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlJ3JlIGxhc3Qgd2UgYWN0dWFsbHkgaGF2ZSB0byBiYWNrdHJhY2sgdG8gdGhlIGxhc3Qgc2hvd2luZyBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SGlkZGVuQ29sID0gZG9XaGlsZUhpZGRlbihjb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjQ29sID0gbGFzdEhpZGRlbkNvbCAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gY3JlYXRlRGVjb3JhdG9yKGRlY0NvbCwgcmlnaHRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLmFkZChkZWNvcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuX2RlY29yYXRvcnNbY29sXSA9IGRlY29yYXRvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gYXBpLl9kZWNvcmF0b3JzW2NvbF07XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZGVjb3JhdG9ycy5yZW1vdmUoZGVjb3JhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLl9kZWNvcmF0b3JzW2NvbF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBjZWxsRGF0YSA9IFtdO1xuICAgIHZhciBoZWFkZXJEYXRhID0gW107XG4gICAgdmFyIHNvcnRlZENvbDtcbiAgICB2YXIgYXNjZW5kaW5nO1xuICAgIHZhciBkaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKShncmlkKTtcbiAgICB2YXIgaW50ZXJuYWxTZXQgPSBmdW5jdGlvbiAoZGF0YSwgciwgYywgZGF0dW0pIHtcbiAgICAgICAgaWYgKCFkYXRhW3JdKSB7XG4gICAgICAgICAgICBkYXRhW3JdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtyXVtjXSA9IGRhdHVtO1xuICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGlzRGlydHk6IGRpcnR5Q2xlYW4uaXNEaXJ0eSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAociwgYywgZGF0dW0pIHtcbiAgICAgICAgICAgIGludGVybmFsU2V0KGNlbGxEYXRhLCByLCBjLCBkYXR1bSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEhlYWRlcjogZnVuY3Rpb24gKHIsIGMsIGRhdHVtKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFNldChoZWFkZXJEYXRhLCByLCBjLCBkYXR1bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUm93ID0gY2VsbERhdGFbZ3JpZC5yb3dNb2RlbC5yb3cocikuZGF0YVJvd107XG4gICAgICAgICAgICB2YXIgZGF0dW0gPSBkYXRhUm93ICYmIGRhdGFSb3dbZ3JpZC5jb2xNb2RlbC5jb2woYykuZGF0YUNvbF07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXR1bSAmJiBkYXR1bS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogdmFsdWUgJiYgJ3InICsgdmFsdWVbMF0gKyAnIGMnICsgdmFsdWVbMV0gfHwgJydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvcHlEYXRhOiBmdW5jdGlvbiAociwgYykge1xuICAgICAgICAgICAgcmV0dXJuIGFwaS5nZXQociwgYyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlYWRlcjogZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUm93ID0gaGVhZGVyRGF0YVtncmlkLnJvd01vZGVsLmdldChyKS5kYXRhUm93XTtcblxuICAgICAgICAgICAgdmFyIGRhdHVtID0gZGF0YVJvdyAmJiBkYXRhUm93W2dyaWQuY29sTW9kZWwuZ2V0KGMpLmRhdGFDb2xdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0dW0gJiYgZGF0dW0udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IHZhbHVlICYmICdocicgKyB2YWx1ZVswXSArICcgaGMnICsgdmFsdWVbMV0gfHwgJydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlU29ydDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciByZXRWYWwgPSAtMTtcbiAgICAgICAgICAgIHZhciBjb21wYXJlTWV0aG9kID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsMSA8ICh2YWwyKSA/IHJldFZhbCA6IC0xICogcmV0VmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjID09PSBzb3J0ZWRDb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzY2VuZGluZyA9ICFhc2NlbmRpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvcnRlZENvbCA9IGM7XG4gICAgICAgICAgICAgICAgYXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxEYXRhLnNvcnQoZnVuY3Rpb24gKGRhdGFSb3cxLCBkYXRhUm93Mikge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YVJvdzEgfHwgIWRhdGFSb3cxW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGF0YVJvdzIgfHwgIWRhdGFSb3cyW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRWYWwgKiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVNZXRob2QoZGF0YVJvdzFbY10udmFsdWUsIGRhdGFSb3cyW2NdLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlydHlDbGVhbi5zZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNsYW1wOiBmdW5jdGlvbiAobnVtLCBtaW4sIG1heCwgcmV0dXJuTmFOKSB7XG4gICAgICAgIGlmIChudW0gPiBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5OYU4gPyBOYU4gOiBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bSA8IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybk5hTiA/IE5hTiA6IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH0sXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInICYmICFpc05hTihudW1iZXIpO1xuICAgIH0sXG4gICAgaXNFbGVtZW50OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gISEobm9kZSAmJlxuICAgICAgICAobm9kZS5ub2RlTmFtZSB8fCAvLyB3ZSBhcmUgYSBkaXJlY3QgZWxlbWVudFxuICAgICAgICAobm9kZS5wcm9wICYmIG5vZGUuYXR0ciAmJiBub2RlLmZpbmQpKSk7ICAvLyB3ZSBoYXZlIGFuIG9uIGFuZCBmaW5kIG1ldGhvZCBwYXJ0IG9mIGpxdWVyeSBBUElcbiAgICB9LFxuICAgIGlzQXJyYXk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoZWxlbSwgdCwgbCwgYiwgcikge1xuICAgICAgICBlbGVtLnN0eWxlLnRvcCA9IHQgKyAncHgnO1xuICAgICAgICBlbGVtLnN0eWxlLmxlZnQgPSBsICsgJ3B4JztcbiAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSBiICsgJ3B4JztcbiAgICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IHIgKyAncHgnO1xuICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIH1cbn07IiwidmFyIGN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tLWV2ZW50Jyk7XG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuLi9kZWJvdW5jZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgdmlld0xheWVyID0ge307XG5cblxuICAgIHZhciBncmlkID0gX2dyaWQ7XG4gICAgdmFyIGNvbnRhaW5lcjtcbiAgICB2YXIgcm9vdDtcbiAgICB2YXIgY2VsbENvbnRhaW5lcjtcbiAgICB2YXIgZGVjb3JhdG9yQ29udGFpbmVyO1xuICAgIHZhciBib3JkZXJXaWR0aDtcblxuICAgIHZhciBHUklEX0NFTExfQ09OVEFJTkVSX0JBU0VfQ0xBU1MgPSAnZ3JpZC1jZWxscyc7XG4gICAgdmFyIEdSSURfVklFV19ST09UX0NMQVNTID0gJ2pzLWdyaWQtdmlldy1yb290JztcbiAgICB2YXIgQ0VMTF9DTEFTUyA9ICdncmlkLWNlbGwnO1xuXG4gICAgdmFyIGNlbGxzOyAvL21hdHJpeCBvZiByZW5kZXJlZCBjZWxsIGVsZW1lbnRzO1xuICAgIHZhciByb3dzOyAvL2FycmF5IG9mIGFsbCByZW5kZXJlZCByb3dzXG4gICAgdmFyIGJ1aWx0Q29sczsgLy9tYXAgZnJvbSBjb2wgaW5kZXggdG8gYW4gYXJyYXkgb2YgYnVpbHQgZWxlbWVudHMgZm9yIHRoZSBjb2x1bW4gdG8gdXBkYXRlIG9uIHNjcm9sbFxuICAgIHZhciBidWlsdFJvd3M7IC8vbWFwIGZyb20gcm93IGluZGV4IHRvIGFuIGFycmF5IG9mIGJ1aWx0IGVsZW1lbnRzIGZvciB0aGUgcm93IHRvIHVwZGF0ZSBvbiBzY3JvbGxcblxuICAgIC8vYWRkIHRoZSBjZWxsIGNsYXNzZXMgdGhyb3VnaCB0aGUgc3RhbmRhcmQgbWV0aG9kXG4gICAgZ3JpZC5jZWxsQ2xhc3Nlcy5hZGQoZ3JpZC5jZWxsQ2xhc3Nlcy5jcmVhdGUoMCwgMCwgQ0VMTF9DTEFTUywgSW5maW5pdHksIEluZmluaXR5LCAndmlydHVhbCcpKTtcblxuICAgIHZhciByb3dIZWFkZXJDbGFzc2VzID0gZ3JpZC5jZWxsQ2xhc3Nlcy5jcmVhdGUoMCwgMCwgJ2dyaWQtaGVhZGVyIGdyaWQtcm93LWhlYWRlcicsIEluZmluaXR5LCAwLCAndmlydHVhbCcpO1xuICAgIHZhciBjb2xIZWFkZXJDbGFzc2VzID0gZ3JpZC5jZWxsQ2xhc3Nlcy5jcmVhdGUoMCwgMCwgJ2dyaWQtaGVhZGVyIGdyaWQtY29sLWhlYWRlcicsIDAsIEluZmluaXR5LCAndmlydHVhbCcpO1xuICAgIHZhciBmaXhlZENvbENsYXNzZXMgPSBncmlkLmNlbGxDbGFzc2VzLmNyZWF0ZSgwLCAtMSwgJ2dyaWQtbGFzdC1maXhlZC1jb2wnLCBJbmZpbml0eSwgMSwgJ3ZpcnR1YWwnKTtcbiAgICB2YXIgZml4ZWRSb3dDbGFzc2VzID0gZ3JpZC5jZWxsQ2xhc3Nlcy5jcmVhdGUoLTEsIDAsICdncmlkLWxhc3QtZml4ZWQtcm93JywgMSwgSW5maW5pdHksICd2aXJ0dWFsJyk7XG5cbiAgICBncmlkLmNlbGxDbGFzc2VzLmFkZChyb3dIZWFkZXJDbGFzc2VzKTtcbiAgICBncmlkLmNlbGxDbGFzc2VzLmFkZChjb2xIZWFkZXJDbGFzc2VzKTtcbiAgICBncmlkLmNlbGxDbGFzc2VzLmFkZChmaXhlZFJvd0NsYXNzZXMpO1xuICAgIGdyaWQuY2VsbENsYXNzZXMuYWRkKGZpeGVkQ29sQ2xhc3Nlcyk7XG5cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtY29sLWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZml4ZWRDb2xDbGFzc2VzLmxlZnQgPSBncmlkLmNvbE1vZGVsLm51bUZpeGVkKCkgLSAxO1xuICAgICAgICByb3dIZWFkZXJDbGFzc2VzLndpZHRoID0gZ3JpZC5jb2xNb2RlbC5udW1IZWFkZXJzKCk7XG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLXJvdy1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpeGVkUm93Q2xhc3Nlcy50b3AgPSBncmlkLnJvd01vZGVsLm51bUZpeGVkKCkgLSAxO1xuICAgICAgICBjb2xIZWFkZXJDbGFzc2VzLmhlaWdodCA9IGdyaWQucm93TW9kZWwubnVtSGVhZGVycygpO1xuICAgIH0pO1xuXG5cbiAgICB2aWV3TGF5ZXIuYnVpbGQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgY29udGFpbmVyID0gZWxlbTtcblxuICAgICAgICBjZWxsQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNlbGxDb250YWluZXIuc2V0QXR0cmlidXRlKCdkdHMnLCAnZ3JpZC1jZWxscycpO1xuICAgICAgICBjZWxsQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBHUklEX0NFTExfQ09OVEFJTkVSX0JBU0VfQ0xBU1MpO1xuICAgICAgICB1dGlsLnBvc2l0aW9uKGNlbGxDb250YWluZXIsIDAsIDAsIDAsIDApO1xuICAgICAgICBjZWxsQ29udGFpbmVyLnN0eWxlLnpJbmRleCA9IDA7XG5cbiAgICAgICAgZGVjb3JhdG9yQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlY29yYXRvckNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2R0cycsICdncmlkLWRlY29yYXRvcnMnKTtcbiAgICAgICAgdXRpbC5wb3NpdGlvbihkZWNvcmF0b3JDb250YWluZXIsIDAsIDAsIDAsIDApO1xuICAgICAgICBkZWNvcmF0b3JDb250YWluZXIuc3R5bGUuekluZGV4ID0gMDtcbiAgICAgICAgZGVjb3JhdG9yQ29udGFpbmVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgICAgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBHUklEX1ZJRVdfUk9PVF9DTEFTUyk7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChjZWxsQ29udGFpbmVyKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChkZWNvcmF0b3JDb250YWluZXIpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyb290KTtcblxuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIG1lYXN1cmVCb3JkZXJXaWR0aCgpIHtcbiAgICAgICAgLy9yZWFkIHRoZSBib3JkZXIgd2lkdGgsIGZvciB0aGUgcmFyZSBjYXNlIG9mIGxhcmdlciB0aGFuIDFweCBib3JkZXJzLCBvdGhlcndpc2UgdGhlIGRyYXcgd2lsbCBkZWZhdWx0IHRvIDFcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGpzR3JpZENlbGwgPSBjZWxsc1swXSAmJiBjZWxsc1swXVswXTtcbiAgICAgICAgaWYgKGpzR3JpZENlbGwpIHtcbiAgICAgICAgICAgIHZhciBvbGRDbGFzcyA9IGpzR3JpZENlbGwuY2xhc3NOYW1lO1xuICAgICAgICAgICAganNHcmlkQ2VsbC5jbGFzc05hbWUgPSBDRUxMX0NMQVNTO1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGpzR3JpZENlbGwpO1xuICAgICAgICAgICAgdmFyIGJvcmRlcldpZHRoUHJvcCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKTtcbiAgICAgICAgICAgIGJvcmRlcldpZHRoID0gcGFyc2VJbnQoYm9yZGVyV2lkdGhQcm9wKTtcbiAgICAgICAgICAgIGpzR3JpZENlbGwuY2xhc3NOYW1lID0gb2xkQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc05hTihib3JkZXJXaWR0aCkgfHwgIWJvcmRlcldpZHRoID8gdW5kZWZpbmVkIDogYm9yZGVyV2lkdGg7XG4gICAgICAgIHJldHVybiBib3JkZXJXaWR0aDtcbiAgICB9XG5cbiAgICAvL29ubHkgZHJhdyBvbmNlIHBlciBqcyB0dXJuLCBtYXkgbmVlZCB0byBjcmVhdGUgYSBzeW5jaHJvbm91cyB2ZXJzaW9uXG4gICAgdmlld0xheWVyLmRyYXcgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZXdMYXllci5fZHJhdygpO1xuICAgIH0sIDEpO1xuXG4gICAgdmlld0xheWVyLl9kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL3JldHVybiBpZiB3ZSBoYXZlbid0IGJ1aWx0IHlldFxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlYnVpbHQgPSBncmlkLnZpZXdQb3J0LmlzRGlydHkoKTtcbiAgICAgICAgaWYgKHJlYnVpbHQpIHtcbiAgICAgICAgICAgIHZpZXdMYXllci5fYnVpbGRDZWxscyhjZWxsQ29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWlsdENvbHNEaXJ0eSA9IGdyaWQuY29sTW9kZWwuYXJlQnVpbGRlcnNEaXJ0eSgpO1xuICAgICAgICBpZiAocmVidWlsdCB8fCBidWlsdENvbHNEaXJ0eSkge1xuICAgICAgICAgICAgdmlld0xheWVyLl9idWlsZENvbHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWlsdFJvd3NEaXJ0eSA9IGdyaWQucm93TW9kZWwuYXJlQnVpbGRlcnNEaXJ0eSgpO1xuICAgICAgICBpZiAocmVidWlsdCB8fCBidWlsdFJvd3NEaXJ0eSkge1xuICAgICAgICAgICAgdmlld0xheWVyLl9idWlsZFJvd3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjZWxsc1Bvc2l0aW9uT3JTaXplQ2hhbmdlZCA9IGdyaWQuY29sTW9kZWwuaXNEaXJ0eSgpIHx8IGdyaWQucm93TW9kZWwuaXNEaXJ0eSgpIHx8IGdyaWQuY2VsbFNjcm9sbE1vZGVsLmlzRGlydHkoKTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsQ2xhc3Nlcy5pc0RpcnR5KCkgfHwgcmVidWlsdCB8fCBjZWxsc1Bvc2l0aW9uT3JTaXplQ2hhbmdlZCkge1xuICAgICAgICAgICAgdmlld0xheWVyLl9kcmF3Q2VsbENsYXNzZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWJ1aWx0IHx8IGNlbGxzUG9zaXRpb25PclNpemVDaGFuZ2VkIHx8IGJ1aWx0Q29sc0RpcnR5IHx8IGJ1aWx0Um93c0RpcnR5IHx8IGdyaWQuZGF0YU1vZGVsLmlzRGlydHkoKSkge1xuICAgICAgICAgICAgdmlld0xheWVyLl9kcmF3Q2VsbHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmlkLmRlY29yYXRvcnMuaXNEaXJ0eSgpIHx8IHJlYnVpbHQgfHwgY2VsbHNQb3NpdGlvbk9yU2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZpZXdMYXllci5fZHJhd0RlY29yYXRvcnMoY2VsbHNQb3NpdGlvbk9yU2l6ZUNoYW5nZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5ldmVudExvb3AuZmlyZSgnZ3JpZC1kcmF3Jyk7XG4gICAgfTtcblxuICAgIC8qIENFTEwgTE9HSUMgKi9cbiAgICBmdW5jdGlvbiBnZXRCb3JkZXJXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGJvcmRlcldpZHRoIHx8IDE7XG4gICAgfVxuXG4gICAgdmlld0xheWVyLl9kcmF3Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lYXN1cmVCb3JkZXJXaWR0aCgpO1xuICAgICAgICB2YXIgYldpZHRoID0gZ2V0Qm9yZGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd3MgPSBncmlkLnJvd01vZGVsLm51bUhlYWRlcnMoKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbHMgPSBncmlkLmNvbE1vZGVsLm51bUhlYWRlcnMoKTtcbiAgICAgICAgdmFyIHRvdGFsVmlzaWJsZUNlbGxXaWR0aCA9IDA7XG4gICAgICAgIHZhciBsYXN0VmlydHVhbENvbDtcbiAgICAgICAgZ3JpZC52aWV3UG9ydC5pdGVyYXRlQ2VsbHMoZnVuY3Rpb24gZHJhd0NlbGwociwgYykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1tyXVtjXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGdyaWQudmlld1BvcnQuZ2V0Q29sV2lkdGgoYyk7XG4gICAgICAgICAgICB2YXIgdmlydHVhbENvbCA9IGdyaWQudmlld1BvcnQudG9WaXJ0dWFsQ29sKGMpO1xuICAgICAgICAgICAgLy9pZiB3ZSBnb3QgdGhlIHNhbWUgdkNvbCB3ZSd2ZSBiZWVuIGNsYW1wZWQgYW5kIGl0cyB0aW1lIHRvIGhpZGUgdGhpcyBjZWxsXG4gICAgICAgICAgICAvL2Fsc28gaGlkZSB0aGUgY2VsbCBpZiBpdHMgd2lkdGggaXMgemVybyBjYXVzZSB5YS4uLlxuICAgICAgICAgICAgaWYgKHdpZHRoID09IDAgfHwgdmlydHVhbENvbCA9PT0gbGFzdFZpcnR1YWxDb2wpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSB3aWR0aCBmb3Igcm93cyBsYXRlciBidXQgb25seSBkbyBpdCBvbmUgdGltZSAoc28gb24gdGhlIGZpcnN0IHJvdylcbiAgICAgICAgICAgICAgICB0b3RhbFZpc2libGVDZWxsV2lkdGggKz0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RWaXJ0dWFsQ29sID0gdmlydHVhbENvbDtcbiAgICAgICAgICAgIGNlbGwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgY2VsbC5zdHlsZS53aWR0aCA9IHdpZHRoICsgYldpZHRoICsgJ3B4JztcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSBncmlkLnZpZXdQb3J0LmdldENvbExlZnQoYyk7XG5cbiAgICAgICAgICAgIGNlbGwuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuXG4gICAgICAgICAgICB3aGlsZSAoY2VsbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5yZW1vdmVDaGlsZChjZWxsLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZpcnR1YWxSb3cgPSBncmlkLnZpZXdQb3J0LnRvVmlydHVhbFJvdyhyKTtcblxuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICBpZiAociA8IGhlYWRlclJvd3MgfHwgYyA8IGhlYWRlckNvbHMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ3JpZC5kYXRhTW9kZWwuZ2V0SGVhZGVyKHZpcnR1YWxSb3csIHZpcnR1YWxDb2wpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ3JpZC5kYXRhTW9kZWwuZ2V0KGdyaWQucm93TW9kZWwudG9EYXRhKHZpcnR1YWxSb3cpLCBncmlkLmNvbE1vZGVsLnRvRGF0YSh2aXJ0dWFsQ29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2FydGlmaWNpYWxseSBvbmx5IGdldCBidWlsZGVycyBmb3Igcm93IGhlYWRlcnMgZm9yIG5vd1xuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSB2aXJ0dWFsUm93IDwgaGVhZGVyUm93cyAmJiBncmlkLnJvd01vZGVsLmdldCh2aXJ0dWFsUm93KS5idWlsZGVyIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBoYXNSb3dCdWlsZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIGhhc1Jvd0J1aWxkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBidWlsZGVyID0gZ3JpZC5jb2xNb2RlbC5nZXQodmlydHVhbENvbCkuYnVpbGRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNlbGxDaGlsZDtcbiAgICAgICAgICAgIGlmIChidWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1aWx0RWxlbTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUm93QnVpbGRlcikge1xuICAgICAgICAgICAgICAgICAgICBidWlsdEVsZW0gPSBidWlsdFJvd3NbdmlydHVhbFJvd11bY107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbHRFbGVtID0gYnVpbHRDb2xzW3ZpcnR1YWxDb2xdW3JdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsQ2hpbGQgPSBidWlsZGVyLnVwZGF0ZShidWlsdEVsZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgdmlydHVhbENvbDogdmlydHVhbENvbCxcbiAgICAgICAgICAgICAgICAgICAgdmlydHVhbFJvdzogdmlydHVhbFJvdyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiB3ZSBkaWRuJ3QgZ2V0IGEgY2hpbGQgZnJvbSB0aGUgYnVpbGRlciB1c2UgYSByZWd1bGFyIHRleHQgbm9kZVxuICAgICAgICAgICAgaWYgKCFjZWxsQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhLmZvcm1hdHRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGNlbGxDaGlsZCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIGRyYXdSb3cocikge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGdyaWQudmlld1BvcnQuZ2V0Um93SGVpZ2h0KHIpO1xuICAgICAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcl07XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID09IDApIHtcbiAgICAgICAgICAgICAgICByb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3cuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgcm93LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIGJXaWR0aCArICdweCc7XG4gICAgICAgICAgICB2YXIgdG9wID0gZ3JpZC52aWV3UG9ydC5nZXRSb3dUb3Aocik7XG4gICAgICAgICAgICByb3cuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJvdy5zdHlsZS53aWR0aCA9IHRvdGFsVmlzaWJsZUNlbGxXaWR0aCArICdweCc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChncmlkLmNlbGxTY3JvbGxNb2RlbC5yb3cgJSAyKSB7XG4gICAgICAgICAgICBjZWxsQ29udGFpbmVyLmNsYXNzTmFtZSA9IEdSSURfQ0VMTF9DT05UQUlORVJfQkFTRV9DTEFTUyArICcgb2Rkcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsQ29udGFpbmVyLmNsYXNzTmFtZSA9IEdSSURfQ0VMTF9DT05UQUlORVJfQkFTRV9DTEFTUztcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHZpZXdMYXllci5fYnVpbGRDZWxscyA9IGZ1bmN0aW9uIGJ1aWxkQ2VsbHMoY2VsbENvbnRhaW5lcikge1xuICAgICAgICB3aGlsZSAoY2VsbENvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBjZWxsQ29udGFpbmVyLnJlbW92ZUNoaWxkKGNlbGxDb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNlbGxzID0gW107XG4gICAgICAgIHJvd3MgPSBbXTtcbiAgICAgICAgdmFyIHJvdztcbiAgICAgICAgZ3JpZC52aWV3UG9ydC5pdGVyYXRlQ2VsbHMoZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gYnVpbGREaXZDZWxsKCk7XG4gICAgICAgICAgICBjZWxsc1tyXVtjXSA9IGNlbGw7XG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICBjZWxsc1tyXSA9IFtdO1xuICAgICAgICAgICAgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByb3cuc2V0QXR0cmlidXRlKCdjbGFzcycsICdncmlkLXJvdycpO1xuICAgICAgICAgICAgcm93LnNldEF0dHJpYnV0ZSgnZHRzJywgJ2dyaWQtcm93Jyk7XG4gICAgICAgICAgICByb3cuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgcm93LnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICAgICAgcm93c1tyXSA9IHJvdztcbiAgICAgICAgICAgIGNlbGxDb250YWluZXIuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkRGl2Q2VsbCgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ2R0cycsICdncmlkLWNlbGwnKTtcbiAgICAgICAgdmFyIHN0eWxlID0gY2VsbC5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICAgIHN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICBzdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuXG4gICAgLyogRU5EIENFTEwgTE9HSUMgKi9cblxuICAgIC8qIENPTCBCVUlMREVSIExPR0lDICovXG4gICAgdmlld0xheWVyLl9idWlsZENvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJ1aWx0Q29scyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGdyaWQuY29sTW9kZWwubGVuZ3RoKHRydWUpOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gZ3JpZC5jb2xNb2RlbC5nZXQoYykuYnVpbGRlcjtcbiAgICAgICAgICAgIGlmIChidWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgYnVpbHRDb2xzW2NdID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcmVhbFJvdyA9IDA7IHJlYWxSb3cgPCBncmlkLnZpZXdQb3J0LnJvd3M7IHJlYWxSb3crKykge1xuICAgICAgICAgICAgICAgICAgICBidWlsdENvbHNbY11bcmVhbFJvd10gPSBidWlsZGVyLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogRU5EIENPTCBCVUlMREVSIExPR0lDICovXG5cbiAgICAvKiBST1cgQlVJTERFUiBMT0dJQyBcbiAgICAgKiAgZm9yIG5vdyB3ZSBvbmx5IGJ1aWxkIGhlYWRlcnNcbiAgICAgKiAqL1xuXG4gICAgdmlld0xheWVyLl9idWlsZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJ1aWx0Um93cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGdyaWQucm93TW9kZWwubnVtSGVhZGVycygpOyByKyspIHtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gZ3JpZC5yb3dNb2RlbC5nZXQocikuYnVpbGRlcjtcbiAgICAgICAgICAgIGlmIChidWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgYnVpbHRSb3dzW3JdID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcmVhbENvbCA9IDA7IHJlYWxDb2wgPCBncmlkLnZpZXdQb3J0LmNvbHM7IHJlYWxDb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBidWlsdFJvd3Nbcl1bcmVhbENvbF0gPSBidWlsZGVyLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogRU5EIFJPVyBCVUlMREVSIExPR0lDKi9cblxuICAgIC8qIERFQ09SQVRPUiBMT0dJQyAqL1xuICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGJvdW5kaW5nQm94LCB0b3AsIGxlZnQsIGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gYm91bmRpbmdCb3guc3R5bGU7XG4gICAgICAgIGlmIChoZWlnaHQgPD0gMCB8fCB3aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnJ1xuICAgICAgICBzdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpb25EZWNvcmF0b3IoYm91bmRpbmcsIHQsIGwsIGgsIHcpIHtcbiAgICAgICAgc2V0UG9zaXRpb24oYm91bmRpbmcsIHQsIGwsIHV0aWwuY2xhbXAoaCwgMCwgZ3JpZC52aWV3UG9ydC5oZWlnaHQpLCB1dGlsLmNsYW1wKHcsIDAsIGdyaWQudmlld1BvcnQud2lkdGgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkNlbGxEZWNvcmF0b3JGcm9tVmlld0NlbGxSYW5nZShyZWFsQ2VsbFJhbmdlLCBib3VuZGluZ0JveCkge1xuICAgICAgICB2YXIgcmVhbFB4UmFuZ2UgPSBncmlkLnZpZXdQb3J0LnRvUHgocmVhbENlbGxSYW5nZSk7XG4gICAgICAgIHBvc2l0aW9uRGVjb3JhdG9yKGJvdW5kaW5nQm94LCByZWFsUHhSYW5nZS50b3AsIHJlYWxQeFJhbmdlLmxlZnQsIHJlYWxQeFJhbmdlLmhlaWdodCAmJiByZWFsUHhSYW5nZS5oZWlnaHQgKyBnZXRCb3JkZXJXaWR0aCgpLCByZWFsUHhSYW5nZS53aWR0aCAmJiByZWFsUHhSYW5nZS53aWR0aCArIGdldEJvcmRlcldpZHRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlRm9yRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHtcbiAgICAgICAgICAgIHRvcDogZGVzY3JpcHRvci50b3AsXG4gICAgICAgICAgICBsZWZ0OiBkZXNjcmlwdG9yLmxlZnQsXG4gICAgICAgICAgICBoZWlnaHQ6IGRlc2NyaXB0b3IuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IGRlc2NyaXB0b3Iud2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc3BhY2UgPT09ICdkYXRhJyAmJiBkZXNjcmlwdG9yLnVuaXRzID09PSAnY2VsbCcpIHtcbiAgICAgICAgICAgIHJhbmdlLnRvcCArPSBncmlkLnJvd01vZGVsLm51bUhlYWRlcnMoKTtcbiAgICAgICAgICAgIHJhbmdlLmxlZnQgKz0gZ3JpZC5jb2xNb2RlbC5udW1IZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIHZpZXdMYXllci5fZHJhd0RlY29yYXRvcnMgPSBmdW5jdGlvbiAoY2VsbHNQb3NpdGlvbk9yU2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgdmFyIGFsaXZlRGVjb3JhdG9ycyA9IGdyaWQuZGVjb3JhdG9ycy5nZXRBbGl2ZSgpO1xuICAgICAgICBhbGl2ZURlY29yYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG5cbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGRlY29yYXRvci5ib3VuZGluZ0JveDtcbiAgICAgICAgICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgICAgICAgICAgdmFyIGRlY0VsZW1lbnQgPSBkZWNvcmF0b3IucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3guYXBwZW5kQ2hpbGQoZGVjRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvckNvbnRhaW5lci5hcHBlbmRDaGlsZChib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdG9yLmlzRGlydHkoKSB8fCBjZWxsc1Bvc2l0aW9uT3JTaXplQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNvcmF0b3Iuc3BhY2UgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRlY29yYXRvci51bml0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRGVjb3JhdG9yKGJvdW5kaW5nQm94LCBkZWNvcmF0b3IudG9wLCBkZWNvcmF0b3IubGVmdCwgZGVjb3JhdG9yLmhlaWdodCwgZGVjb3JhdG9yLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2VsbERlY29yYXRvckZyb21WaWV3Q2VsbFJhbmdlKGRlY29yYXRvciwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY29yYXRvci5zcGFjZSA9PT0gJ3ZpcnR1YWwnIHx8IGRlY29yYXRvci5zcGFjZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGVjb3JhdG9yLnVuaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdweCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjZWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzA4NiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZUZvckRlc2NyaXB0b3IoZGVjb3JhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhbENlbGxSYW5nZSA9IGdyaWQudmlld1BvcnQuaW50ZXJzZWN0KHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhbENlbGxSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNlbGxEZWNvcmF0b3JGcm9tVmlld0NlbGxSYW5nZShyZWFsQ2VsbFJhbmdlLCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25EZWNvcmF0b3IoYm91bmRpbmdCb3gsIC0xLCAtMSwgLTEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgK1cwODYgKi9cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZW1vdmVEZWNvcmF0b3JzKGdyaWQuZGVjb3JhdG9ycy5wb3BBbGxEZWFkKCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZW1vdmVEZWNvcmF0b3JzKGRlY29yYXRvcnMpIHtcbiAgICAgICAgZGVjb3JhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGRlY29yYXRvci5ib3VuZGluZ0JveDtcbiAgICAgICAgICAgIGlmIChib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIC8vaWYgdGhleSByZW5kZXJlZCBhbiBlbGVtZW50IHByZXZpb3VzbHkgd2UgYXR0YWNoZWQgaXQgdG8gdGhlIGJvdW5kaW5nIGJveCBhcyB0aGUgb25seSBjaGlsZFxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlZEVsZW1lbnQgPSBib3VuZGluZ0JveC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgYSBkZXN0cm95IGRvbSBldmVudCB0aGF0IGJ1YmJsZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc3Ryb3lFdmVudCA9IGN1c3RvbUV2ZW50KCdkZWNvcmF0b3ItZGVzdHJveScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQuZGlzcGF0Y2hFdmVudChkZXN0cm95RXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvcmF0b3JDb250YWluZXIucmVtb3ZlQ2hpbGQoYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgIGRlY29yYXRvci5ib3VuZGluZ0JveCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogRU5EIERFQ09SQVRPUiBMT0dJQyAqL1xuXG4gICAgLyogQ0VMTCBDTEFTU0VTIExPR0lDICovXG4gICAgdmlld0xheWVyLl9kcmF3Q2VsbENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdyaWQudmlld1BvcnQuaXRlcmF0ZUNlbGxzKGZ1bmN0aW9uIChyLCBjKSB7XG4gICAgICAgICAgICBjZWxsc1tyXVtjXS5jbGFzc05hbWUgPSAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIGdyaWQuY2VsbENsYXNzZXMuZ2V0QWxsKCkuZm9yRWFjaChmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2VGb3JEZXNjcmlwdG9yKGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGdyaWQudmlld1BvcnQuaW50ZXJzZWN0KHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByb3dMb29wOlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGludGVyc2VjdGlvbi5oZWlnaHQ7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpbnRlcnNlY3Rpb24ud2lkdGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBpbnRlcnNlY3Rpb24udG9wICsgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gaW50ZXJzZWN0aW9uLmxlZnQgKyBjO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxSb3cgPSBjZWxsc1tyb3ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2VsbFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSByb3dMb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGNlbGxSb3dbY29sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lID0gKGNlbGwuY2xhc3NOYW1lID8gY2VsbC5jbGFzc05hbWUgKyAnICcgOiAnJykgKyBkZXNjcmlwdG9yLmNsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKiBFTkQgQ0VMTCBDTEFTU0VTIExPR0lDKi9cblxuICAgIHZpZXdMYXllci5kZXN0cm95ID0gY2xlYW51cDtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIHJlbW92ZURlY29yYXRvcnMoZ3JpZC5kZWNvcmF0b3JzLmdldEFsaXZlKCkuY29uY2F0KGdyaWQuZGVjb3JhdG9ycy5wb3BBbGxEZWFkKCkpKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnlTZWxlY3RvckFsbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIEdSSURfVklFV19ST09UX0NMQVNTKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeVNlbGVjdG9yQWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHF1ZXJ5U2VsZWN0b3JBbGxbaV07XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZXdMYXllci5kZXN0cm95KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh2aWV3TGF5ZXIuZHJhdy50aW1lb3V0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB2aWV3TGF5ZXI7XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHJhbmdlVXRpbCA9IHJlcXVpcmUoJy4uL3JhbmdlLXV0aWwnKTtcbnZhciBjYXBpdGFsaXplID0gcmVxdWlyZSgnY2FwaXRhbGl6ZScpO1xudmFyIGFkZERpcnR5UHJvcHMgPSByZXF1aXJlKCcuLi9hZGQtZGlydHktcHJvcHMnKTtcbnZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4uL2RlYm91bmNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcbiAgICB2YXIgZGlydHlDbGVhbiA9IHJlcXVpcmUoJy4uL2RpcnR5LWNsZWFuJykoZ3JpZCk7XG4gICAgdmFyIGNvbnRhaW5lcjtcblxuICAgIHZhciB2aWV3UG9ydCA9IGFkZERpcnR5UHJvcHMoe30sIFsncm93cycsICdjb2xzJywgJ3dpZHRoJywgJ2hlaWdodCddLCBbZGlydHlDbGVhbl0pO1xuICAgIHZpZXdQb3J0LnJvd3MgPSAwO1xuICAgIHZpZXdQb3J0LmNvbHMgPSAwO1xuICAgIHZpZXdQb3J0LmlzRGlydHkgPSBkaXJ0eUNsZWFuLmlzRGlydHk7XG5cbiAgICAvL3RoZXNlIHByb2JhYmx5IHRyaWdnZXIgcmVmbG93IHNvIHdlIG1heSBuZWVkIHRvIHRoaW5rIGFib3V0IGNhY2hpbmcgdGhlIHZhbHVlIGFuZCB1cGRhdGluZyBpdCBhdCBvbiBkcmF3cyBvciBzb21ldGhpbmdcbiAgICBmdW5jdGlvbiBnZXRGaXJzdENsaWVudFJlY3QoKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIgJiYgY29udGFpbmVyLmdldENsaWVudFJlY3RzICYmIGNvbnRhaW5lci5nZXRDbGllbnRSZWN0cygpICYmIGNvbnRhaW5lci5nZXRDbGllbnRSZWN0cygpWzBdIHx8IHt9O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2aWV3UG9ydCwgJ3RvcCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Rmlyc3RDbGllbnRSZWN0KCkudG9wIHx8IDA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2aWV3UG9ydCwgJ2xlZnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZpcnN0Q2xpZW50UmVjdCgpLmxlZnQgfHwgMDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmlld1BvcnQudG9HcmlkWCA9IGZ1bmN0aW9uIChjbGllbnRYKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRYIC0gdmlld1BvcnQubGVmdDtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQudG9HcmlkWSA9IGZ1bmN0aW9uIChjbGllbnRZKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRZIC0gdmlld1BvcnQudG9wO1xuICAgIH07XG5cblxuICAgIHZhciBmaXhlZCA9IHtyb3dzOiAwLCBjb2xzOiAwfTtcblxuICAgIGZ1bmN0aW9uIGdldEZpeGVkKHJvd09yQ29sKSB7XG4gICAgICAgIHJldHVybiBmaXhlZFtyb3dPckNvbCArICdzJ107XG4gICAgfVxuXG4gICAgdmlld1BvcnQuc2l6ZVRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgY29udGFpbmVyID0gZWxlbTtcbiAgICAgICAgdmlld1BvcnQud2lkdGggPSBlbGVtLm9mZnNldFdpZHRoO1xuICAgICAgICB2aWV3UG9ydC5oZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmlld1BvcnQucm93cyA9IGNhbGN1bGF0ZU1heExlbmd0aHModmlld1BvcnQuaGVpZ2h0LCBncmlkLnJvd01vZGVsKTtcbiAgICAgICAgdmlld1BvcnQuY29scyA9IGNhbGN1bGF0ZU1heExlbmd0aHModmlld1BvcnQud2lkdGgsIGdyaWQuY29sTW9kZWwpO1xuICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKCdncmlkLXZpZXdwb3J0LWNoYW5nZScpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC5fb25SZXNpemUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZXdQb3J0Ll9yZXNpemUoKTtcbiAgICB9LCAyMDApO1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodmlld1BvcnQuX29uUmVzaXplLnRpbWVvdXQpO1xuICAgICAgICBjbGVhclRpbWVvdXQoc2hvcnREZWJvdW5jZWRSZXNpemUudGltZW91dCk7XG4gICAgfSk7XG5cbiAgICB2aWV3UG9ydC5fcmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2aWV3UG9ydC5zaXplVG9Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2hvcnREZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZXdQb3J0Ll9yZXNpemUoKTtcbiAgICB9LCAxKTtcblxuICAgIHZpZXdQb3J0LnNob3J0RGVib3VuY2VkUmVzaXplID0gc2hvcnREZWJvdW5jZWRSZXNpemU7XG5cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ3Jlc2l6ZScsIHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvL3dlIGRvbid0IGJpbmQgdGhlIGhhbmRsZXIgZGlyZWN0bHkgc28gdGhhdCB0ZXN0cyBjYW4gbW9jayBpdCBvdXRcbiAgICAgICAgdmlld1BvcnQuX29uUmVzaXplKCk7XG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLXJvdy1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpeGVkLnJvd3MgPSBncmlkLnJvd01vZGVsLm51bUZpeGVkKCk7XG4gICAgICAgIHNob3J0RGVib3VuY2VkUmVzaXplKCk7XG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWNvbC1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpeGVkLmNvbHMgPSBncmlkLmNvbE1vZGVsLm51bUZpeGVkKCk7XG4gICAgICAgIHNob3J0RGVib3VuY2VkUmVzaXplKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhbFRvVmlydHVhbChjb29yZCwgcm93T3JDb2wsIGNvb3JkSXNWaXJ0dWFsKSB7XG4gICAgICAgIC8vY291bGQgY2FjaGUgdGhpcyBvbiBjaGFuZ2VzIGkuZS4gcm93LWNoYW5nZSBvciBjb2wtY2hhbmdlIGV2ZW50c1xuICAgICAgICB2YXIgbnVtRml4ZWQgPSBnZXRGaXhlZChyb3dPckNvbCk7XG4gICAgICAgIGlmIChjb29yZCA8IG51bUZpeGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkICsgKGNvb3JkSXNWaXJ0dWFsID8gLTEgOiAxKSAqIGdyaWQuY2VsbFNjcm9sbE1vZGVsW3Jvd09yQ29sXTtcbiAgICB9XG5cbi8vIGNvbnZlcnRzIGEgdmlld3BvcnQgcm93IG9yIGNvbHVtbiB0byBhIHJlYWwgcm93IG9yIGNvbHVtbiBcbi8vIGNsYW1wcyBpdCBpZiB0aGUgY29sdW1uIHdvdWxkIGJlIG91dHNpZGUgdGhlIHJhbmdlXG4gICAgZnVuY3Rpb24gZ2V0VmlydHVhbFJvd0NvbFVuc2FmZShyZWFsQ29vcmQsIHJvd09yQ29sKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0UmVhbFRvVmlydHVhbChyZWFsQ29vcmQsIHJvd09yQ29sKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaXJ0dWFsUm93Q29sQ2xhbXBlZCh2aWV3Q29vcmQsIHJvd09yQ29sKSB7XG4gICAgICAgIHZhciB2aXJ0dWFsUm93Q29sID0gZ2V0VmlydHVhbFJvd0NvbFVuc2FmZSh2aWV3Q29vcmQsIHJvd09yQ29sKTtcbiAgICAgICAgcmV0dXJuIGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsWydjbGFtcCcgKyBjYXBpdGFsaXplKHJvd09yQ29sKV0odmlydHVhbFJvd0NvbCk7XG4gICAgfVxuXG4gICAgdmlld1BvcnQudG9WaXJ0dWFsUm93ID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIGdldFZpcnR1YWxSb3dDb2xDbGFtcGVkKHIsICdyb3cnKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQudG9WaXJ0dWFsQ29sID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGdldFZpcnR1YWxSb3dDb2xDbGFtcGVkKGMsICdjb2wnKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVhbFJvd0NvbENsYW1wZWQodmlydHVhbENvb3JkLCByb3dPckNvbCkge1xuICAgICAgICB2YXIgbnVtRml4ZWQgPSBnZXRGaXhlZChyb3dPckNvbCk7XG4gICAgICAgIGlmICh2aXJ0dWFsQ29vcmQgPCBudW1GaXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxDb29yZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4Vmlld1BvcnRJbmRleCA9IHZpZXdQb3J0W3Jvd09yQ29sICsgJ3MnXSAtIDE7XG4gICAgICAgIHJldHVybiB1dGlsLmNsYW1wKHZpcnR1YWxDb29yZCAtIGdyaWQuY2VsbFNjcm9sbE1vZGVsW3Jvd09yQ29sXSwgbnVtRml4ZWQsIG1heFZpZXdQb3J0SW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LnJvd0lzSW5WaWV3ID0gZnVuY3Rpb24gKHZpcnR1YWxSb3cpIHtcbiAgICAgICAgdmFyIHJlYWxSb3cgPSB2aWV3UG9ydC50b1JlYWxSb3codmlydHVhbFJvdyk7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocmVhbFJvdykgJiYgZ2V0TGVuZ3RoQmV0d2VlblZpZXdDb29yZHMoMCwgcmVhbFJvdywgJ3JvdycsICdoZWlnaHQnLCB0cnVlKSA8IHZpZXdQb3J0LmhlaWdodDtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuY29sSXNJblZpZXcgPSBmdW5jdGlvbiAodmlydHVhbENvbCkge1xuICAgICAgICB2YXIgcmVhbENvbCA9IHZpZXdQb3J0LnRvUmVhbENvbCh2aXJ0dWFsQ29sKTtcbiAgICAgICAgcmV0dXJuICFpc05hTihyZWFsQ29sKSAmJiBnZXRMZW5ndGhCZXR3ZWVuVmlld0Nvb3JkcygwLCByZWFsQ29sLCAnY29sJywgJ3dpZHRoJywgdHJ1ZSkgPCB2aWV3UG9ydC53aWR0aDtcbiAgICB9O1xuXG5cbi8vZGVmYXVsdCB1bmNsYW1wZWQgY2F1c2UgdGhhdCBzZWVtcyB0byBiZSB0aGUgbW9yZSBsaWtlbHkgdXNlIGNhc2UgY29udmVydGluZyB0aGlzIGRpcmVjdGlvblxuICAgIHZpZXdQb3J0LnRvUmVhbFJvdyA9IGZ1bmN0aW9uICh2aXJ0dWFsUm93KSB7XG4gICAgICAgIHJldHVybiBnZXRSZWFsUm93Q29sQ2xhbXBlZCh2aXJ0dWFsUm93LCAncm93Jyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LnRvUmVhbENvbCA9IGZ1bmN0aW9uICh2aXJ0dWFsQ29sKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWFsUm93Q29sQ2xhbXBlZCh2aXJ0dWFsQ29sLCAnY29sJyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmNsYW1wUm93ID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xhbXAociwgMCwgdmlld1BvcnQucm93cyAtIDEpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC5jbGFtcENvbCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmNsYW1wKGMsIDAsIHZpZXdQb3J0LmNvbHMgLSAxKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuY2xhbXBZID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xhbXAoeSwgMCwgdmlld1BvcnQuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuY2xhbXBYID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xhbXAoeCwgMCwgdmlld1BvcnQud2lkdGgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRMZW5ndGhCZXR3ZWVuVmlld0Nvb3JkcyhzdGFydENvb3JkLCBlbmRDb29yZCwgcm93T3JDb2wsIGhlaWdodE9yV2lkdGgsIGluY2x1c2l2ZSkge1xuICAgICAgICB2YXIgcm93T3JDb2xDYXAgPSBjYXBpdGFsaXplKHJvd09yQ29sKTtcbiAgICAgICAgdmFyIHRvVmlydHVhbCA9IHZpZXdQb3J0Wyd0b1ZpcnR1YWwnICsgcm93T3JDb2xDYXBdO1xuICAgICAgICB2YXIgbGVuZ3RoRm4gPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFtoZWlnaHRPcldpZHRoXTtcbiAgICAgICAgdmFyIGNsYW1wRm4gPSB2aWV3UG9ydFsnY2xhbXAnICsgcm93T3JDb2xDYXBdO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgdmFyIG51bUZpeGVkID0gZ2V0Rml4ZWQocm93T3JDb2wpO1xuICAgICAgICB2YXIgaXNJbk5vbmZpeGVkQXJlYSA9IGVuZENvb3JkID49IG51bUZpeGVkO1xuICAgICAgICB2YXIgaXNJbkZpeGVkQXJlYSA9IHN0YXJ0Q29vcmQgPCBudW1GaXhlZDtcbiAgICAgICAgdmFyIGV4Y2x1c2l2ZU9mZnNldCA9IChpbmNsdXNpdmUgPyAwIDogMSk7XG4gICAgICAgIGlmIChpc0luRml4ZWRBcmVhKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRFbmRDb29yZCA9IChpc0luTm9uZml4ZWRBcmVhID8gbnVtRml4ZWQgLSAxIDogZW5kQ29vcmQgLSBleGNsdXNpdmVPZmZzZXQpO1xuICAgICAgICAgICAgcG9zICs9IGxlbmd0aEZuKHN0YXJ0Q29vcmQsIGZpeGVkRW5kQ29vcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luTm9uZml4ZWRBcmVhKSB7XG4gICAgICAgICAgICBwb3MgKz0gbGVuZ3RoRm4oKGlzSW5GaXhlZEFyZWEgPyB0b1ZpcnR1YWwobnVtRml4ZWQpIDogdG9WaXJ0dWFsKHN0YXJ0Q29vcmQpKSwgdG9WaXJ0dWFsKGNsYW1wRm4oZW5kQ29vcmQpKSAtIGV4Y2x1c2l2ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUb3BPckxlZnQoZW5kQ29vcmQsIHJvd09yQ29sLCBoZWlnaHRPcldpZHRoKSB7XG4gICAgICAgIHJldHVybiBnZXRMZW5ndGhCZXR3ZWVuVmlld0Nvb3JkcygwLCBlbmRDb29yZCwgcm93T3JDb2wsIGhlaWdodE9yV2lkdGgpO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LmdldFJvd1RvcCA9IGZ1bmN0aW9uICh2aWV3UG9ydENvb3JkKSB7XG4gICAgICAgIHJldHVybiBnZXRUb3BPckxlZnQodmlld1BvcnRDb29yZCwgJ3JvdycsICdoZWlnaHQnKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuZ2V0Q29sTGVmdCA9IGZ1bmN0aW9uICh2aWV3UG9ydENvbCkge1xuICAgICAgICByZXR1cm4gZ2V0VG9wT3JMZWZ0KHZpZXdQb3J0Q29sLCAnY29sJywgJ3dpZHRoJyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LnRvUHggPSBmdW5jdGlvbiAocmVhbENlbGxSYW5nZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiB2aWV3UG9ydC5nZXRSb3dUb3AocmVhbENlbGxSYW5nZS50b3ApLFxuICAgICAgICAgICAgbGVmdDogdmlld1BvcnQuZ2V0Q29sTGVmdChyZWFsQ2VsbFJhbmdlLmxlZnQpLFxuICAgICAgICAgICAgaGVpZ2h0OiBnZXRMZW5ndGhCZXR3ZWVuVmlld0Nvb3JkcyhyZWFsQ2VsbFJhbmdlLnRvcCwgcmVhbENlbGxSYW5nZS50b3AgKyByZWFsQ2VsbFJhbmdlLmhlaWdodCAtIDEsICdyb3cnLCAnaGVpZ2h0JywgdHJ1ZSksXG4gICAgICAgICAgICB3aWR0aDogZ2V0TGVuZ3RoQmV0d2VlblZpZXdDb29yZHMocmVhbENlbGxSYW5nZS5sZWZ0LCByZWFsQ2VsbFJhbmdlLmxlZnQgKyByZWFsQ2VsbFJhbmdlLndpZHRoIC0gMSwgJ2NvbCcsICd3aWR0aCcsIHRydWUpXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFJvd09yQ29sRnJvbVBvc2l0aW9uKHBvcywgcm93T3JDb2wsIGhlaWdodE9yV2lkdGgsIHJldHVyblZpcnR1YWwpIHtcbiAgICAgICAgLy93ZSBjb3VsZCBkbyB0aGlzIHNsaWdobHkgZmFzdGVyIHdpdGggYmluYXJ5IHNlYXJjaCB0byBnZXQgbG9nKG4pIGluc3RlYWQgb2YgbiwgYnV0IHdpbGwgb25seSBkbyBpdCBpZiB3ZSBhY3R1YWxseSBuZWVkIHRvIG9wdGltaXplIHRoaXNcbiAgICAgICAgdmFyIHJvd09yQ29sQ2FwID0gY2FwaXRhbGl6ZShyb3dPckNvbCk7XG4gICAgICAgIHZhciB2aWV3TWF4ID0gdmlld1BvcnRbcm93T3JDb2wgKyAncyddO1xuICAgICAgICB2YXIgdG9WaXJ0dWFsID0gdmlld1BvcnRbJ3RvVmlydHVhbCcgKyByb3dPckNvbENhcF07XG4gICAgICAgIHZhciBsZW5ndGhGbiA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsW2hlaWdodE9yV2lkdGhdO1xuICAgICAgICB2YXIgc3VtbWVkTGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3TWF4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2aXJ0dWFsID0gdG9WaXJ0dWFsKGkpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxlbmd0aEZuKHZpcnR1YWwpO1xuICAgICAgICAgICAgdmFyIG5ld1N1bSA9IHN1bW1lZExlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZXdTdW0gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmlydHVhbCA/IHZpcnR1YWwgOiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtbWVkTGVuZ3RoID0gbmV3U3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdmlld1BvcnQuZ2V0VmlydHVhbFJvd0J5VG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICByZXR1cm4gZ2V0Um93T3JDb2xGcm9tUG9zaXRpb24odG9wLCAncm93JywgJ2hlaWdodCcsIHRydWUpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC5nZXRWaXJ0dWFsQ29sQnlMZWZ0ID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvd09yQ29sRnJvbVBvc2l0aW9uKGxlZnQsICdjb2wnLCAnd2lkdGgnLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuZ2V0Um93QnlUb3AgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHJldHVybiBnZXRSb3dPckNvbEZyb21Qb3NpdGlvbih0b3AsICdyb3cnLCAnaGVpZ2h0Jyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmdldENvbEJ5TGVmdCA9IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgIHJldHVybiBnZXRSb3dPckNvbEZyb21Qb3NpdGlvbihsZWZ0LCAnY29sJywgJ3dpZHRoJyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmdldFJvd0hlaWdodCA9IGZ1bmN0aW9uICh2aWV3UG9ydFJvdykge1xuICAgICAgICByZXR1cm4gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuaGVpZ2h0KHZpZXdQb3J0LnRvVmlydHVhbFJvdyh2aWV3UG9ydC5jbGFtcFJvdyh2aWV3UG9ydFJvdykpKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuZ2V0Q29sV2lkdGggPSBmdW5jdGlvbiAodmlld1BvcnRDb2wpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLndpZHRoKHZpZXdQb3J0LnRvVmlydHVhbENvbCh2aWV3UG9ydC5jbGFtcENvbCh2aWV3UG9ydENvbCkpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0Um93c09yQ29scyhpbnRlcnNlY3Rpb24sIHJhbmdlLCB0b3BPckxlZnQsIHJvd09yQ29sLCBoZWlnaHRPcldpZHRoKSB7XG4gICAgICAgIHZhciBudW1GaXhlZCA9IGZpeGVkW3Jvd09yQ29sICsgJ3MnXTtcbiAgICAgICAgdmFyIGZpeGVkUmFuZ2UgPSBbMCwgbnVtRml4ZWRdO1xuXG4gICAgICAgIHZhciB2aXJ0dWFsUmFuZ2UgPSBbcmFuZ2VbdG9wT3JMZWZ0XSwgcmFuZ2VbaGVpZ2h0T3JXaWR0aF1dO1xuICAgICAgICB2YXIgZml4ZWRJbnRlcnNlY3Rpb24gPSByYW5nZVV0aWwuaW50ZXJzZWN0KGZpeGVkUmFuZ2UsIHZpcnR1YWxSYW5nZSk7XG4gICAgICAgIHZhciBzY3JvbGxSYW5nZSA9IFtudW1GaXhlZCwgdmlld1BvcnRbcm93T3JDb2wgKyAncyddIC0gbnVtRml4ZWRdO1xuICAgICAgICB2aXJ0dWFsUmFuZ2VbMF0gLT0gZ3JpZC5jZWxsU2Nyb2xsTW9kZWxbcm93T3JDb2xdO1xuICAgICAgICB2YXIgc2Nyb2xsSW50ZXJzZWN0aW9uID0gcmFuZ2VVdGlsLmludGVyc2VjdChzY3JvbGxSYW5nZSwgdmlydHVhbFJhbmdlKTtcbiAgICAgICAgdmFyIHJlc3VsdFJhbmdlID0gcmFuZ2VVdGlsLnVuaW9uKGZpeGVkSW50ZXJzZWN0aW9uLCBzY3JvbGxJbnRlcnNlY3Rpb24pO1xuICAgICAgICBpZiAoIXJlc3VsdFJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGludGVyc2VjdGlvblt0b3BPckxlZnRdID0gcmVzdWx0UmFuZ2VbMF07XG4gICAgICAgIGludGVyc2VjdGlvbltoZWlnaHRPcldpZHRoXSA9IHJlc3VsdFJhbmdlWzFdO1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LmludGVyc2VjdCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAvL2Fzc3VtZSB2aXJ0dWFsIGNlbGxzIGZvciBub3dcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGludGVyc2VjdFJvd3NPckNvbHMoe30sIHJhbmdlLCAndG9wJywgJ3JvdycsICdoZWlnaHQnKTtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RSb3dzT3JDb2xzKGludGVyc2VjdGlvbiwgcmFuZ2UsICdsZWZ0JywgJ2NvbCcsICd3aWR0aCcpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU1heExlbmd0aHModG90YWxMZW5ndGgsIGxlbmd0aE1vZGVsKSB7XG4gICAgICAgIHZhciBsZW5ndGhNZXRob2QgPSBsZW5ndGhNb2RlbC53aWR0aCAmJiBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC53aWR0aCB8fCBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5oZWlnaHQ7XG4gICAgICAgIHZhciBudW1GaXhlZCA9IGxlbmd0aE1vZGVsLm51bUZpeGVkKCk7XG4gICAgICAgIHZhciB3aW5kb3dMZW5ndGggPSAwO1xuICAgICAgICB2YXIgbWF4U2l6ZSA9IDA7XG4gICAgICAgIHZhciBmaXhlZExlbmd0aCA9IDA7XG4gICAgICAgIHZhciB3aW5kb3dTdGFydEluZGV4ID0gbnVtRml4ZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgZml4ZWQgPSAwOyBmaXhlZCA8IG51bUZpeGVkOyBmaXhlZCsrKSB7XG4gICAgICAgICAgICBmaXhlZExlbmd0aCArPSBsZW5ndGhNZXRob2QoZml4ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pdCBtaWdodCBiZSBzYWZlciB0byBhY3R1YWxseSBzdW0gdGhlIGxlbmd0aHMgaW4gdGhlIHZpcnR1YWxQaXhlbENlbGxNb2RlbCBidXQgZm9yIG5vdyBoZXJlIGlzIG9rXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gbnVtRml4ZWQ7IGluZGV4IDwgbGVuZ3RoTW9kZWwubGVuZ3RoKHRydWUpOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoT2ZJaW5kZXggPSBsZW5ndGhNZXRob2QoaW5kZXgpO1xuICAgICAgICAgICAgd2luZG93TGVuZ3RoICs9IGxlbmd0aE9mSWluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKHdpbmRvd0xlbmd0aCArIGZpeGVkTGVuZ3RoID4gdG90YWxMZW5ndGggJiYgd2luZG93U3RhcnRJbmRleCA8IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgd2luZG93TGVuZ3RoIC09IGxlbmd0aE1ldGhvZCh3aW5kb3dTdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICB3aW5kb3dTdGFydEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2luZG93U2l6ZSA9IGluZGV4IC0gd2luZG93U3RhcnRJbmRleCArIDE7IC8vIGFkZCB0aGUgb25lIGJlY2F1c2Ugd2Ugd2FudCB0aGUgbGFzdCBpbmRleCB0aGF0IGRpZG4ndCBmaXRcbiAgICAgICAgICAgIGlmICh3aW5kb3dTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIG1heFNpemUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFNpemUgKyBudW1GaXhlZCArIDE7XG4gICAgfVxuXG5cbiAgICB2aWV3UG9ydC5pdGVyYXRlQ2VsbHMgPSBmdW5jdGlvbiAoY2VsbEZuLCBvcHRpb25hbFJvd0ZuLCBvcHRpb25hbE1heFJvdywgb3B0aW9uYWxNYXhDb2wpIHtcbiAgICAgICAgb3B0aW9uYWxNYXhSb3cgPSBvcHRpb25hbE1heFJvdyB8fCBJbmZpbml0eTtcbiAgICAgICAgb3B0aW9uYWxNYXhDb2wgPSBvcHRpb25hbE1heENvbCB8fCBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBNYXRoLm1pbih2aWV3UG9ydC5yb3dzLCBvcHRpb25hbE1heFJvdyk7IHIrKykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsUm93Rm4pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbFJvd0ZuKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbGxGbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgTWF0aC5taW4odmlld1BvcnQuY29scywgb3B0aW9uYWxNYXhDb2wpOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbEZuKHIsIGMpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB2aWV3UG9ydDtcbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuICAgIHZhciBtb2RlbCA9IHt9O1xuXG4gICAgLy9hbGwgcGl4ZWxzIGFyZSBhc3N1bWVkIHRvIGJlIGluIHRoZSB2aXJ0dWFsIHdvcmxkLCBubyByZWFsIHdvcmxkIHBpeGVscyBhcmUgZGVhbHQgd2l0aCBoZXJlIDopXG4gICAgbW9kZWwuZ2V0Um93ID0gZnVuY3Rpb24gKHRvcFB4KSB7XG4gICAgICAgIGlmICh0b3BQeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1bUxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZ3JpZC5yb3dNb2RlbC5sZW5ndGgodHJ1ZSk7IHIrKykge1xuICAgICAgICAgICAgc3VtTGVuZ3RoICs9IGdyaWQucm93TW9kZWwuaGVpZ2h0KHIpO1xuICAgICAgICAgICAgaWYgKHRvcFB4IDwgc3VtTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9O1xuXG4gICAgLy95ZXMgdGhlc2UgYXJlIHZlcnkgc2ltaWxhciBidXQgdGhlcmUgd2lsbCBiZSBkaWZmZXJlbmNlc1xuICAgIG1vZGVsLmdldENvbCA9IGZ1bmN0aW9uIChsZWZ0UHgpIHtcbiAgICAgICAgaWYgKGxlZnRQeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1bUxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgZ3JpZC5jb2xNb2RlbC5sZW5ndGgodHJ1ZSk7IGMrKykge1xuICAgICAgICAgICAgc3VtTGVuZ3RoICs9IGdyaWQuY29sTW9kZWwud2lkdGgoYyk7XG4gICAgICAgICAgICBpZiAobGVmdFB4IDwgc3VtTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBjbGFtcFJvd09yQ29sKHZpcnR1YWxSb3dDb2wsIHJvd09yQ29sKSB7XG4gICAgICAgIHZhciBtYXhSb3dDb2wgPSBncmlkW3Jvd09yQ29sICsgJ01vZGVsJ10ubGVuZ3RoKHRydWUpIC0gMTtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xhbXAodmlydHVhbFJvd0NvbCwgMCwgbWF4Um93Q29sKTtcbiAgICB9XG5cbiAgICBtb2RlbC5jbGFtcFJvdyA9IGZ1bmN0aW9uICh2aXJ0dWFsUm93KSB7XG4gICAgICAgIHJldHVybiBjbGFtcFJvd09yQ29sKHZpcnR1YWxSb3csICdyb3cnKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuY2xhbXBDb2wgPSBmdW5jdGlvbiAodmlydHVhbENvbCkge1xuICAgICAgICByZXR1cm4gY2xhbXBSb3dPckNvbCh2aXJ0dWFsQ29sLCAnY29sJyk7XG4gICAgfTtcblxuICAgIC8vZm9yIG5vdyB0aGVzZSBqdXN0IGNhbGwgdGhyb3VnaCB0byB0aGUgcm93IGFuZCBjb2x1bW4gbW9kZWwsIGJ1dCB2ZXJ5IGxpa2VseSBpdCB3aWxsIG5lZWQgdG8gaW5jbHVkZSBzb21lIG90aGVyIGNhbGN1bGF0aW9uc1xuICAgIG1vZGVsLmhlaWdodCA9IGZ1bmN0aW9uICh2aXJ0dWFsUm93U3RhcnQsIHZpcnR1YWxSb3dFbmQpIHtcbiAgICAgICAgcmV0dXJuIGhlaWdodE9yV2lkdGgodmlydHVhbFJvd1N0YXJ0LCB2aXJ0dWFsUm93RW5kLCAncm93Jyk7XG4gICAgfTtcblxuICAgIG1vZGVsLndpZHRoID0gZnVuY3Rpb24gKHZpcnR1YWxDb2xTdGFydCwgdmlydHVhbENvbEVuZCkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0T3JXaWR0aCh2aXJ0dWFsQ29sU3RhcnQsIHZpcnR1YWxDb2xFbmQsICdjb2wnKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGVpZ2h0T3JXaWR0aChzdGFydCwgZW5kLCByb3dPckNvbCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSB1dGlsLmlzTnVtYmVyKGVuZCkgPyBlbmQgOiBzdGFydDtcbiAgICAgICAgZW5kID0gY2xhbXBSb3dPckNvbChlbmQsIHJvd09yQ29sKTtcbiAgICAgICAgc3RhcnQgPSBjbGFtcFJvd09yQ29sKHN0YXJ0LCByb3dPckNvbCk7XG4gICAgICAgIHZhciBsZW5ndGhNb2RlbCA9IGdyaWRbcm93T3JDb2wgKyAnTW9kZWwnXTtcbiAgICAgICAgdmFyIGxlbmd0aEZuID0gbGVuZ3RoTW9kZWwud2lkdGggfHwgbGVuZ3RoTW9kZWwuaGVpZ2h0O1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBsZW5ndGhGbihpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cblxuICAgIG1vZGVsLnRvdGFsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuaGVpZ2h0KDAsIGdyaWQucm93TW9kZWwubGVuZ3RoKHRydWUpIC0gMSk7XG4gICAgfTtcblxuICAgIG1vZGVsLnRvdGFsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC53aWR0aCgwLCBncmlkLmNvbE1vZGVsLmxlbmd0aCh0cnVlKSAtIDEpO1xuICAgIH07XG5cbiAgICBtb2RlbC5maXhlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmhlaWdodCgwLCBncmlkLnJvd01vZGVsLm51bUZpeGVkKCkgLSAxKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuZml4ZWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLndpZHRoKDAsIGdyaWQuY29sTW9kZWwubnVtRml4ZWQoKSAtIDEpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzaXplQ2hhbmdlTGlzdGVuZXIoKSB7XG4gICAgICAgIC8vZm9yIG5vdyB3ZSBkb24ndCBjYWNoZSBhbnl0aGluZyBhYm91dCB0aGlzIHNvIHdlIGp1c3Qgbm90aWZ5XG4gICAgICAgIGdyaWQuZXZlbnRMb29wLmZpcmUoJ2dyaWQtdmlydHVhbC1waXhlbC1jZWxsLWNoYW5nZScpO1xuICAgIH1cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtY29sLWNoYW5nZScsIHNpemVDaGFuZ2VMaXN0ZW5lcik7XG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1yb3ctY2hhbmdlJywgc2l6ZUNoYW5nZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBtb2RlbDtcbn07Il19
