(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
angular.module('riq-grid', [
  require('./angular-decorator').name
])
  .factory('RiqGridSrvc', function () {
    return {
      core: require('./core')
    };
  })
;


},{"./angular-decorator":13,"./core":21}],2:[function(require,module,exports){
module.exports = function (string) {
  return string.charAt(0).toUpperCase() + string.substring(1);
}

module.exports.words = function (string) {
  return string.replace(/(^|\W)(\w)/g, function (m) {
    return m.toUpperCase()
  })
}

},{}],3:[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (classes.indexOf(className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = classes.indexOf(className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return classes.indexOf(className) > -1
}

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var alnum, ref;

  ref = require('../ref').ref;

  alnum = {
    '0': ref('0', 48),
    '1': ref('1', 49),
    '2': ref('2', 50),
    '3': ref('3', 51),
    '4': ref('4', 52),
    '5': ref('5', 53),
    '6': ref('6', 54),
    '7': ref('7', 55),
    '8': ref('8', 56),
    '9': ref('9', 57),
    a: ref('A', 65),
    b: ref('B', 66),
    c: ref('C', 67),
    d: ref('D', 68),
    e: ref('E', 69),
    f: ref('F', 70),
    g: ref('G', 71),
    h: ref('H', 72),
    i: ref('I', 73),
    j: ref('J', 74),
    k: ref('K', 75),
    l: ref('L', 76),
    m: ref('M', 77),
    n: ref('N', 78),
    o: ref('O', 79),
    p: ref('P', 80),
    q: ref('Q', 81),
    r: ref('R', 82),
    s: ref('S', 83),
    t: ref('T', 84),
    u: ref('U', 85),
    v: ref('V', 86),
    w: ref('W', 87),
    x: ref('X', 88),
    y: ref('Y', 89),
    z: ref('Z', 90)
  };

  module.exports = alnum;

}).call(this);

},{"../ref":10}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var arrow, ref;

  ref = require('../ref').ref;

  arrow = {
    left: ref('Left', 37),
    up: ref('Up', 38),
    right: ref('Right', 39),
    down: ref('Down', 40)
  };

  module.exports = arrow;

}).call(this);

},{"../ref":10}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var brand, ref;

  ref = require('../ref').ref;

  brand = {
    apple: ref('Apple &#8984;', 224),
    windows: {
      start: ref('Windows start', [91, 92]),
      menu: ref('Windows menu', 93)
    }
  };

  module.exports = brand;

}).call(this);

},{"../ref":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var punctuation, ref;

  ref = require('../ref').ref;

  punctuation = {
    colon: ref('Colon/Semicolon', [59, 186]),
    equal: ref('Equal/Plus', [61, 187]),
    comma: ref('Comma/Less Than', [44, 188]),
    hyphen: ref('Hyphen/Underscore', [45, 109, 189]),
    period: ref('Period/Greater Than', [46, 190]),
    tilde: ref('Tilde/Back Tick', [96, 192]),
    apostrophe: ref('Apostrophe/Quote', [39, 222]),
    slash: {
      forward: ref('Forward Slash/Question Mark', [47, 191]),
      backward: ref('Backward Slash/Pipe', 220)
    },
    brace: {
      square: {
        open: ref('Open Square/Curly Brace', 219),
        close: ref('Close Square/Curly Brace', 221)
      }
    }
  };

  punctuation.semicolon = punctuation.colon;

  punctuation.plus = punctuation.equal;

  punctuation.lessthan = punctuation.comma;

  punctuation.underscore = punctuation.hyphen;

  punctuation.greaterthan = punctuation.period;

  punctuation.question = punctuation.slash.forward;

  punctuation.backtick = punctuation.tilde;

  punctuation.pipe = punctuation.slash.backward;

  punctuation.quote = punctuation.apostrophe;

  punctuation.brace.curly = punctuation.brace.square;

  module.exports = punctuation;

}).call(this);

},{"../ref":10}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var ref, special;

  ref = require('../ref').ref;

  special = {
    backspace: ref('Backspace', 8),
    tab: ref('Tab', 9),
    enter: ref('Enter', 13),
    shift: ref('Shift', 16),
    ctrl: ref('Ctrl', 17),
    alt: ref('Alt', 18),
    caps: ref('Caps Lock', 20),
    esc: ref('Escape', 27),
    space: ref('Space', 32),
    num: ref('Num Lock', 144)
  };

  module.exports = special;

}).call(this);

},{"../ref":10}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var isRef, iterator, key,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  isRef = require('./ref').isRef;

  key = {};

  key.code = {
    special: require('./code/special'),
    arrow: require('./code/arrow'),
    punctuation: require('./code/punctuation'),
    alnum: require('./code/alnum'),
    brand: require('./code/brand')
  };

  key.get = function(pressed) {
    return iterator(key.code, pressed);
  };

  key.is = function(ref, pressed) {
    if (!isRef(ref)) {
      ref = iterator(ref, pressed);
    }
    if (isRef(ref)) {
      if (isRef(pressed)) {
        return pressed === ref;
      } else {
        return pressed === ref.code || __indexOf.call(ref.code, pressed) >= 0;
      }
    } else {
      return pressed === ref;
    }
  };

  iterator = function(context, pressed) {
    var i, out, ref;
    for (i in context) {
      if (!__hasProp.call(context, i)) continue;
      ref = context[i];
      if (isRef(ref)) {
        if (key.is(ref, pressed)) {
          return ref;
        }
      } else {
        out = iterator(ref, pressed);
        if (isRef(out)) {
          return out;
        }
      }
    }
  };

  if (typeof window !== 'undefined') {
    window.key = key;
  }

  module.exports = key;

}).call(this);

},{"./code/alnum":4,"./code/arrow":5,"./code/brand":6,"./code/punctuation":7,"./code/special":8,"./ref":10}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Reference, assertRef, isRef, ref;

  Reference = (function() {

    function Reference(name, code) {
      this.name = name;
      this.code = code;
    }

    return Reference;

  })();

  ref = function(name, code) {
    return new Reference(name, code);
  };

  isRef = function(ref) {
    return ref instanceof Reference;
  };

  assertRef = function(ref) {
    if (!isRef(ref)) {
      throw new Error('Invalid reference');
    }
    return ref;
  };

  module.exports = {
    ref: ref,
    isRef: isRef,
    assertRef: assertRef
  };

}).call(this);

},{}],11:[function(require,module,exports){
var addDirtyProps = require('../add-dirty-props');
var util = require('../util');
var noop = require('../no-op');
var passThrough = require('../pass-through');

module.exports = function (_grid, name, lengthName, defaultSize) {
    var grid = _grid;

    var descriptors = [];
    var numFixed = 0;
    var numHeaders = 0;
    var makeDirtyClean = require('../dirty-clean');
    var dirtyClean = makeDirtyClean(grid);
    var builderDirtyClean = makeDirtyClean(grid);
    var selected = [];

    function setDescriptorsDirty(eventOptional) {
        var event = eventOptional || {};
        event.type = 'grid-' + name + '-change';
        grid.eventLoop.fire(event);
        dirtyClean.setDirty();
        builderDirtyClean.setDirty();
    }

    function fireSelectionChange() {
        grid.eventLoop.fire('grid-' + name + '-selection-change');
    }

    function updateDescriptorIndices() {
        descriptors.forEach(function (descriptor, i) {
            descriptor.index = i;
        });
    }

    var api = {
        areBuildersDirty: builderDirtyClean.isDirty,
        isDirty: dirtyClean.isDirty,
        defaultSize: defaultSize,
        add: function (toAdd) {
            if (!util.isArray(toAdd)) {
                toAdd = [toAdd];
            }
            toAdd.forEach(function (descriptor) {
                if (descriptor.header) {
                    descriptors.splice(numHeaders, 0, descriptor);
                    numFixed++;
                    numHeaders++;
                }

                else {
                    //if the column is fixed and the last one added is fixed (we only allow fixed at the beginning for now)
                    if (descriptor.fixed) {
                        if (!descriptors.length || descriptors[descriptors.length - 1].fixed) {
                            numFixed++;
                        } else {
                            throw 'Cannot add a fixed column after an unfixed one';
                        }
                    }
                    descriptors.push(descriptor);
                }
            });
            updateDescriptorIndices();
            setDescriptorsDirty({action: 'add', descriptors: toAdd});
        },
        addHeaders: function (toAdd) {
            if (!util.isArray(toAdd)) {
                toAdd = [toAdd];
            }
            toAdd.forEach(function (header) {
                header.header = true;
            });
            api.add(toAdd);
        },
        header: function (index) {
            return descriptors[index];
        },
        get: function (index) {
            return descriptors[index];
        },
        length: function (includeHeaders) {
            var subtract = includeHeaders ? 0 : numHeaders;
            return descriptors.length - subtract;
        },
        remove: function (descriptor, dontUpdateIndex) {
            var index = descriptors.indexOf(descriptor);
            if (index !== -1) {
                descriptors.splice(index, 1);
                if (descriptor.header) {
                    numFixed--;
                    numHeaders--;
                } else if (descriptor.fixed) {
                    numFixed--;
                }
            }
            if (!dontUpdateIndex) {
                updateDescriptorIndices();
            }
        },
        clear: function (includeHeaders) {
            descriptors.slice(0).forEach(function (descriptor) {
                if (includeHeaders || !descriptor.header) {
                    api.remove(descriptor, true);
                }
            });
        },
        move: function (start, target) {
            descriptors.splice(target, 0, descriptors.splice(start, 1)[0]);
            updateDescriptorIndices();
            setDescriptorsDirty({action: 'move', descriptors: [api.get(start), api.get(target)]});
        },
        numHeaders: function () {
            return numHeaders;
        },
        numFixed: function () {
            return numFixed;
        },
        toVirtual: function (dataIndex) {
            return dataIndex + api.numHeaders();
        },
        toData: function (virtualIndex) {
            return virtualIndex - api.numHeaders();
        },

        select: function (index) {

            var descriptor = api[name](index);
            if (!descriptor.selected) {
                descriptor.selected = true;
                selected.push(index);
                fireSelectionChange();
            }
        },
        deselect: function (index, dontNotify) {
            var descriptor = api[name](index);
            if (descriptor.selected) {
                descriptor.selected = false;
                selected.splice(selected.indexOf(index), 1);
                if (!dontNotify) {
                    fireSelectionChange();
                }
            }
        },
        toggleSelect: function (index) {
            var descriptor = api[name](index);
            if (descriptor.selected) {
                api.deselect(index);
            } else {
                api.select(index);
            }
        },
        clearSelected: function () {
            var length = selected.length;
            selected.slice(0).forEach(function (index) {
                api.deselect(index, true);
            });
            if (length) {
                fireSelectionChange();
            }
        },
        getSelected: function () {
            return selected;
        },
        create: function (builder) {
            var descriptor = {};
            var fixed = false;
            Object.defineProperty(descriptor, 'fixed', {
                enumerable: true,
                get: function () {
                    return descriptor.header || fixed;
                },
                set: function (_fixed) {
                    fixed = _fixed;
                }
            });
//
//            Object.defineProperty(descriptor, 'index', {
//                enumerable: true,
//                get: function () {
//                    return descriptors.indexOf(descriptor);
//                }
//            });

            addDirtyProps(descriptor, ['builder'], [builderDirtyClean]);
            descriptor.builder = builder;

            return addDirtyProps(descriptor, [
                {
                    name: lengthName,
                    onDirty: function () {
                        setDescriptorsDirty({action: 'size', descriptors: [descriptor]});
                    }
                },
                {
                    name: 'hidden',
                    onDirty: function () {
                        setDescriptorsDirty({action: 'hide', descriptors: [descriptor]});
                    }
                }
            ], [dirtyClean]);
        },
        createBuilder: function (render, update) {
            return {render: render || noop, update: update || passThrough};
        }

    };

    //basically height or width
    api[lengthName] = function (index) {
        var descriptor = descriptors[index];
        if (!descriptor) {
            return NaN;
        }


        if (descriptor.hidden) {
            return 0;
        }

        return descriptor[lengthName] || api.defaultSize;
    };

    //row or col get
    api[name] = function (index) {
        return descriptors[index + numHeaders];
    };

    return api;
};
},{"../add-dirty-props":12,"../dirty-clean":26,"../no-op":32,"../pass-through":33,"../util":41}],12:[function(require,module,exports){
module.exports = function (obj, props, dirtyCleans) {
    props.forEach(function (prop) {
        var val;
        var name = prop.name || prop;
        Object.defineProperty(obj, name, {
            enumerable: true,
            get: function () {
                return val;
            }, set: function (_val) {
                var isChanged = _val !== val;
                
                val = _val;

                if (isChanged) {
                    dirtyCleans.forEach(function (dirtyClean) {
                        dirtyClean.setDirty();
                    });
                    if (prop.onDirty) {
                        prop.onDirty();
                    }
                }
            }
        });
    });
    return obj;
};
},{}],13:[function(require,module,exports){
module.exports = angular.module('grid-decorator', [])
    .factory('GridDecoratorSrvc', function ($compile) {
        var GridDecoratorSrvc = {
            render: function (opts) {
                var compiled = $compile(opts.template)(opts.$scope);
                compiled.on('decorator-destroy', function () {
                    opts.$scope.$destroy();
                    //unbind in a timeout to allow any other listeners to fire first
                    setTimeout(function () {
                        compiled.off('decorator-destroy');
                    }, 1);
                });
                opts.$scope.$apply();
                if (opts.events) {
                    compiled[0].style.pointerEvents = 'all';
                }
                return compiled[0];
            },
            headerDecorators: function (grid, model) {
                var origAnnotate = model.annotateDecorator;
                model.annotateDecorator = function (dec) {
                    dec.render = function () {
                        return GridDecoratorSrvc.render(dec.renderOpts);
                    };
                    if (origAnnotate) {
                        origAnnotate(dec);
                    }
                };

                require('../header-decorators')(grid, model);
            }
        };
        return GridDecoratorSrvc
    })

;
},{"../header-decorators":28}],14:[function(require,module,exports){
var positionRange = require('../position-range');
var makeDirtyClean = require('../dirty-clean');
var addDirtyProps = require('../add-dirty-props');

module.exports = function (_grid) {
    var grid = _grid;

    var dirtyClean = makeDirtyClean(grid);
    var descriptors = [];

    var api = {
        add: function (descriptor) {
            descriptors.push(descriptor);
            dirtyClean.setDirty();
        },
        remove: function (descriptor) {
            descriptors.splice(descriptors.indexOf(descriptor), 1);
            dirtyClean.setDirty();
        },
        getAll: function () {
            return descriptors.slice(0);
        },
        create: function (top, left, className, height, width, space) {
            var thisDirtyClean = makeDirtyClean(grid);
            var descriptor = {};
            //mixins
            positionRange(descriptor, thisDirtyClean, dirtyClean);
            addDirtyProps(descriptor, ['class'], [thisDirtyClean, dirtyClean]);

            //all of these are optional
            descriptor.top = top;
            descriptor.left = left;
            //default to single cell ranges
            descriptor.height = height || 1;
            descriptor.width = width || 1;
            descriptor.class = className;
            descriptor.space = space || descriptor.space;
            return descriptor;
        },
        isDirty: dirtyClean.isDirty
    };


    return api;
};
},{"../add-dirty-props":12,"../dirty-clean":26,"../position-range":35}],15:[function(require,module,exports){
var customEvent = require('../custom-event');

var PROPS_TO_COPY_FROM_MOUSE_EVENTS = ['clientX', 'clientY', 'gridX', 'gridY', 'layerX', 'layerY', 'row', 'col', 'realRow', 'realCol'];


module.exports = function (_grid) {
    var grid = _grid;

    var model = {};

    var wasDragged = false;

    model._annotateEvent = function annotateEvent(e) {
        switch (e.type) {
            case 'click':
                e.wasDragged = wasDragged;
            /* jshint -W086 */
            case 'mousedown':
            /* jshint +W086 */
            case 'mousemove':
            case 'mouseup':
            case 'dblclick':
                model._annotateEventInternal(e);
                break;

        }
    };

    model._annotateEventFromViewCoords = function (e, viewRow, viewCol) {
        e.realRow = viewRow;
        e.realCol = viewCol;
        e.virtualRow = grid.viewPort.toVirtualRow(e.realRow);
        e.virtualCol = grid.viewPort.toVirtualCol(e.realCol);
        e.row = e.virtualRow - grid.rowModel.numHeaders();
        e.col = e.virtualCol - grid.colModel.numHeaders();
    }

    model._annotateEventInternal = function (e) {
        var y = grid.viewPort.toGridY(e.clientY);
        var x = grid.viewPort.toGridX(e.clientX);
        var viewRow = grid.viewPort.getRowByTop(y);
        var viewCol = grid.viewPort.getColByLeft(x);
        model._annotateEventFromViewCoords(e, viewRow, viewCol);
        e.gridX = x;
        e.gridY = y;
    };

    grid.eventLoop.addInterceptor(function (e) {
        model._annotateEvent(e);

        if (e.type === 'mousedown') {
            setupDragEventForMouseDown(e);
        }
    });

    function setupDragEventForMouseDown(downEvent) {
        wasDragged = false;
        var lastDragRow = downEvent.row;
        var lastDragCol = downEvent.col;
        var dragStarted = false;
        var unbindMove = grid.eventLoop.bind('mousemove', window, function (e) {
            if (dragStarted && !e.which) {
                //got a move event without mouse down which means we somehow missed the mouseup
                console.log('mousemove unbind, how on earth do these happen?');
                handleMouseUp(e);
                return;
            }

            if (!dragStarted) {
                wasDragged = true;
                createAndFireDragEvent('grid-drag-start', downEvent);
                dragStarted = true;
            }

            createAndFireDragEvent('grid-drag', e);

            if (e.row !== lastDragRow || e.col !== lastDragCol) {
                createAndFireDragEvent('grid-cell-drag', e);

                lastDragRow = e.row;
                lastDragCol = e.col;
            }

        });

        var unbindUp = grid.eventLoop.bind('mouseup', window, handleMouseUp);

        function handleMouseUp(e) {
            unbindMove();
            unbindUp();

            var dragEnd = createDragEventFromMouseEvent('grid-drag-end', e);

            //row, col, x, and y should inherit
            grid.eventLoop.fire(dragEnd);
        }
    }

    function createDragEventFromMouseEvent(type, e) {
        var event = customEvent(type, true, true);
        PROPS_TO_COPY_FROM_MOUSE_EVENTS.forEach(function (prop) {
            event[prop] = e[prop];
        });
        event.originalEvent = e;
        return event;
    }

    function createAndFireDragEvent(type, e) {
        var drag = createDragEventFromMouseEvent(type, e);
        if (e.target) {
            e.target.dispatchEvent(drag);
        } else {
            grid.eventLoop.fire(drag);
        }
        return drag;
    }

    return model;
};
},{"../custom-event":23}],16:[function(require,module,exports){
var util = require('../util');

module.exports = function (_grid) {
    var grid = _grid;
    var dirtyClean = require('../dirty-clean')(grid);


    var row;
    var model = {col: 0};
    Object.defineProperty(model, 'row', {
        enumerable: true,
        get: function () {
            return row;
        },
        set: function (r) {
            row = r;
        }
    });
    model.row = 0;

    model.isDirty = dirtyClean.isDirty;

    model.scrollTo = function (r, c, dontFire, fromPixelModel) {
        if (isNaN(r) || isNaN(c)) {
            return;
        }
        var maxRow = (grid.rowModel.length() || 1) - 1;
        var maxCol = (grid.colModel.length() || 1) - 1;
        var lastRow = model.row;
        var lastCol = model.col;
        model.row = util.clamp(r, 0, maxRow);
        model.col = util.clamp(c, 0, maxCol);
        if (lastRow !== model.row || lastCol !== model.col) {
            dirtyClean.setDirty();

            if (!dontFire) {
                grid.eventLoop.fire('grid-cell-scroll');
            }

            if (!fromPixelModel) {
                var top = grid.virtualPixelCellModel.height(0, model.row - 1);
                var left = grid.virtualPixelCellModel.width(0, model.col - 1);
                grid.pixelScrollModel.scrollTo(top, left, true);
            }
        }
    };

    function convertVirtualToScroll(virtualCoord, rowOrCol) {
        return virtualCoord - grid[rowOrCol + 'Model'].numFixed();
    }

    function getScrollToRowOrCol(virtualCoord, rowOrCol, heightWidth) {
        var currentScroll = model[rowOrCol];
        var scrollTo = currentScroll;
        if (grid.viewPort[rowOrCol + 'IsInView'](virtualCoord)) {
            return scrollTo;
        }

        var targetScroll = convertVirtualToScroll(virtualCoord, rowOrCol);
        if (targetScroll < currentScroll) {
            scrollTo = targetScroll;
        } else if (targetScroll > currentScroll) {

            var lengthToCell = grid.virtualPixelCellModel[heightWidth](0, virtualCoord);
            var numFixed = grid[rowOrCol + 'Model'].numFixed();
            scrollTo = 0;
            for (var i = numFixed; i < virtualCoord; i++) {
                lengthToCell -= grid.virtualPixelCellModel[heightWidth](i);
                scrollTo = i - (numFixed - 1);
                if (lengthToCell <= grid.viewPort[heightWidth]) {
                    break;
                }
            }
        }

        return scrollTo;
    }

    model.scrollIntoView = function (vr, vc) {
        vr = grid.virtualPixelCellModel.clampRow(vr);
        vc = grid.virtualPixelCellModel.clampCol(vc);
        var newRow = getScrollToRowOrCol(vr, 'row', 'height');
        var newCol = getScrollToRowOrCol(vc, 'col', 'width');
        model.scrollTo(newRow, newCol);
    };


    return model;
};
},{"../dirty-clean":26,"../util":41}],17:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = require('../abstract-row-col-model')(grid, 'col', 'width', 100);

    return api;
};
},{"../abstract-row-col-model":11}],18:[function(require,module,exports){
var elementClass = require('element-class');
var util = require('../util');


module.exports = function (_grid) {
    var grid = _grid;

    var api = {annotateDecorator: makeReorderDecorator};

    function makeReorderDecorator(headerDecorator) {
        var col = headerDecorator.left;
        headerDecorator._dragRect = grid.decorators.create(0, undefined, Infinity, undefined, 'px', 'real');

        headerDecorator._dragRect.postRender = function (div) {
            div.setAttribute('class', 'grid-drag-rect');
        };

        headerDecorator._onDragStart = function (e) {
            if (e.realCol < grid.colModel.numFixed()) {
                return;
            }


            grid.decorators.add(headerDecorator._dragRect);

            headerDecorator._dragRect.width = grid.viewPort.getColWidth(col);
            var colOffset = e.gridX - headerDecorator.getDecoratorLeft();

            headerDecorator._dragRect._targetCol = grid.decorators.create(0, undefined, Infinity, 1, 'cell', 'real');
            headerDecorator._dragRect._targetCol.postRender = function (div) {
                div.setAttribute('class', 'grid-reorder-target');
                headerDecorator._dragRect._targetCol._renderedElem = div;
            };
            grid.decorators.add(headerDecorator._dragRect._targetCol);

            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (e) {
                headerDecorator._dragRect.left = util.clamp(e.gridX - colOffset, grid.viewPort.getColLeft(grid.colModel.numFixed()), Infinity);
                headerDecorator._dragRect._targetCol.left = util.clamp(e.realCol, grid.colModel.numFixed(), Infinity);
                if (e.realCol > col) {
                    elementClass(headerDecorator._dragRect._targetCol._renderedElem).add('right');
                } else {
                    elementClass(headerDecorator._dragRect._targetCol._renderedElem).remove('right');
                }


            });

            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function (e) {
                var targetCol = headerDecorator._dragRect._targetCol.left;

                grid.colModel.move(grid.viewPort.toVirtualCol(col), grid.viewPort.toVirtualCol(targetCol));
                grid.decorators.remove([headerDecorator._dragRect._targetCol, headerDecorator._dragRect]);
                headerDecorator._unbindDrag();
                headerDecorator._unbindDragEnd();
            });
        };

        headerDecorator.postRender = function (div) {
            div.setAttribute('class', 'grid-col-reorder');
            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);
        };

        return headerDecorator;
    }

    require('../header-decorators')(grid, api);

    return api;
};
},{"../header-decorators":28,"../util":41,"element-class":3}],19:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = {annotateDecorator: annotateDecorator};

    function annotateDecorator(headerDecorator) {
        var col = headerDecorator.left;
        headerDecorator._dragLine = grid.decorators.create(0, undefined, Infinity, 1, 'px', 'real');

        headerDecorator._dragLine.postRender = function (div) {
            div.setAttribute('class', 'grid-drag-line');
        };

        headerDecorator._onDragStart = function (e) {

            grid.decorators.add(headerDecorator._dragLine);

            headerDecorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (e) {
                var minX = headerDecorator.getDecoratorLeft() + 10;
                headerDecorator._dragLine.left = Math.max(e.gridX, minX);
            });

            headerDecorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function (e) {
                grid.colModel.get(grid.viewPort.toVirtualCol(col)).width = headerDecorator._dragLine.left - headerDecorator.getDecoratorLeft();
                grid.decorators.remove(headerDecorator._dragLine);
                headerDecorator._unbindDrag();
                headerDecorator._unbindDragEnd();
            });
        };

        headerDecorator.postRender = function (div) {
            div.style.transform = 'translateX(50%)';
            div.style.webkitTransform = 'translateX(50%)';

            div.style.removeProperty('left');
            div.setAttribute('class', 'col-resize');

            grid.eventLoop.bind('grid-drag-start', div, headerDecorator._onDragStart);
        };
    }

    require('../header-decorators')(grid, api);

    return api;
};
},{"../header-decorators":28}],20:[function(require,module,exports){
var ctrlOrCmd = require('../ctrl-or-cmd');
var tsv = require('../tsv');
var debounce = require('../debounce');
var rangeUtil = require('../range-util');


module.exports = function (_grid) {
    var grid = _grid;

    function getCopyPasteRange() {
        var selectionRange = grid.navigationModel.selection;
        //valid selection range cannot go to -1
        if (selectionRange.top === -1) {
            selectionRange = {
                top: grid.navigationModel.focus.row,
                left: grid.navigationModel.focus.col,
                width: 1,
                height: 1
            };
        }
        return selectionRange;
    }

    grid.eventLoop.bind('copy', function (e) {
        //prepare for copy
        var copyData = [];
        var selectionRange = getCopyPasteRange();
        rangeUtil.iterate(selectionRange, function () {
            var row = [];
            copyData.push(row)
            return row;
        }, function (r, c, row) {
            var data = grid.dataModel.getCopyData(r, c);
            row.push(data);
        });
        if (e.clipboardData && e.clipboardData.setData) {
            e.preventDefault();
            e.clipboardData.setData('Text', tsv.stringify(copyData));
        } else {
            console.warn('copy event without clipboard data or setdata property');
        }

    });

    grid.eventLoop.bind('paste', function (e) {
        var selectionRange = getCopyPasteRange();
        if (!e.clipboardData || !e.clipboardData.getData) {
            console.warn('no clipboard data on paste event');
            return;
        }
        var pasteData = tsv.parse(e.clipboardData.getData('Text'));
        var dataChanges = [];
        rangeUtil.iterate(selectionRange, function (r, c) {
            var offsetR = r - selectionRange.top;
            var offsetC = c - selectionRange.left;
            dataChanges.push({row: r, col: c, data: pasteData[offsetR][offsetC], paste: true});
        });
        grid.dataModel.set(dataChanges);
    });

    var maybeSelectText = debounce(function maybeSelectTextInner() {
        if (!model.isSelectionDisabled || !model.isSelectionDisabled()) {
            grid.textarea.value = ' ';
            grid.textarea.select();
        }
    }, 1)

    grid.eventLoop.bind('keyup', maybeSelectText);
    grid.eventLoop.bind('grid-focus', maybeSelectText);

    var model = {};
    return model;
};
},{"../ctrl-or-cmd":22,"../debounce":24,"../range-util":36,"../tsv":40}],21:[function(require,module,exports){
var elementClass = require('element-class');
var dirtyClean = require('../dirty-clean');

module.exports = function () {

    var grid = {};

    //the order here matters because some of these depend on each other
    grid.eventLoop = require('../event-loop')(grid);
    grid.decorators = require('../decorators')(grid);
    grid.cellClasses = require('../cell-classes')(grid);
    grid.rowModel = require('../row-model')(grid);
    grid.colModel = require('../col-model')(grid);
    grid.dataModel = require('../simple-data-model')(grid);
    grid.virtualPixelCellModel = require('../virtual-pixel-cell-model')(grid);
    grid.cellScrollModel = require('../cell-scroll-model')(grid);
    grid.cellMouseModel = require('../cell-mouse-model')(grid);

    grid.viewPort = require('../view-port')(grid);
    grid.viewLayer = require('../view-layer')(grid);

    //things with logic that also register decorators (slightly less core than the other models)
    grid.navigationModel = require('../navigation-model')(grid);
    grid.pixelScrollModel = require('../pixel-scroll-model')(grid);
    grid.colResize = require('../col-resize')(grid);
    grid.colReorder = require('../col-reorder')(grid);
    grid.showHiddenCols = require('../show-hidden-cols')(grid);
    grid.copyPaste = require('../copy-paste')(grid);

    var drawRequested = false;
    grid.requestDraw = function () {
        if (!grid.eventLoop.isRunning) {
            grid.viewLayer.draw();
        } else {
            drawRequested = true;
        }
    };

    grid.eventLoop.bind('grid-draw', function () {
        drawRequested = false;
    });

    grid.eventLoop.addExitListener(function () {
        if (drawRequested) {
            grid.viewLayer.draw();
        }
    });

    function setupTextareaForContainer(textarea, container) {
        textarea.addEventListener('focus', function () {
            if (container) {
                elementClass(container).add('focus');
            }
            textarea.select();
            grid.eventLoop.fire('grid-focus');
        });

        textarea.addEventListener('blur', function () {
            if (container) {
                elementClass(container).remove('focus');
            }
            grid.eventLoop.fire('grid-blur');
        });

        container.appendChild(textarea);
        if (!container.getAttribute('tabIndex')) {
            container.tabIndex = -1;
        }
        container.addEventListener('focus', function () {
            if (textarea) {
                textarea.focus();
            }
        });
    }

    function createFocusTextArea() {
        var textarea = document.createElement('textarea');
        textarea.setAttribute('dts', 'grid-textarea');
        textarea.style.position = 'fixed';
        textarea.style.left = '-100000px';
        return textarea;
    }

    grid.build = function (container) {
        setupTextareaForContainer(grid.textarea, container);
        grid.viewPort.sizeToContainer(container);
        grid.viewLayer.build(container);
        grid.eventLoop.setContainer(container);
    };

    grid.makeDirtyClean = function () {
        return dirtyClean(grid);
    };

    grid.textarea = createFocusTextArea();

    return grid;
};
},{"../cell-classes":14,"../cell-mouse-model":15,"../cell-scroll-model":16,"../col-model":17,"../col-reorder":18,"../col-resize":19,"../copy-paste":20,"../decorators":25,"../dirty-clean":26,"../event-loop":27,"../navigation-model":31,"../pixel-scroll-model":34,"../row-model":37,"../show-hidden-cols":38,"../simple-data-model":39,"../view-layer":42,"../view-port":43,"../virtual-pixel-cell-model":44,"element-class":3}],22:[function(require,module,exports){
module.exports = function (e) {
    return (window.navigator.userAgent.match(/win/i) ? e.ctrlKey : e.metaKey)
};
},{}],23:[function(require,module,exports){
module.exports = function (name, bubbles, cancelable, detail) {
    var event = document.createEvent('CustomEvent');  // MUST be 'CustomEvent'
    event.initCustomEvent(name, bubbles, cancelable, detail);
    return event;
};
},{}],24:[function(require,module,exports){
module.exports = function (fn, delay) {
    var f = function debounced() {
        if (f.timeout) {
            clearTimeout(f.timeout);
            f.timeout = undefined;
        }
        f.timeout = setTimeout(fn, delay);
    };
    return f;
};
},{}],25:[function(require,module,exports){
var util = require('../util');
var makeDirtyClean = require('../dirty-clean');
var positionRange = require('../position-range');

module.exports = function (_grid) {
    var grid = _grid;

    var dirtyClean = makeDirtyClean(grid);

    var aliveDecorators = [];
    var deadDecorators = [];

    var decorators = {
        add: function (decorator) {
            aliveDecorators.push(decorator);
            dirtyClean.setDirty();
        },
        remove: function (decorators) {
            if (!util.isArray(decorators)) {
                decorators = [decorators];
            }
            decorators.forEach(function (decorator) {
                var index = aliveDecorators.indexOf(decorator);
                if (index !== -1) {
                    aliveDecorators.splice(index, 1);
                    deadDecorators.push(decorator);
                    dirtyClean.setDirty();
                }
            });
        },
        getAlive: function () {
            return aliveDecorators.slice(0);
        },
        popAllDead: function () {
            var oldDead = deadDecorators;
            deadDecorators = [];
            return oldDead;
        },
        isDirty: dirtyClean.isDirty,
        create: function (t, l, h, w, u, s) {
            var decorator = {};
            var thisDirtyClean = makeDirtyClean(grid);

            //mixin the position range functionality
            positionRange(decorator, thisDirtyClean, dirtyClean);
            decorator.top = t;
            decorator.left = l;
            decorator.height = h;
            decorator.width = w;
            decorator.units = u || decorator.units;
            decorator.space = s || decorator.space;

            //they can override but we should have an empty default to prevent npes
            decorator.render = function () {
                var div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.top = '0px';
                div.style.left = '0px';
                div.style.bottom = '0px';
                div.style.right = '0px';
                if (decorator.postRender) {
                    decorator.postRender(div);
                }
                return div;
            };
            return decorator;

        }

    };


    return decorators;
};
},{"../dirty-clean":26,"../position-range":35,"../util":41}],26:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;
    var dirty = true;

    grid.eventLoop.bind('grid-draw', function () {
        api.setClean();
    });


    var api = {
        isDirty: function () {
            return dirty;
        },
        isClean: function () {
            return !dirty;
        },
        setDirty: function () {
            dirty = true;
            //when things are initalizing sometimes this doesn't exist yet
            //we have to hope that at the end of initialization the grid will call request draw itself
            if (grid.requestDraw) {
                grid.requestDraw();
            }
        },
        setClean: function () {
            dirty = false;
        }
    };
    return api;
};
},{}],27:[function(require,module,exports){
var mousewheel = require('../mousewheel');
var util = require('../util');
var listeners = require('../listeners');

var EVENTS = ['click', 'mousedown', 'mouseup', 'mousemove', 'dblclick', 'keydown', 'keypress', 'keyup', 'copy', 'paste'];

var GRID_EVENTS = ['grid-drag-start', 'grid-drag', 'grid-cell-drag', 'grid-drag-end'];

var eventLoop = function (_grid) {
    var grid = _grid;
    var eloop = {
        isRunning: false
    };

    var handlersByName = {};
    var domUnbindFns = [];

    var unbindAll;

    eloop.setContainer = function (container) {
        var unbindMouseWheelFn = mousewheel.bind(container, mainLoop);

        EVENTS.forEach(function (name) {
            bindToDomElement(container, name, mainLoop);
        });

        GRID_EVENTS.forEach(function (name) {
            bindToDomElement(window, name, mainLoop);
        });

        unbindAll = function () {
            unbindMouseWheelFn();

            //have to copy the array since the unbind will actually remove itself from the array which modifies it mid iteration
            domUnbindFns.slice(0).forEach(function (unbind) {
                unbind();
            });
        };
    };

    function getHandlers(name) {
        var handlers = handlersByName[name];
        if (!handlers) {
            handlers = handlersByName[name] = [];
        }
        return handlers;
    }

    function bindToDomElement(elem, name, listener) {
        elem.addEventListener(name, listener);
        var unbindFn = function () {
            elem.removeEventListener(name, listener);
            domUnbindFns.splice(domUnbindFns.indexOf(unbindFn), 1);
        };
        domUnbindFns.push(unbindFn);
        return unbindFn;
    }

    function getHandlerFromArgs(args) {
        var handler = args.filter(function (arg) {
            return typeof arg === 'function';
        })[0];
        return handler;
    }

    eloop.bind = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        var name = args.filter(function (arg) {
            return typeof arg === 'string';
        })[0];
        var handler = getHandlerFromArgs(args);
        if (!handler || !name) {
            throw 'cannot bind without at least name and function';
        }


        var elem = args.filter(function (arg) {
            return util.isElement(arg) || arg === window || arg === document;
        })[0];

        if (!elem) {
            getHandlers(name).push(handler);
            return function () {
                var handlers = getHandlers(name);
                handlers.splice(handlers.indexOf(handler), 1);
            };
        } else {
            var listener = loopWith(handler);
            //make sure the elem can receive events
            if (elem.style) {
                elem.style.pointerEvents = 'all';
            }
            return bindToDomElement(elem, name, listener);
        }
    };

    eloop.bindOnce = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        var handler = getHandlerFromArgs(args);
        args.splice(args.indexOf(handler), 1, function bindOnceHandler(e) {
            unbind();
            handler(e);
        });
        var unbind = eloop.bind.apply(this, args);
        return unbind;
    }

    eloop.fire = function (event) {
        event = typeof event === 'string' ? {type: event} : event;
        mainLoop(event);
    };

    var interceptors = listeners();
    var exitListeners = listeners();

    eloop.addInterceptor = interceptors.addListener;
    eloop.addExitListener = exitListeners.addListener;

    function loopWith(fn) {
        return function (e) {
            loop(e, fn);
        };
    }

    var mainLoop = loopWith(function (e) {
        //have to copy the array because handlers can unbind themselves which modifies the array
        //we use some so that we can break out of the loop if need be
        getHandlers(e.type).slice(0).some(function (handler) {
            handler(e);
            if (e.gridStopBubbling) {
                return true;
            }
        });
    });

    function loop(e, bodyFn) {
        var isOuterLoopRunning = eloop.isRunning;
        eloop.isRunning = true;
        interceptors.notify(e);
        if (!e.gridStopBubbling) {
            bodyFn(e);
        }

        if (!isOuterLoopRunning) {
            eloop.isRunning = false;
            exitListeners.notify(e);
        }
    }

    eloop.bind('grid-destroy', function () {
        unbindAll();
        eloop.destroyed = true;
    });

    eloop.stopBubbling = function (e) {
        e.gridStopBubbling = true;
        return e;
    };

    return eloop;
};


eventLoop.EVENTS = EVENTS;
eventLoop.GRID_EVENTS = GRID_EVENTS;
module.exports = eventLoop;
},{"../listeners":29,"../mousewheel":30,"../util":41}],28:[function(require,module,exports){
module.exports = function (_grid, model) {
    var grid = _grid;

    var api = model || {};
    api._decorators = {};

    function makeDecorator(col) {
        var decorator = grid.decorators.create(0, col, 1, 1, 'cell', 'real');


        decorator.getDecoratorLeft = function () {
            var firstRect = decorator.boundingBox && decorator.boundingBox.getClientRects() && decorator.boundingBox.getClientRects()[0] || {};
            return grid.viewPort.toGridX(firstRect.left) || 0;
        };

        if (api.annotateDecorator) {
            api.annotateDecorator(decorator);
        }


        return decorator;
    }

    api.makeDecorator = api.makeDecorator || makeDecorator;

    function ensureDecoratorPerCol() {
        for (var c = 0; c < grid.viewPort.cols; c++) {
            if (!api._decorators[c]) {
                if (api.isNeeded && !api.isNeeded(c)) {
                    continue;
                }
                var decorator = api.makeDecorator(c);
                api._decorators[c] = decorator;
                grid.decorators.add(decorator);
            }
        }
    }

    grid.eventLoop.bind('grid-viewport-change', function () {
        ensureDecoratorPerCol();
    });
    ensureDecoratorPerCol();

    return api;
};
},{}],29:[function(require,module,exports){
/*
 A simple package for creating a list of listeners that can be added to and notified
 */

module.exports = function () {
    var listeners = [];
    return {
        //returns a removal function to unbind the listener
        addListener: function (fn) {
            listeners.push(fn);
            return function () {
                listeners.splice(listeners.indexOf(fn), 1);
            };
        },
        notify: function (e) {
            listeners.forEach(function (listener) {
                listener(e);
            });
        }
    };
};
},{}],30:[function(require,module,exports){
var EVENT_NAMES = ['mousewheel', 'wheel', 'DOMMouseScroll'];

var api = {
    getDelta: function (event, xaxis) {
        if (event.wheelDelta) { //for everything but firefox
            var delta = event.wheelDeltaY;
            if (xaxis) {
                delta = event.wheelDeltaX;
            }
            return delta;

        } else if (event.detail) { //for firefox pre version 17
            if (event.axis && ((event.axis === 1 && xaxis) || (event.axis === 2 && !xaxis))) {
                return -1 * event.detail * 12;
            }
        } else if (event.deltaX || event.deltaY) {
            if (xaxis) {
                return -1 * event.deltaX;
            } else {
                return -1 * event.deltaY;
            }
        }
        return 0;
    },

    //binds a cross browser normalized mousewheel event, and returns a function that will unbind the listener;
    bind: function (elem, listener) {
        var normalizedListener = function (e) {
            listener(normalizeWheelEvent(e));
        };

        EVENT_NAMES.forEach(function (name) {
            elem.addEventListener(name, normalizedListener);
        });

        return function () {
            EVENT_NAMES.forEach(function (name) {
                elem.removeEventListener(name, normalizedListener);
            });
        };

    },
    normalize: normalizeWheelEvent
};

function normalizeWheelEvent(e) {
    var deltaX = api.getDelta(e, true);
    var deltaY = api.getDelta(e);
    var newEvent = Object.create(e,
        {
            deltaY: {value: deltaY},
            deltaX: {value: deltaX},
            type: {value: 'mousewheel'}
        });

    newEvent.preventDefault = function () {
        newEvent.defaultPrevented = true;
        if (e && e.preventDefault) {
            e.preventDefault();
        }
    };
    return newEvent;
}

module.exports = api;
},{}],31:[function(require,module,exports){
var key = require('key');
var util = require('../util');
var rangeUtil = require('../range-util');

module.exports = function (_grid) {
    var grid = _grid;

    var model = {
        focus: {
            row: 0,
            col: 0
        }
    };

    var focusClass = grid.cellClasses.create(0, 0, 'focus');
    grid.cellClasses.add(focusClass);

    model.focusDecorator = grid.decorators.create(0, 0, 1, 1);
    model.focusDecorator.render = function () {
        var div = defaultRender();
        div.setAttribute('class', 'grid-focus-decorator');
        return div;
    };
    grid.decorators.add(model.focusDecorator);


    function clampRowToMinMax(row) {
        return util.clamp(row, 0, grid.rowModel.length() - 1);
    }

    function clampColToMinMax(col) {
        return util.clamp(col, 0, grid.colModel.length() - 1);
    }

    model.setFocus = function setFocus(row, col, optionalEvent) {
        row = clampRowToMinMax(row);
        col = clampColToMinMax(col);
        model.focus.row = row;
        model.focus.col = col;
        focusClass.top = row;
        focusClass.left = col;
        model.focusDecorator.top = row;
        model.focusDecorator.left = col;
        grid.cellScrollModel.scrollIntoView(row, col);
        //focus changes always clear the selection
        clearSelection();
    };

    grid.eventLoop.bind('keydown', function (e) {
        var arrow = key.code.arrow;
        if (!key.is(arrow, e.which)) {
            return;
        }
        //focus logic

        if (!e.shiftKey) {
            //if nothing changes great we'll stay where we are
            var navToRow = model.focus.row;
            var navToCol = model.focus.col;


            switch (e.which) {
                case arrow.down.code:
                    navToRow++;
                    break;
                case arrow.up.code:
                    navToRow--;
                    break;
                case arrow.right.code:
                    navToCol++;
                    break;
                case arrow.left.code:
                    navToCol--;
                    break;
            }
            model.setFocus(navToRow, navToCol, e);
        } else {
            //selection logic
            var newSelection;
            //stand in for if it's cleared
            if (model.selection.top === -1) {
                newSelection = {top: model.focus.row, left: model.focus.col, height: 1, width: 1};
            } else {
                newSelection = {
                    top: model.selection.top,
                    left: model.selection.left,
                    height: model.selection.height,
                    width: model.selection.width
                };
            }

            switch (e.which) {
                case arrow.down.code:
                    if (model.focus.row === newSelection.top) {
                        newSelection.height++;
                    } else {
                        newSelection.top++;
                        newSelection.height--;
                    }
                    break;
                case arrow.up.code:
                    if (model.focus.row === newSelection.top + newSelection.height - 1) {
                        newSelection.top--;
                        newSelection.height++;
                    } else {
                        newSelection.height--;

                    }
                    break;
                case arrow.right.code:
                    if (model.focus.col === newSelection.left) {
                        newSelection.width++;
                    } else {
                        newSelection.left++;
                        newSelection.width--;
                    }
                    break;
                case arrow.left.code:
                    if (model.focus.col === newSelection.left + newSelection.width - 1) {
                        newSelection.left--;
                        newSelection.width++;
                    } else {
                        newSelection.width--;
                    }
                    break;
            }
            if (newSelection.height === 1 && newSelection.width === 1) {
                clearSelection();
            } else {
                model.setSelection(newSelection);
            }

        }
    });

    function outsideMinMax(row, col) {
        return row < 0 || row > grid.rowModel.length() || col < 0 || col > grid.colModel.length();
    }

    grid.eventLoop.bind('mousedown', function (e) {
        //assume the event has been annotated by the cell mouse model interceptor
        var row = e.row;
        var col = e.col;
        if (row < 0 && col >= 0) {
            grid.colModel.toggleSelect(col);
        }
        if (col < 0 && row >= 0) {
            grid.rowModel.toggleSelect(row);
        }

        if (row < 0 && col < 0) {
            return;
        }

        if (!e.shiftKey) {
            model.setFocus(row, col, e);
        } else {
            setSelectionFromPoints(model.focus.row, model.focus.col, row, col);
        }

    });

    model._rowSelectionClasses = [];
    model._colSelectionClasses = [];
    //row col selection
    function handleRowColSelectionChange(rowOrCol) {
        var decoratorsField = ('_' + rowOrCol + 'SelectionClasses');
        model[decoratorsField].forEach(function (selectionDecorator) {
            grid.cellClasses.remove(selectionDecorator);
        });
        model[decoratorsField] = [];

        grid[rowOrCol + 'Model'].getSelected().forEach(function (index) {
            var virtualIndex = grid[rowOrCol + 'Model'].toVirtual(index);
            var top = rowOrCol === 'row' ? virtualIndex : 0;
            var left = rowOrCol === 'col' ? virtualIndex : 0;
            var decorator = grid.cellClasses.create(top, left, 'selected', 1, 1, 'virtual');
            grid.cellClasses.add(decorator);
            model[decoratorsField].push(decorator);
        });
    }

    grid.eventLoop.bind('grid-row-selection-change', function () {
        handleRowColSelectionChange('row');
    });

    grid.eventLoop.bind('grid-col-selection-change', function () {
        handleRowColSelectionChange('col');
    });

    var selection = grid.decorators.create();

    var defaultRender = selection.render;
    selection.render = function () {
        var div = defaultRender();
        div.setAttribute('class', 'grid-selection');
        return div;
    };

    grid.decorators.add(selection);

    model.setSelection = function setSelection(newSelection) {
        selection.top = newSelection.top;
        selection.left = newSelection.left;
        selection.height = newSelection.height;
        selection.width = newSelection.width;
    };

    function clearSelection() {
        model.setSelection({top: -1, left: -1, height: -1, width: -1});
    }

    function setSelectionFromPoints(fromRow, fromCol, toRow, toCol) {
        var newSelection = rangeUtil.createFromPoints(fromRow, fromCol, clampRowToMinMax(toRow), clampColToMinMax(toCol));
        model.setSelection(newSelection);
    }

    selection._onDragStart = function (e) {
        if (outsideMinMax(e.row, e.col)) {
            return;
        }
        var fromRow = model.focus.row;
        var fromCol = model.focus.col;
        var unbindDrag = grid.eventLoop.bind('grid-cell-drag', function (e) {
            setSelectionFromPoints(fromRow, fromCol, e.row, e.col);
        });

        var unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function () {
            unbindDrag();
            unbindDragEnd();
        });
    };

    grid.eventLoop.bind('grid-drag-start', selection._onDragStart);
    clearSelection();

    model.selection = selection;

    return model;
};
},{"../range-util":36,"../util":41,"key":9}],32:[function(require,module,exports){
module.exports = function () {
    //a noop function to use
};
},{}],33:[function(require,module,exports){
module.exports = function () {
    return arguments[0];
};
},{}],34:[function(require,module,exports){
var util = require('../util');
var debounce = require('../debounce');
var capitalize = require('capitalize');

module.exports = function (_grid) {
    var grid = _grid;
    var model = {top: 0, left: 0, maxScroll: {}};
    var scrollBarWidth = 10;

    grid.eventLoop.bind('grid-virtual-pixel-cell-change', function () {
        var scrollHeight = grid.virtualPixelCellModel.totalHeight() - grid.virtualPixelCellModel.fixedHeight();
        var scrollWidth = grid.virtualPixelCellModel.totalWidth() - grid.virtualPixelCellModel.fixedWidth();
        model.setScrollSize(scrollHeight, scrollWidth);
        cacheMaxScroll();
        sizeScrollBars();
    });


    grid.eventLoop.bind('grid-viewport-change', function () {
        cacheMaxScroll();
        sizeScrollBars();
    });

    function cacheMaxScroll() {
        model.maxScroll.height = getMaxScroll('height');
        model.maxScroll.width = getMaxScroll('width');
    }

    //assumes a standardized wheel event that we create through the mousewheel package
    grid.eventLoop.bind('mousewheel', function handleMouseWheel(e) {
        var deltaY = e.deltaY;
        var deltaX = e.deltaX;
        model.scrollTo(model.top - deltaY, model.left - deltaX, true);
        debouncedNotify();
        e.preventDefault();
    });

    model.setScrollSize = function (h, w) {
        model.height = h;
        model.width = w;
    };

    function notifyListeners() {
        //TODO: possibly keep track of delta since last update and send it along. for now, no
        grid.eventLoop.fire('grid-pixel-scroll');

        //update the cell scroll
        var scrollTop = model.top;
        var row = grid.virtualPixelCellModel.getRow(scrollTop + grid.virtualPixelCellModel.fixedHeight()) - grid.rowModel.numFixed();

        var scrollLeft = model.left;
        var col = grid.virtualPixelCellModel.getCol(scrollLeft + grid.virtualPixelCellModel.fixedWidth()) - grid.colModel.numFixed();

        grid.cellScrollModel.scrollTo(row, col, undefined, true);
    }

    var debouncedNotify = debounce(notifyListeners, 1);

    model.scrollTo = function (top, left, dontNotify) {
        model.top = util.clamp(top, 0, model.maxScroll.height);
        model.left = util.clamp(left, 0, model.maxScroll.width);
        positionScrollBars();

        if (!dontNotify) {
            notifyListeners();
        }


    };


    /* SCROLL BAR LOGIC */
    function getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz) {
        var scrollBarTopClick = scrollBarRealClickCoord - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
        var scrollRatio = scrollBarTopClick / getMaxScrollBarCoord(heightWidth, vertHorz);
        var scrollCoord = scrollRatio * model.maxScroll[heightWidth];
        return scrollCoord;
    }

    function makeScrollBarDecorator(isHorz) {
        var decorator = grid.decorators.create();
        var xOrY = isHorz ? 'X' : 'Y';
        var heightWidth = isHorz ? 'width' : 'height';
        var vertHorz = isHorz ? 'horz' : 'vert';
        var gridCoordField = 'grid' + xOrY;
        var layerCoordField = 'layer' + xOrY;
        var viewPortClampFn = grid.viewPort['clamp' + xOrY];

        decorator.postRender = function (scrollBarElem) {
            scrollBarElem.setAttribute('class', 'grid-scroll-bar');
            decorator._onDragStart = function (e) {
                if (e.target !== scrollBarElem) {
                    return;
                }
                var scrollBarOffset = e[layerCoordField];

                decorator._unbindDrag = grid.eventLoop.bind('grid-drag', function (e) {
                    var gridCoord = viewPortClampFn(e[gridCoordField]);
                    var scrollBarRealClickCoord = gridCoord - scrollBarOffset;
                    var scrollCoord = getScrollPositionFromReal(scrollBarRealClickCoord, heightWidth, vertHorz);
                    if (isHorz) {
                        model.scrollTo(model.top, scrollCoord);
                    } else {
                        model.scrollTo(scrollCoord, model.left);
                    }
                });

                decorator._unbindDragEnd = grid.eventLoop.bind('grid-drag-end', function (e) {
                    decorator._unbindDrag();
                    decorator._unbindDragEnd();
                });

                e.stopPropagation();
            };

            grid.eventLoop.bind('grid-drag-start', scrollBarElem, decorator._onDragStart);
            grid.eventLoop.bind('mousedown', scrollBarElem, function (e) {
                grid.eventLoop.stopBubbling(e);
            });

            return scrollBarElem;
        };

        decorator.units = 'px';
        decorator.space = 'real';

        return decorator;
    }

    model.vertScrollBar = makeScrollBarDecorator();
    model.horzScrollBar = makeScrollBarDecorator(true);
    model.vertScrollBar.width = scrollBarWidth;
    model.horzScrollBar.height = scrollBarWidth;

    function getMaxScroll(heightWidth) {
        var rowOrCol = heightWidth === 'height' ? 'row' : 'col';
        var scrollLength = model[heightWidth];
        var viewScrollHeightOrWidth = getViewScrollHeightOrWidth(heightWidth);
        var firstScrollableCell = grid[rowOrCol + 'Model'].numFixed();
        while (scrollLength > viewScrollHeightOrWidth - 10) {
            scrollLength -= grid.virtualPixelCellModel[heightWidth](firstScrollableCell);
            firstScrollableCell++;
        }
        return model[heightWidth] - scrollLength;
    }

    model._getMaxScroll = getMaxScroll;

    function getScrollRatioFromVirtualScrollCoords(scroll, heightWidth) {
        var maxScroll = model.maxScroll[heightWidth];
        var scrollRatio = scroll / maxScroll;
        return scrollRatio;
    }

    function getMaxScrollBarCoord(heightWidth, vertHorz) {
        return getViewScrollHeightOrWidth(heightWidth) - model[vertHorz + 'ScrollBar'][heightWidth];
    }

    function getRealScrollBarPosition(scroll, heightWidth, vertHorz) {
        var scrollRatio = getScrollRatioFromVirtualScrollCoords(scroll, heightWidth);
        var maxScrollBarScroll = getMaxScrollBarCoord(heightWidth, vertHorz);
        //in scroll bar coords
        var scrollBarCoord = scrollRatio * maxScrollBarScroll;
        //add the fixed height to translate back into real coords
        return scrollBarCoord + grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
    }

    model._getRealScrollBarPosition = getRealScrollBarPosition;
    model._getScrollPositionFromReal = getScrollPositionFromReal;

    function calcScrollBarRealTop() {
        return getRealScrollBarPosition(model.top, 'height', 'vert');
    }

    function calcScrollBarRealLeft() {
        return getRealScrollBarPosition(model.left, 'width', 'horz');
    }

    function positionScrollBars() {
        model.vertScrollBar.top = calcScrollBarRealTop();
        model.horzScrollBar.left = calcScrollBarRealLeft();
    }

    function getViewScrollHeightOrWidth(heightWidth) {
        return grid.viewPort[heightWidth] - grid.virtualPixelCellModel['fixed' + capitalize(heightWidth)]();
    }

    function getScrollableViewWidth() {
        return getViewScrollHeightOrWidth('width');
    }

    function getScrollableViewHeight() {
        return getViewScrollHeightOrWidth('height');
    }

    function sizeScrollBars() {
        model.vertScrollBar.left = grid.viewPort.width - scrollBarWidth;
        model.horzScrollBar.top = grid.viewPort.height - scrollBarWidth;
        var scrollableViewHeight = getScrollableViewHeight();
        var scrollableViewWidth = getScrollableViewWidth();
        model.vertScrollBar.height = Math.max(scrollableViewHeight / grid.virtualPixelCellModel.totalHeight() * scrollableViewHeight, 20);
        model.horzScrollBar.width = Math.max(scrollableViewWidth / grid.virtualPixelCellModel.totalWidth() * scrollableViewWidth, 20);
        positionScrollBars();
    }

    grid.decorators.add(model.vertScrollBar);
    grid.decorators.add(model.horzScrollBar);
    /* END SCROLL BAR LOGIC */

    return model;
};
},{"../debounce":24,"../util":41,"capitalize":2}],35:[function(require,module,exports){
var addDirtyProps = require('../add-dirty-props');
module.exports = function (range, dirtyClean, parentDirtyClean) {
    range = range || {}; //allow mixin functionality
    range.isDirty = dirtyClean.isDirty;

    var watchedProperties = ['top', 'left', 'height', 'width', 'units', 'space'];
    var dirtyCleans = [dirtyClean];
    if (parentDirtyClean) {
        dirtyCleans.push(parentDirtyClean);
    }

    addDirtyProps(range, watchedProperties, dirtyCleans);
    //defaults
    range.units = 'cell';
    range.space = 'data';

    return range;
};
},{"../add-dirty-props":12}],36:[function(require,module,exports){
module.exports = {
    //takes a point and a length as the ranges in array form
    intersect: function (range1, range2) {
        var range2Start = range2[0];
        var range1Start = range1[0];
        var range1End = range1Start + range1[1] - 1;
        var range2End = range2Start + range2[1] - 1;
        if (range2Start > range1End || range2End < range1Start) {
            return null;
        }
        var resultStart = (range1Start > range2Start ? range1Start : range2Start);
        var resultEnd = (range1End < range2End ? range1End : range2End);
        return [
            resultStart,
            resultEnd - resultStart + 1
        ];
    },
    //takes a point and a length as the ranges in array form
    union: function (range1, range2) {
        if (!range1) {
            return range2;
        }
        if (!range2) {
            return range1;
        }
        var range2Start = range2[0];
        var range2End = range2Start + range2[1] - 1;
        var range1Start = range1[0];
        var range1End = range1Start + range1[1] - 1;
        var resultStart = (range1Start < range2Start ? range1Start : range2Start);
        return [
            resultStart,
            (range1End > range2End ? range1End : range2End) - resultStart + 1
        ];
    },

    //takes two row, col points and creates a normal position range
    createFromPoints: function (r1, c1, r2, c2) {
        var range = {};
        if (r1 < r2) {
            range.top = r1;
            range.height = r2 - r1 + 1;
        } else {
            range.top = r2;
            range.height = r1 - r2 + 1;
        }

        if (c1 < c2) {
            range.left = c1;
            range.width = c2 - c1 + 1;
        } else {
            range.left = c2;
            range.width = c1 - c2 + 1;
        }
        return range;
    },
    iterate: function (range) {
        var cellFn;
        var rowFn;
        if (arguments.length === 2) {
            cellFn = arguments[1];
        } else if (arguments.length === 3) {
            cellFn = arguments[2];
            rowFn = arguments[1];
        }
        for (var r = range.top; r < range.top + range.height; r++) {
            var rowResult;
            if (rowFn) {
                rowResult = rowFn(r);
            }
            for (var c = range.left; c < range.left + range.width; c++) {
                if (cellFn) {
                    cellFn(r, c, rowResult);
                }
            }
        }
    }
};


},{}],37:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = require('../abstract-row-col-model')(grid, 'row', 'height', 30);

    return api;
};
},{"../abstract-row-col-model":11}],38:[function(require,module,exports){
module.exports = function (_grid) {
    var grid = _grid;

    var api = {_decorators: {}};

    function setColShowing(col) {
        grid.colModel.get(col).hidden = false;
    }

    function doWhileHidden(col, fn) {
        while (grid.colModel.get(col - 1).hidden) {
            col--;
            fn && fn(col);
        }
        return col;
    }

    function createDecorator(col, right) {
        var headerDecorator = grid.decorators.create(0, col, 1, 1, 'cell', 'virtual');

        headerDecorator.postRender = function (div) {

            if (right) {
                div.style.transform = 'translate(50%, -50%)';
                div.style.webkitTransform = 'translate(50%, -50%)';
                div.style.removeProperty('left');
            } else {
                div.style.transform = 'translate(-50%, -50%)';
                div.style.webkitTransform = 'translate(-50%, -50%)';
                div.style.removeProperty('right');
            }
            div.style.removeProperty('bottom');
            div.style.top = '50%';
            div.setAttribute('class', 'show-hidden-cols');

            grid.eventLoop.bind('click', div, function () {
                doWhileHidden(col, setColShowing);
            });
        };
        return headerDecorator;
    }

    grid.eventLoop.bind('grid-col-change', function (e) {
        if (e.action === 'hide' || e.action === 'add') {
            e.descriptors.forEach(function (descriptor) {
                var col = descriptor.index;
                if (!col && col !== 0) {
                    return;
                }
                if (descriptor.hidden) {
                    var decCol = col + 1;
                    var rightSide = col === grid.colModel.length(true) - 1;
                    if (rightSide) {
                        //if we're last we actually have to backtrack to the last showing column
                        var lastHiddenCol = doWhileHidden(col);
                        decCol = lastHiddenCol - 1;

                    }
                    var decorator = createDecorator(decCol, rightSide);
                    grid.decorators.add(decorator);
                    api._decorators[col] = decorator;
                } else {
                    var decorator = api._decorators[col];
                    grid.decorators.remove(decorator);
                    api._decorators[col] = undefined;
                }
            });
        }
    });

    return api;
};
},{}],39:[function(require,module,exports){
var util = require('../util');

module.exports = function (_grid) {
    var grid = _grid;

    var cellData = [];
    var headerData = [];
    var sortedCol;
    var ascending;
    var dirtyClean = require('../dirty-clean')(grid);
    var internalSet = function (data, r, c, datum) {
        if (!data[r]) {
            data[r] = [];
        }
        data[r][c] = datum;
        dirtyClean.setDirty();
    };

    var api = {
        isDirty: dirtyClean.isDirty,
        set: function (r, c, datum) {
            var data = arguments[0];
            if (!util.isArray(data)) {
                if (typeof datum === 'string') {
                    datum = {value: datum.replace('[rR]', '').replace('[cC]', '').split(' ')};
                }
                data = [{row: r, col: c, data: datum}];
            }
            data.forEach(function (change) {
                internalSet(cellData, change.row, change.col, change.data);
            });
        },
        setHeader: function (r, c, datum) {
            internalSet(headerData, r, c, datum);
        },
        get: function (r, c) {
            var dataRow = cellData[grid.rowModel.row(r).dataRow];
            var datum = dataRow && dataRow[grid.colModel.col(c).dataCol];
            var value = datum && datum.value;
            if (value === undefined) {
                console.log((value && 'r' + value[0] + ' c' + value[1]) || '');
            }
            return {
                value: value,
                formatted: (value && 'r' + value[0] + ' c' + value[1]) || ''
            };
        },
        getCopyData: function (r, c) {
            return api.get(r, c).formatted;
        },
        getHeader: function (r, c) {
            var dataRow = headerData[grid.rowModel.get(r).dataRow];

            var datum = dataRow && dataRow[grid.colModel.get(c).dataCol];
            var value = datum && datum.value;
            return {
                value: value,
                formatted: value && 'hr' + value[0] + ' hc' + value[1] || ''
            };
        },

        toggleSort: function (c) {
            var retVal = -1;
            var compareMethod = function (val1, val2) {
                return val1 < (val2) ? retVal : -1 * retVal;
            };
            if (c === sortedCol) {
                if (ascending) {
                    retVal = 1;
                }
                ascending = !ascending;
            } else {
                sortedCol = c;
                ascending = true;
            }
            cellData.sort(function (dataRow1, dataRow2) {
                if (!dataRow1 || !dataRow1[c]) {
                    return retVal;
                }
                if (!dataRow2 || !dataRow2[c]) {
                    return retVal * -1;
                }
                return compareMethod(dataRow1[c].value, dataRow2[c].value);
            });
            dirtyClean.setDirty();
        }
    };

    return api;
};
},{"../dirty-clean":26,"../util":41}],40:[function(require,module,exports){
module.exports.stringify = function (data) {
    var string = '';
    data.forEach(function (row, r) {
        row.forEach(function (value, c) {
            if (value.indexOf('\n') !== -1 || value.indexOf('\t') !== -1) {
                //replace " with "" to escape and wrap the whole value in quotes 
                value = '"' + value.replace('"', '""') + '"';
            }
            string += value;
            if (c !== row.length - 1) {
                string += '\t'
            }
        });
        if (r !== data.length - 1) {
            string += '\n';
        }

    });
    return string;
};

// ref: http://stackoverflow.com/a/1293163/2343
// This will parse a delimited string into an array of
// arrays. The default delimiter is the comma, but this
// can be overriden in the second argument.
function DSVToArray(strData, strDelimiter) {
    // Check to see if the delimiter is defined. If not,
    // then default to comma.
    strDelimiter = (strDelimiter || ",");

    // Create a regular expression to parse the CSV values.
    var objPattern = new RegExp(
        (
            // Delimiters.
        "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

            // Quoted fields.
        "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

            // Standard fields.
        "([^\"\\" + strDelimiter + "\\r\\n]*))"
        ),
        "gi"
    );


    // Create an array to hold our data. Give the array
    // a default empty first row.
    var arrData = [[]];

    // Create an array to hold our individual pattern
    // matching groups.
    var arrMatches = null;


    // Keep looping over the regular expression matches
    // until we can no longer find a match.
    while (arrMatches = objPattern.exec(strData)) {

        // Get the delimiter that was found.
        var strMatchedDelimiter = arrMatches[1];

        // Check to see if the given delimiter has a length
        // (is not the start of string) and if it matches
        // field delimiter. If id does not, then we know
        // that this delimiter is a row delimiter.
        if (
            strMatchedDelimiter.length &&
            strMatchedDelimiter !== strDelimiter
        ) {

            // Since we have reached a new row of data,
            // add an empty row to our data array.
            arrData.push([]);

        }

        var strMatchedValue;

        // Now that we have our delimiter out of the way,
        // let's check to see which kind of value we
        // captured (quoted or unquoted).
        if (arrMatches[2]) {

            // We found a quoted value. When we capture
            // this value, unescape any double quotes.
            strMatchedValue = arrMatches[2].replace(
                new RegExp("\"\"", "g"),
                "\""
            );

        } else {

            // We found a non-quoted value.
            strMatchedValue = arrMatches[3];

        }


        // Now that we have our value string, let's add
        // it to the data array.
        arrData[arrData.length - 1].push(strMatchedValue);
    }

    // Return the parsed data.
    return ( arrData );
}


module.exports.parse = function (string) {
    return DSVToArray(string, '\t');
};
},{}],41:[function(require,module,exports){
module.exports = {
    clamp: function (num, min, max, returnNaN) {
        if (num > max) {
            return returnNaN ? NaN : max;
        }
        if (num < min) {
            return returnNaN ? NaN : min;
        }
        return num;
    },
    isNumber: function (number) {
        return typeof number === 'number' && !isNaN(number);
    },
    isElement: function (node) {
        return !!(node &&
        (node.nodeName || // we are a direct element
        (node.prop && node.attr && node.find)));  // we have an on and find method part of jquery API
    },
    isArray: function (value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },
    position: function (elem, t, l, b, r) {
        elem.style.top = t + 'px';
        elem.style.left = l + 'px';
        elem.style.bottom = b + 'px';
        elem.style.right = r + 'px';
        elem.style.position = 'absolute';

    }
};
},{}],42:[function(require,module,exports){
var customEvent = require('../custom-event');
var debounce = require('../debounce');
var util = require('../util');


module.exports = function (_grid) {
    var viewLayer = {};


    var grid = _grid;
    var container;
    var root;
    var cellContainer;
    var decoratorContainer;
    var borderWidth;

    var GRID_CELL_CONTAINER_BASE_CLASS = 'grid-cells';
    var GRID_VIEW_ROOT_CLASS = 'js-grid-view-root';
    var CELL_CLASS = 'grid-cell';

    var cells; //matrix of rendered cell elements;
    var rows; //array of all rendered rows
    var builtCols; //map from col index to an array of built elements for the column to update on scroll
    var builtRows; //map from row index to an array of built elements for the row to update on scroll

    //add the cell classes through the standard method
    grid.cellClasses.add(grid.cellClasses.create(0, 0, CELL_CLASS, Infinity, Infinity, 'virtual'));

    var rowHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-row-header', Infinity, 0, 'virtual');
    var colHeaderClasses = grid.cellClasses.create(0, 0, 'grid-header grid-col-header', 0, Infinity, 'virtual');
    var fixedColClasses = grid.cellClasses.create(0, -1, 'grid-last-fixed-col', Infinity, 1, 'virtual');
    var fixedRowClasses = grid.cellClasses.create(-1, 0, 'grid-last-fixed-row', 1, Infinity, 'virtual');

    grid.cellClasses.add(rowHeaderClasses);
    grid.cellClasses.add(colHeaderClasses);
    grid.cellClasses.add(fixedRowClasses);
    grid.cellClasses.add(fixedColClasses);


    grid.eventLoop.bind('grid-col-change', function () {
        fixedColClasses.left = grid.colModel.numFixed() - 1;
        rowHeaderClasses.width = grid.colModel.numHeaders();
    });

    grid.eventLoop.bind('grid-row-change', function () {
        fixedRowClasses.top = grid.rowModel.numFixed() - 1;
        colHeaderClasses.height = grid.rowModel.numHeaders();
    });


    viewLayer.build = function (elem) {
        cleanup();

        container = elem;

        cellContainer = document.createElement('div');
        cellContainer.setAttribute('dts', 'grid-cells');
        cellContainer.setAttribute('class', GRID_CELL_CONTAINER_BASE_CLASS);
        util.position(cellContainer, 0, 0, 0, 0);
        cellContainer.style.zIndex = 0;

        decoratorContainer = document.createElement('div');
        decoratorContainer.setAttribute('dts', 'grid-decorators');
        util.position(decoratorContainer, 0, 0, 0, 0);
        decoratorContainer.style.zIndex = 0;
        decoratorContainer.style.pointerEvents = 'none';

        root = document.createElement('div');
        root.setAttribute('class', GRID_VIEW_ROOT_CLASS);

        root.appendChild(cellContainer);
        root.appendChild(decoratorContainer);

        container.appendChild(root);

    };


    function measureBorderWidth() {
        //read the border width, for the rare case of larger than 1px borders, otherwise the draw will default to 1
        if (borderWidth) {
            return;
        }
        var jsGridCell = cells[0] && cells[0][0];
        if (jsGridCell) {
            var oldClass = jsGridCell.className;
            jsGridCell.className = CELL_CLASS;
            var computedStyle = getComputedStyle(jsGridCell);
            var borderWidthProp = computedStyle.getPropertyValue('border-left-width');
            borderWidth = parseInt(borderWidthProp);
            jsGridCell.className = oldClass;
        }
        borderWidth = isNaN(borderWidth) || !borderWidth ? undefined : borderWidth;
        return borderWidth;
    }

    //only draw once per js turn, may need to create a synchronous version
    viewLayer.draw = debounce(function () {
        viewLayer._draw();
    }, 1);

    viewLayer._draw = function () {
        //return if we haven't built yet
        if (!container) {
            return;
        }

        var rebuilt = grid.viewPort.isDirty();
        if (rebuilt) {
            viewLayer._buildCells(cellContainer);
        }

        var builtColsDirty = grid.colModel.areBuildersDirty();
        if (rebuilt || builtColsDirty) {
            viewLayer._buildCols();
        }

        var builtRowsDirty = grid.rowModel.areBuildersDirty();
        if (rebuilt || builtRowsDirty) {
            viewLayer._buildRows();
        }

        var cellsPositionOrSizeChanged = grid.colModel.isDirty() || grid.rowModel.isDirty() || grid.cellScrollModel.isDirty();

        if (grid.cellClasses.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawCellClasses();
        }

        if (rebuilt || cellsPositionOrSizeChanged || builtColsDirty || builtRowsDirty || grid.dataModel.isDirty()) {
            viewLayer._drawCells();
        }

        if (grid.decorators.isDirty() || rebuilt || cellsPositionOrSizeChanged) {
            viewLayer._drawDecorators(cellsPositionOrSizeChanged);
        }

        grid.eventLoop.fire('grid-draw');
    };

    /* CELL LOGIC */
    function getBorderWidth() {
        return borderWidth || 1;
    }

    viewLayer._drawCells = function () {
        measureBorderWidth();
        var bWidth = getBorderWidth();
        var headerRows = grid.rowModel.numHeaders();
        var headerCols = grid.colModel.numHeaders();
        var totalVisibleCellWidth = 0;
        var lastVirtualCol;
        grid.viewPort.iterateCells(function drawCell(r, c) {
            var cell = cells[r][c];
            var width = grid.viewPort.getColWidth(c);
            var virtualCol = grid.viewPort.toVirtualCol(c);
            //if we got the same vCol we've been clamped and its time to hide this cell
            //also hide the cell if its width is zero cause ya...
            if (width == 0 || virtualCol === lastVirtualCol) {
                cell.style.display = 'none';
                return;
            }
            if (r === 0) {
                //calculate width for rows later but only do it one time (so on the first row)
                totalVisibleCellWidth += width;
            }

            lastVirtualCol = virtualCol;
            cell.style.display = '';
            cell.style.width = width + bWidth + 'px';

            var left = grid.viewPort.getColLeft(c);

            cell.style.left = left + 'px';

            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            var virtualRow = grid.viewPort.toVirtualRow(r);

            var data;
            if (r < headerRows || c < headerCols) {
                data = grid.dataModel.getHeader(virtualRow, virtualCol);
            } else {
                data = grid.dataModel.get(grid.rowModel.toData(virtualRow), grid.colModel.toData(virtualCol));
            }
            //artificially only get builders for row headers for now
            var builder = virtualRow < headerRows && grid.rowModel.get(virtualRow).builder || undefined;
            var hasRowBuilder = true;
            if (!builder) {
                hasRowBuilder = false;
                builder = grid.colModel.get(virtualCol).builder;
            }

            var cellChild;
            if (builder) {
                var builtElem;
                if (hasRowBuilder) {
                    builtElem = builtRows[virtualRow][c];
                } else {
                    builtElem = builtCols[virtualCol][r];
                }
                cellChild = builder.update(builtElem, {
                    virtualCol: virtualCol,
                    virtualRow: virtualRow,
                    data: data
                });
            }
            //if we didn't get a child from the builder use a regular text node
            if (!cellChild) {
                cellChild = document.createTextNode(data.formatted);
            }
            cell.appendChild(cellChild);
        }, function drawRow(r) {
            var height = grid.viewPort.getRowHeight(r);
            var row = rows[r];
            if (height == 0) {
                row.style.display = 'none';
                return;
            }
            row.style.display = '';
            row.style.height = height + bWidth + 'px';
            var top = grid.viewPort.getRowTop(r);
            row.style.top = top + 'px';
        });

        rows.forEach(function (row) {
            row.style.width = totalVisibleCellWidth + 'px';
        });

        if (grid.cellScrollModel.row % 2) {
            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS + ' odds';
        } else {
            cellContainer.className = GRID_CELL_CONTAINER_BASE_CLASS;
        }
    };


    viewLayer._buildCells = function buildCells(cellContainer) {
        while (cellContainer.firstChild) {
            cellContainer.removeChild(cellContainer.firstChild);
        }


        cells = [];
        rows = [];
        var row;
        grid.viewPort.iterateCells(function (r, c) {
            var cell = buildDivCell();
            cells[r][c] = cell;
            row.appendChild(cell);
        }, function (r) {
            cells[r] = [];
            row = document.createElement('div');
            row.setAttribute('class', 'grid-row');
            row.setAttribute('dts', 'grid-row');
            row.style.position = 'absolute';
            row.style.left = 0;
            rows[r] = row;
            cellContainer.appendChild(row);
        });
    };

    function buildDivCell() {
        var cell = document.createElement('div');
        cell.setAttribute('dts', 'grid-cell');
        var style = cell.style;
        style.position = 'absolute';
        style.boxSizing = 'border-box';
        style.top = '0px';
        style.bottom = '0px';
        return cell;
    }

    /* END CELL LOGIC */

    /* COL BUILDER LOGIC */
    viewLayer._buildCols = function () {
        builtCols = {};
        for (var c = 0; c < grid.colModel.length(true); c++) {
            var builder = grid.colModel.get(c).builder;
            if (builder) {
                builtCols[c] = [];
                for (var realRow = 0; realRow < grid.viewPort.rows; realRow++) {
                    builtCols[c][realRow] = builder.render();
                }
            }
        }
    };
    /* END COL BUILDER LOGIC */

    /* ROW BUILDER LOGIC 
     *  for now we only build headers
     * */

    viewLayer._buildRows = function () {
        builtRows = {};
        for (var r = 0; r < grid.rowModel.numHeaders(); r++) {
            var builder = grid.rowModel.get(r).builder;
            if (builder) {
                builtRows[r] = [];
                for (var realCol = 0; realCol < grid.viewPort.cols; realCol++) {
                    builtRows[r][realCol] = builder.render();
                }
            }
        }
    };
    /* END ROW BUILDER LOGIC*/

    /* DECORATOR LOGIC */
    function setPosition(boundingBox, top, left, height, width) {
        var style = boundingBox.style;
        if (height <= 0 || width <= 0) {
            style.display = 'none';
            return;
        }
        style.display = ''
        style.top = top + 'px';
        style.left = left + 'px';
        style.height = height + 'px';
        style.width = width + 'px';
        style.position = 'absolute';
    }

    function positionDecorator(bounding, t, l, h, w) {
        setPosition(bounding, t, l, util.clamp(h, 0, grid.viewPort.height), util.clamp(w, 0, grid.viewPort.width));
    }

    function positionCellDecoratorFromViewCellRange(realCellRange, boundingBox) {
        var realPxRange = grid.viewPort.toPx(realCellRange);
        positionDecorator(boundingBox, realPxRange.top, realPxRange.left, realPxRange.height && realPxRange.height + getBorderWidth(), realPxRange.width && realPxRange.width + getBorderWidth());
    }

    function createRangeForDescriptor(descriptor) {
        var range = {
            top: descriptor.top,
            left: descriptor.left,
            height: descriptor.height,
            width: descriptor.width
        };
        if (descriptor.space === 'data' && descriptor.units === 'cell') {
            range.top += grid.rowModel.numHeaders();
            range.left += grid.colModel.numHeaders();
        }
        return range;
    }

    viewLayer._drawDecorators = function (cellsPositionOrSizeChanged) {
        var aliveDecorators = grid.decorators.getAlive();
        aliveDecorators.forEach(function (decorator) {

            var boundingBox = decorator.boundingBox;
            if (!boundingBox) {
                boundingBox = document.createElement('div');
                boundingBox.style.pointerEvents = 'none';
                decorator.boundingBox = boundingBox;
                var decElement = decorator.render();
                if (decElement) {
                    boundingBox.appendChild(decElement);
                    decoratorContainer.appendChild(boundingBox);
                }
            }

            if (decorator.isDirty() || cellsPositionOrSizeChanged) {
                if (decorator.space === 'real') {
                    switch (decorator.units) {
                        case 'px':
                            positionDecorator(boundingBox, decorator.top, decorator.left, decorator.height, decorator.width);
                            break;
                        case 'cell':
                            positionCellDecoratorFromViewCellRange(decorator, boundingBox);
                            break;
                    }
                }
                else if (decorator.space === 'virtual' || decorator.space === 'data') {
                    switch (decorator.units) {
                        case 'px':
                            break;
                        case 'cell':
                        /* jshint -W086 */
                        default:
                            var range = createRangeForDescriptor(decorator);
                            var realCellRange = grid.viewPort.intersect(range);
                            if (realCellRange) {
                                positionCellDecoratorFromViewCellRange(realCellRange, boundingBox);
                            } else {
                                positionDecorator(boundingBox, -1, -1, -1, -1);
                            }
                            break;
                        /* jshint +W086 */
                    }

                }
            }
        });

        removeDecorators(grid.decorators.popAllDead());
    };

    function removeDecorators(decorators) {
        decorators.forEach(function (decorator) {
            var boundingBox = decorator.boundingBox;
            if (boundingBox) {
                //if they rendered an element previously we attached it to the bounding box as the only child
                var renderedElement = boundingBox.firstChild;
                if (renderedElement) {
                    //create a destroy dom event that bubbles
                    var destroyEvent = customEvent('decorator-destroy', true);
                    renderedElement.dispatchEvent(destroyEvent);
                }
                decoratorContainer.removeChild(boundingBox);
                decorator.boundingBox = undefined;
            }
        });
    }

    /* END DECORATOR LOGIC */

    /* CELL CLASSES LOGIC */
    viewLayer._drawCellClasses = function () {
        grid.viewPort.iterateCells(function (r, c) {
            cells[r][c].className = '';
        });
        grid.cellClasses.getAll().forEach(function (descriptor) {
            var range = createRangeForDescriptor(descriptor);
            var intersection = grid.viewPort.intersect(range);
            if (intersection) {
                rowLoop:
                    for (var r = 0; r < intersection.height; r++) {
                        for (var c = 0; c < intersection.width; c++) {
                            var row = intersection.top + r;
                            var col = intersection.left + c;

                            var cellRow = cells[row];
                            if (!cellRow) {
                                continue rowLoop;
                            }
                            var cell = cellRow[col];
                            if (!cell) {
                                continue;
                            }
                            cell.className = (cell.className ? cell.className + ' ' : '') + descriptor.class;
                        }
                    }
            }
        });
    };

    /* END CELL CLASSES LOGIC*/

    viewLayer.destroy = cleanup;

    function cleanup() {
        removeDecorators(grid.decorators.getAlive().concat(grid.decorators.popAllDead()));
        if (!container) {
            return;
        }
        var querySelectorAll = container.querySelectorAll('.' + GRID_VIEW_ROOT_CLASS);
        for (var i = 0; i < querySelectorAll.length; ++i) {
            var root = querySelectorAll[i];
            container.removeChild(root);
        }
    }

    grid.eventLoop.bind('grid-destroy', function () {
        viewLayer.destroy();
        clearTimeout(viewLayer.draw.timeout);
    });

    return viewLayer;
};
},{"../custom-event":23,"../debounce":24,"../util":41}],43:[function(require,module,exports){
var util = require('../util');
var rangeUtil = require('../range-util');
var capitalize = require('capitalize');
var addDirtyProps = require('../add-dirty-props');
var debounce = require('../debounce');

module.exports = function (_grid) {
    var grid = _grid;
    var dirtyClean = require('../dirty-clean')(grid);
    var container;

    var viewPort = addDirtyProps({}, ['rows', 'cols', 'width', 'height'], [dirtyClean]);
    viewPort.rows = 0;
    viewPort.cols = 0;
    viewPort.isDirty = dirtyClean.isDirty;

    //these probably trigger reflow so we may need to think about caching the value and updating it at on draws or something
    function getFirstClientRect() {
        return container && container.getClientRects && container.getClientRects() && container.getClientRects()[0] || {};
    }

    Object.defineProperty(viewPort, 'top', {
        enumerable: true,
        get: function () {
            return getFirstClientRect().top || 0;
        }
    });

    Object.defineProperty(viewPort, 'left', {
        enumerable: true,
        get: function () {
            return getFirstClientRect().left || 0;
        }
    });

    viewPort.toGridX = function (clientX) {
        return clientX - viewPort.left;
    };

    viewPort.toGridY = function (clientY) {
        return clientY - viewPort.top;
    };


    var fixed = {rows: 0, cols: 0};

    function getFixed(rowOrCol) {
        return fixed[rowOrCol + 's'];
    }

    viewPort.sizeToContainer = function (elem) {
        container = elem;
        viewPort.width = elem.offsetWidth;
        viewPort.height = elem.offsetHeight;
        viewPort.rows = calculateMaxLengths(viewPort.height, grid.rowModel);
        viewPort.cols = calculateMaxLengths(viewPort.width, grid.colModel);
        grid.eventLoop.fire('grid-viewport-change');
    };

    viewPort._onResize = debounce(function () {
        viewPort._resize();
    }, 200);

    grid.eventLoop.bind('grid-destroy', function () {
        clearTimeout(viewPort._onResize.timeout);
        clearTimeout(shortDebouncedResize.timeout);
    });

    viewPort._resize = function () {
        if (container) {
            viewPort.sizeToContainer(container);
        }
    };

    var shortDebouncedResize = debounce(function () {
        viewPort._resize();
    }, 1);

    viewPort.shortDebouncedResize = shortDebouncedResize;


    grid.eventLoop.bind('resize', window, function () {
        //we don't bind the handler directly so that tests can mock it out
        viewPort._onResize();
    });

    grid.eventLoop.bind('grid-row-change', function () {
        fixed.rows = grid.rowModel.numFixed();
        shortDebouncedResize();
    });

    grid.eventLoop.bind('grid-col-change', function () {
        fixed.cols = grid.colModel.numFixed();
        shortDebouncedResize();
    });

    function convertRealToVirtual(coord, rowOrCol, coordIsVirtual) {
        //could cache this on changes i.e. row-change or col-change events
        var numFixed = getFixed(rowOrCol);
        if (coord < numFixed) {
            return coord;
        }
        return coord + (coordIsVirtual ? -1 : 1) * grid.cellScrollModel[rowOrCol];
    }

// converts a viewport row or column to a real row or column 
// clamps it if the column would be outside the range
    function getVirtualRowColUnsafe(realCoord, rowOrCol) {
        return convertRealToVirtual(realCoord, rowOrCol);
    }

    function getVirtualRowColClamped(viewCoord, rowOrCol) {
        var virtualRowCol = getVirtualRowColUnsafe(viewCoord, rowOrCol);
        return grid.virtualPixelCellModel['clamp' + capitalize(rowOrCol)](virtualRowCol);
    }

    viewPort.toVirtualRow = function (r) {
        return getVirtualRowColClamped(r, 'row');
    };

    viewPort.toVirtualCol = function (c) {
        return getVirtualRowColClamped(c, 'col');
    };

    function getRealRowColClamped(virtualCoord, rowOrCol) {
        var numFixed = getFixed(rowOrCol);
        if (virtualCoord < numFixed) {
            return virtualCoord;
        }
        var maxViewPortIndex = viewPort[rowOrCol + 's'] - 1;
        return util.clamp(virtualCoord - grid.cellScrollModel[rowOrCol], numFixed, maxViewPortIndex, true);
    }

    viewPort.rowIsInView = function (virtualRow) {
        var realRow = viewPort.toRealRow(virtualRow);
        return !isNaN(realRow) && getLengthBetweenViewCoords(0, realRow, 'row', 'height', true) < viewPort.height;
    };

    viewPort.colIsInView = function (virtualCol) {
        var realCol = viewPort.toRealCol(virtualCol);
        return !isNaN(realCol) && getLengthBetweenViewCoords(0, realCol, 'col', 'width', true) < viewPort.width;
    };


//default unclamped cause that seems to be the more likely use case converting this direction
    viewPort.toRealRow = function (virtualRow) {
        return getRealRowColClamped(virtualRow, 'row');
    };

    viewPort.toRealCol = function (virtualCol) {
        return getRealRowColClamped(virtualCol, 'col');
    };

    viewPort.clampRow = function (r) {
        return util.clamp(r, 0, viewPort.rows - 1);
    };

    viewPort.clampCol = function (c) {
        return util.clamp(c, 0, viewPort.cols - 1);
    };

    viewPort.clampY = function (y) {
        return util.clamp(y, 0, viewPort.height);
    };

    viewPort.clampX = function (x) {
        return util.clamp(x, 0, viewPort.width);
    };

    function getLengthBetweenViewCoords(startCoord, endCoord, rowOrCol, heightOrWidth, inclusive) {
        var rowOrColCap = capitalize(rowOrCol);
        var toVirtual = viewPort['toVirtual' + rowOrColCap];
        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];
        var clampFn = viewPort['clamp' + rowOrColCap];
        var pos = 0;
        var numFixed = getFixed(rowOrCol);
        var isInNonfixedArea = endCoord >= numFixed;
        var isInFixedArea = startCoord < numFixed;
        var exclusiveOffset = (inclusive ? 0 : 1);
        if (isInFixedArea) {
            var fixedEndCoord = (isInNonfixedArea ? numFixed - 1 : endCoord - exclusiveOffset);
            pos += lengthFn(startCoord, fixedEndCoord);
        }
        if (isInNonfixedArea) {
            pos += lengthFn((isInFixedArea ? toVirtual(numFixed) : toVirtual(startCoord)), toVirtual(clampFn(endCoord)) - exclusiveOffset);
        }
        return pos;
    }

    function getTopOrLeft(endCoord, rowOrCol, heightOrWidth) {
        return getLengthBetweenViewCoords(0, endCoord, rowOrCol, heightOrWidth);
    }

    viewPort.getRowTop = function (viewPortCoord) {
        return getTopOrLeft(viewPortCoord, 'row', 'height');
    };

    viewPort.getColLeft = function (viewPortCol) {
        return getTopOrLeft(viewPortCol, 'col', 'width');
    };

    viewPort.toPx = function (realCellRange) {
        return {
            top: viewPort.getRowTop(realCellRange.top),
            left: viewPort.getColLeft(realCellRange.left),
            height: getLengthBetweenViewCoords(realCellRange.top, realCellRange.top + realCellRange.height - 1, 'row', 'height', true),
            width: getLengthBetweenViewCoords(realCellRange.left, realCellRange.left + realCellRange.width - 1, 'col', 'width', true)
        };
    };

    function getRowOrColFromPosition(pos, rowOrCol, heightOrWidth, returnVirtual) {
        //we could do this slighly faster with binary search to get log(n) instead of n, but will only do it if we actually need to optimize this
        var rowOrColCap = capitalize(rowOrCol);
        var viewMax = viewPort[rowOrCol + 's'];
        var toVirtual = viewPort['toVirtual' + rowOrColCap];
        var lengthFn = grid.virtualPixelCellModel[heightOrWidth];
        var summedLength = 0;
        for (var i = 0; i < viewMax; i++) {
            var virtual = toVirtual(i);
            var length = lengthFn(virtual);
            var newSum = summedLength + length;
            if (newSum > pos) {
                return returnVirtual ? virtual : i;
            }
            summedLength = newSum;
        }
        return NaN;
    }

    viewPort.getVirtualRowByTop = function (top) {
        return getRowOrColFromPosition(top, 'row', 'height', true);
    };

    viewPort.getVirtualColByLeft = function (left) {
        return getRowOrColFromPosition(left, 'col', 'width', true);
    };

    viewPort.getRowByTop = function (top) {
        return getRowOrColFromPosition(top, 'row', 'height');
    };

    viewPort.getColByLeft = function (left) {
        return getRowOrColFromPosition(left, 'col', 'width');
    };

    viewPort.getRowHeight = function (viewPortRow) {
        return grid.virtualPixelCellModel.height(viewPort.toVirtualRow(viewPort.clampRow(viewPortRow)));
    };

    viewPort.getColWidth = function (viewPortCol) {
        return grid.virtualPixelCellModel.width(viewPort.toVirtualCol(viewPort.clampCol(viewPortCol)));
    };

    function intersectRowsOrCols(intersection, range, topOrLeft, rowOrCol, heightOrWidth) {
        var numFixed = fixed[rowOrCol + 's'];
        var fixedRange = [0, numFixed];

        var virtualRange = [range[topOrLeft], range[heightOrWidth]];
        var fixedIntersection = rangeUtil.intersect(fixedRange, virtualRange);
        var scrollRange = [numFixed, viewPort[rowOrCol + 's'] - numFixed];
        virtualRange[0] -= grid.cellScrollModel[rowOrCol];
        var scrollIntersection = rangeUtil.intersect(scrollRange, virtualRange);
        var resultRange = rangeUtil.union(fixedIntersection, scrollIntersection);
        if (!resultRange) {
            return null;
        }

        intersection[topOrLeft] = resultRange[0];
        intersection[heightOrWidth] = resultRange[1];
        return intersection;
    }

    viewPort.intersect = function (range) {
        //assume virtual cells for now
        var intersection = intersectRowsOrCols({}, range, 'top', 'row', 'height');
        if (!intersection) {
            return null;
        }
        return intersectRowsOrCols(intersection, range, 'left', 'col', 'width');
    };


    function calculateMaxLengths(totalLength, lengthModel) {
        var lengthMethod = lengthModel.width && grid.virtualPixelCellModel.width || grid.virtualPixelCellModel.height;
        var numFixed = lengthModel.numFixed();
        var windowLength = 0;
        var maxSize = 0;
        var fixedLength = 0;
        var windowStartIndex = numFixed;

        for (var fixed = 0; fixed < numFixed; fixed++) {
            fixedLength += lengthMethod(fixed);
        }

        //it might be safer to actually sum the lengths in the virtualPixelCellModel but for now here is ok
        for (var index = numFixed; index < lengthModel.length(true); index++) {
            var lengthOfIindex = lengthMethod(index);
            windowLength += lengthOfIindex;
            while (windowLength + fixedLength > totalLength && windowStartIndex < index) {
                windowLength -= lengthMethod(windowStartIndex);
                windowStartIndex++;
            }
            var windowSize = index - windowStartIndex + 1; // add the one because we want the last index that didn't fit
            if (windowSize > maxSize) {
                maxSize = windowSize;
            }

        }
        return maxSize + numFixed + 1;
    }


    viewPort.iterateCells = function (cellFn, optionalRowFn, optionalMaxRow, optionalMaxCol) {
        optionalMaxRow = optionalMaxRow || Infinity;
        optionalMaxCol = optionalMaxCol || Infinity;
        for (var r = 0; r < Math.min(viewPort.rows, optionalMaxRow); r++) {
            if (optionalRowFn) {
                optionalRowFn(r);
            }
            if (cellFn) {
                for (var c = 0; c < Math.min(viewPort.cols, optionalMaxCol); c++) {
                    cellFn(r, c);

                }
            }
        }
    };

    return viewPort;
}
},{"../add-dirty-props":12,"../debounce":24,"../dirty-clean":26,"../range-util":36,"../util":41,"capitalize":2}],44:[function(require,module,exports){
var util = require('../util');

module.exports = function (_grid) {
    var grid = _grid;
    var model = {};

    //all pixels are assumed to be in the virtual world, no real world pixels are dealt with here :)
    model.getRow = function (topPx) {
        if (topPx < 0) {
            return NaN;
        }
        var sumLength = 0;
        for (var r = 0; r < grid.rowModel.length(true); r++) {
            sumLength += grid.rowModel.height(r);
            if (topPx < sumLength) {
                return r;
            }
        }
        return NaN;
    };

    //yes these are very similar but there will be differences
    model.getCol = function (leftPx) {
        if (leftPx < 0) {
            return NaN;
        }
        var sumLength = 0;
        for (var c = 0; c < grid.colModel.length(true); c++) {
            sumLength += grid.colModel.width(c);
            if (leftPx < sumLength) {
                return c;
            }
        }
        return NaN;
    };


    function clampRowOrCol(virtualRowCol, rowOrCol) {
        var maxRowCol = grid[rowOrCol + 'Model'].length(true) - 1;
        return util.clamp(virtualRowCol, 0, maxRowCol);
    }

    model.clampRow = function (virtualRow) {
        return clampRowOrCol(virtualRow, 'row');
    };

    model.clampCol = function (virtualCol) {
        return clampRowOrCol(virtualCol, 'col');
    };

    //for now these just call through to the row and column model, but very likely it will need to include some other calculations
    model.height = function (virtualRowStart, virtualRowEnd) {
        return heightOrWidth(virtualRowStart, virtualRowEnd, 'row');
    };

    model.width = function (virtualColStart, virtualColEnd) {
        return heightOrWidth(virtualColStart, virtualColEnd, 'col');
    };

    function heightOrWidth(start, end, rowOrCol) {
        var length = 0;
        if (end < start) {
            return 0;
        }
        end = util.isNumber(end) ? end : start;
        end = clampRowOrCol(end, rowOrCol);
        start = clampRowOrCol(start, rowOrCol);
        var lengthModel = grid[rowOrCol + 'Model'];
        var lengthFn = lengthModel.width || lengthModel.height;
        for (var i = start; i <= end; i++) {
            length += lengthFn(i);
        }
        return length;
    }

    model.totalHeight = function () {
        return model.height(0, grid.rowModel.length(true) - 1);
    };

    model.totalWidth = function () {
        return model.width(0, grid.colModel.length(true) - 1);
    };

    model.fixedHeight = function () {
        return model.height(0, grid.rowModel.numFixed() - 1);
    };

    model.fixedWidth = function () {
        return model.width(0, grid.colModel.numFixed() - 1);
    };

    function sizeChangeListener() {
        //for now we don't cache anything about this so we just notify
        grid.eventLoop.fire('grid-virtual-pixel-cell-change');
    }

    grid.eventLoop.bind('grid-col-change', sizeChangeListener);
    grid.eventLoop.bind('grid-row-change', sizeChangeListener);

    return model;
};
},{"../util":41}]},{},[1])
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ndWxwLXRhc2tzLXJpcS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwic3JjL21vZHVsZXMvcmlxLWdyaWQtZW50cnkuanMiLCJub2RlX21vZHVsZXMvY2FwaXRhbGl6ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbGVtZW50LWNsYXNzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2tleS9saWIvY29kZS9hbG51bS5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL2NvZGUvYXJyb3cuanMiLCJub2RlX21vZHVsZXMva2V5L2xpYi9jb2RlL2JyYW5kLmpzIiwibm9kZV9tb2R1bGVzL2tleS9saWIvY29kZS9wdW5jdHVhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL2NvZGUvc3BlY2lhbC5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL2tleS5qcyIsIm5vZGVfbW9kdWxlcy9rZXkvbGliL3JlZi5qcyIsInNyYy9tb2R1bGVzL2Fic3RyYWN0LXJvdy1jb2wtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9hZGQtZGlydHktcHJvcHMvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9hbmd1bGFyLWRlY29yYXRvci9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NlbGwtY2xhc3Nlcy9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NlbGwtbW91c2UtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9jZWxsLXNjcm9sbC1tb2RlbC9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NvbC1tb2RlbC9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NvbC1yZW9yZGVyL2luZGV4LmpzIiwic3JjL21vZHVsZXMvY29sLXJlc2l6ZS9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2NvcHktcGFzdGUvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9jb3JlL2luZGV4LmpzIiwic3JjL21vZHVsZXMvY3RybC1vci1jbWQvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9jdXN0b20tZXZlbnQvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2RlY29yYXRvcnMvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9kaXJ0eS1jbGVhbi9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2V2ZW50LWxvb3AvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9oZWFkZXItZGVjb3JhdG9ycy9pbmRleC5qcyIsInNyYy9tb2R1bGVzL2xpc3RlbmVycy9pbmRleC5qcyIsInNyYy9tb2R1bGVzL21vdXNld2hlZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9uYXZpZ2F0aW9uLW1vZGVsL2luZGV4LmpzIiwic3JjL21vZHVsZXMvbm8tb3AvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9wYXNzLXRocm91Z2gvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9waXhlbC1zY3JvbGwtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9wb3NpdGlvbi1yYW5nZS9pbmRleC5qcyIsInNyYy9tb2R1bGVzL3JhbmdlLXV0aWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9yb3ctbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy9zaG93LWhpZGRlbi1jb2xzL2luZGV4LmpzIiwic3JjL21vZHVsZXMvc2ltcGxlLWRhdGEtbW9kZWwvaW5kZXguanMiLCJzcmMvbW9kdWxlcy90c3YvaW5kZXguanMiLCJzcmMvbW9kdWxlcy91dGlsL2luZGV4LmpzIiwic3JjL21vZHVsZXMvdmlldy1sYXllci9pbmRleC5qcyIsInNyYy9tb2R1bGVzL3ZpZXctcG9ydC9pbmRleC5qcyIsInNyYy9tb2R1bGVzL3ZpcnR1YWwtcGl4ZWwtY2VsbC1tb2RlbC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiYW5ndWxhci5tb2R1bGUoJ3JpcS1ncmlkJywgW1xuICByZXF1aXJlKCcuL2FuZ3VsYXItZGVjb3JhdG9yJykubmFtZVxuXSlcbiAgLmZhY3RvcnkoJ1JpcUdyaWRTcnZjJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb3JlOiByZXF1aXJlKCcuL2NvcmUnKVxuICAgIH07XG4gIH0pXG47XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cmluZygxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMud29yZHMgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKF58XFxXKShcXHcpL2csIGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIG0udG9VcHBlckNhc2UoKVxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHJldHVybiBuZXcgRWxlbWVudENsYXNzKG9wdHMpXG59XG5cbmZ1bmN0aW9uIEVsZW1lbnRDbGFzcyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFbGVtZW50Q2xhc3MpKSByZXR1cm4gbmV3IEVsZW1lbnRDbGFzcyhvcHRzKVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICAvLyBzaW1pbGFyIGRvaW5nIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgYnV0IHdvcmtzIGluIElFOFxuICBpZiAob3B0cy5ub2RlVHlwZSkgb3B0cyA9IHtlbDogb3B0c31cblxuICB0aGlzLm9wdHMgPSBvcHRzXG4gIHRoaXMuZWwgPSBvcHRzLmVsIHx8IGRvY3VtZW50LmJvZHlcbiAgaWYgKHR5cGVvZiB0aGlzLmVsICE9PSAnb2JqZWN0JykgdGhpcy5lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5lbClcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgaWYgKGVsLmNsYXNzTmFtZSA9PT0gXCJcIikgcmV0dXJuIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgnICcpXG4gIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xKSByZXR1cm4gY2xhc3Nlc1xuICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKVxuICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKVxuICByZXR1cm4gY2xhc3Nlc1xufVxuXG5FbGVtZW50Q2xhc3MucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIGlmICghZWwpIHJldHVyblxuICBpZiAoZWwuY2xhc3NOYW1lID09PSBcIlwiKSByZXR1cm5cbiAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVxuICB2YXIgaWR4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSlcbiAgaWYgKGlkeCA+IC0xKSBjbGFzc2VzLnNwbGljZShpZHgsIDEpXG4gIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpXG4gIHJldHVybiBjbGFzc2VzXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KCcgJylcbiAgcmV0dXJuIGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID4gLTFcbn1cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4zLjNcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBhbG51bSwgcmVmO1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4uL3JlZicpLnJlZjtcblxuICBhbG51bSA9IHtcbiAgICAnMCc6IHJlZignMCcsIDQ4KSxcbiAgICAnMSc6IHJlZignMScsIDQ5KSxcbiAgICAnMic6IHJlZignMicsIDUwKSxcbiAgICAnMyc6IHJlZignMycsIDUxKSxcbiAgICAnNCc6IHJlZignNCcsIDUyKSxcbiAgICAnNSc6IHJlZignNScsIDUzKSxcbiAgICAnNic6IHJlZignNicsIDU0KSxcbiAgICAnNyc6IHJlZignNycsIDU1KSxcbiAgICAnOCc6IHJlZignOCcsIDU2KSxcbiAgICAnOSc6IHJlZignOScsIDU3KSxcbiAgICBhOiByZWYoJ0EnLCA2NSksXG4gICAgYjogcmVmKCdCJywgNjYpLFxuICAgIGM6IHJlZignQycsIDY3KSxcbiAgICBkOiByZWYoJ0QnLCA2OCksXG4gICAgZTogcmVmKCdFJywgNjkpLFxuICAgIGY6IHJlZignRicsIDcwKSxcbiAgICBnOiByZWYoJ0cnLCA3MSksXG4gICAgaDogcmVmKCdIJywgNzIpLFxuICAgIGk6IHJlZignSScsIDczKSxcbiAgICBqOiByZWYoJ0onLCA3NCksXG4gICAgazogcmVmKCdLJywgNzUpLFxuICAgIGw6IHJlZignTCcsIDc2KSxcbiAgICBtOiByZWYoJ00nLCA3NyksXG4gICAgbjogcmVmKCdOJywgNzgpLFxuICAgIG86IHJlZignTycsIDc5KSxcbiAgICBwOiByZWYoJ1AnLCA4MCksXG4gICAgcTogcmVmKCdRJywgODEpLFxuICAgIHI6IHJlZignUicsIDgyKSxcbiAgICBzOiByZWYoJ1MnLCA4MyksXG4gICAgdDogcmVmKCdUJywgODQpLFxuICAgIHU6IHJlZignVScsIDg1KSxcbiAgICB2OiByZWYoJ1YnLCA4NiksXG4gICAgdzogcmVmKCdXJywgODcpLFxuICAgIHg6IHJlZignWCcsIDg4KSxcbiAgICB5OiByZWYoJ1knLCA4OSksXG4gICAgejogcmVmKCdaJywgOTApXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBhbG51bTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4zLjNcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBhcnJvdywgcmVmO1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4uL3JlZicpLnJlZjtcblxuICBhcnJvdyA9IHtcbiAgICBsZWZ0OiByZWYoJ0xlZnQnLCAzNyksXG4gICAgdXA6IHJlZignVXAnLCAzOCksXG4gICAgcmlnaHQ6IHJlZignUmlnaHQnLCAzOSksXG4gICAgZG93bjogcmVmKCdEb3duJywgNDApXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBhcnJvdztcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4zLjNcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBicmFuZCwgcmVmO1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4uL3JlZicpLnJlZjtcblxuICBicmFuZCA9IHtcbiAgICBhcHBsZTogcmVmKCdBcHBsZSAmIzg5ODQ7JywgMjI0KSxcbiAgICB3aW5kb3dzOiB7XG4gICAgICBzdGFydDogcmVmKCdXaW5kb3dzIHN0YXJ0JywgWzkxLCA5Ml0pLFxuICAgICAgbWVudTogcmVmKCdXaW5kb3dzIG1lbnUnLCA5MylcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBicmFuZDtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4zLjNcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwdW5jdHVhdGlvbiwgcmVmO1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4uL3JlZicpLnJlZjtcblxuICBwdW5jdHVhdGlvbiA9IHtcbiAgICBjb2xvbjogcmVmKCdDb2xvbi9TZW1pY29sb24nLCBbNTksIDE4Nl0pLFxuICAgIGVxdWFsOiByZWYoJ0VxdWFsL1BsdXMnLCBbNjEsIDE4N10pLFxuICAgIGNvbW1hOiByZWYoJ0NvbW1hL0xlc3MgVGhhbicsIFs0NCwgMTg4XSksXG4gICAgaHlwaGVuOiByZWYoJ0h5cGhlbi9VbmRlcnNjb3JlJywgWzQ1LCAxMDksIDE4OV0pLFxuICAgIHBlcmlvZDogcmVmKCdQZXJpb2QvR3JlYXRlciBUaGFuJywgWzQ2LCAxOTBdKSxcbiAgICB0aWxkZTogcmVmKCdUaWxkZS9CYWNrIFRpY2snLCBbOTYsIDE5Ml0pLFxuICAgIGFwb3N0cm9waGU6IHJlZignQXBvc3Ryb3BoZS9RdW90ZScsIFszOSwgMjIyXSksXG4gICAgc2xhc2g6IHtcbiAgICAgIGZvcndhcmQ6IHJlZignRm9yd2FyZCBTbGFzaC9RdWVzdGlvbiBNYXJrJywgWzQ3LCAxOTFdKSxcbiAgICAgIGJhY2t3YXJkOiByZWYoJ0JhY2t3YXJkIFNsYXNoL1BpcGUnLCAyMjApXG4gICAgfSxcbiAgICBicmFjZToge1xuICAgICAgc3F1YXJlOiB7XG4gICAgICAgIG9wZW46IHJlZignT3BlbiBTcXVhcmUvQ3VybHkgQnJhY2UnLCAyMTkpLFxuICAgICAgICBjbG9zZTogcmVmKCdDbG9zZSBTcXVhcmUvQ3VybHkgQnJhY2UnLCAyMjEpXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1bmN0dWF0aW9uLnNlbWljb2xvbiA9IHB1bmN0dWF0aW9uLmNvbG9uO1xuXG4gIHB1bmN0dWF0aW9uLnBsdXMgPSBwdW5jdHVhdGlvbi5lcXVhbDtcblxuICBwdW5jdHVhdGlvbi5sZXNzdGhhbiA9IHB1bmN0dWF0aW9uLmNvbW1hO1xuXG4gIHB1bmN0dWF0aW9uLnVuZGVyc2NvcmUgPSBwdW5jdHVhdGlvbi5oeXBoZW47XG5cbiAgcHVuY3R1YXRpb24uZ3JlYXRlcnRoYW4gPSBwdW5jdHVhdGlvbi5wZXJpb2Q7XG5cbiAgcHVuY3R1YXRpb24ucXVlc3Rpb24gPSBwdW5jdHVhdGlvbi5zbGFzaC5mb3J3YXJkO1xuXG4gIHB1bmN0dWF0aW9uLmJhY2t0aWNrID0gcHVuY3R1YXRpb24udGlsZGU7XG5cbiAgcHVuY3R1YXRpb24ucGlwZSA9IHB1bmN0dWF0aW9uLnNsYXNoLmJhY2t3YXJkO1xuXG4gIHB1bmN0dWF0aW9uLnF1b3RlID0gcHVuY3R1YXRpb24uYXBvc3Ryb3BoZTtcblxuICBwdW5jdHVhdGlvbi5icmFjZS5jdXJseSA9IHB1bmN0dWF0aW9uLmJyYWNlLnNxdWFyZTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHB1bmN0dWF0aW9uO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjMuM1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHJlZiwgc3BlY2lhbDtcblxuICByZWYgPSByZXF1aXJlKCcuLi9yZWYnKS5yZWY7XG5cbiAgc3BlY2lhbCA9IHtcbiAgICBiYWNrc3BhY2U6IHJlZignQmFja3NwYWNlJywgOCksXG4gICAgdGFiOiByZWYoJ1RhYicsIDkpLFxuICAgIGVudGVyOiByZWYoJ0VudGVyJywgMTMpLFxuICAgIHNoaWZ0OiByZWYoJ1NoaWZ0JywgMTYpLFxuICAgIGN0cmw6IHJlZignQ3RybCcsIDE3KSxcbiAgICBhbHQ6IHJlZignQWx0JywgMTgpLFxuICAgIGNhcHM6IHJlZignQ2FwcyBMb2NrJywgMjApLFxuICAgIGVzYzogcmVmKCdFc2NhcGUnLCAyNyksXG4gICAgc3BhY2U6IHJlZignU3BhY2UnLCAzMiksXG4gICAgbnVtOiByZWYoJ051bSBMb2NrJywgMTQ0KVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gc3BlY2lhbDtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4zLjNcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBpc1JlZiwgaXRlcmF0b3IsIGtleSxcbiAgICBfdGhpcyA9IHRoaXMsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgaXNSZWYgPSByZXF1aXJlKCcuL3JlZicpLmlzUmVmO1xuXG4gIGtleSA9IHt9O1xuXG4gIGtleS5jb2RlID0ge1xuICAgIHNwZWNpYWw6IHJlcXVpcmUoJy4vY29kZS9zcGVjaWFsJyksXG4gICAgYXJyb3c6IHJlcXVpcmUoJy4vY29kZS9hcnJvdycpLFxuICAgIHB1bmN0dWF0aW9uOiByZXF1aXJlKCcuL2NvZGUvcHVuY3R1YXRpb24nKSxcbiAgICBhbG51bTogcmVxdWlyZSgnLi9jb2RlL2FsbnVtJyksXG4gICAgYnJhbmQ6IHJlcXVpcmUoJy4vY29kZS9icmFuZCcpXG4gIH07XG5cbiAga2V5LmdldCA9IGZ1bmN0aW9uKHByZXNzZWQpIHtcbiAgICByZXR1cm4gaXRlcmF0b3Ioa2V5LmNvZGUsIHByZXNzZWQpO1xuICB9O1xuXG4gIGtleS5pcyA9IGZ1bmN0aW9uKHJlZiwgcHJlc3NlZCkge1xuICAgIGlmICghaXNSZWYocmVmKSkge1xuICAgICAgcmVmID0gaXRlcmF0b3IocmVmLCBwcmVzc2VkKTtcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlZikpIHtcbiAgICAgIGlmIChpc1JlZihwcmVzc2VkKSkge1xuICAgICAgICByZXR1cm4gcHJlc3NlZCA9PT0gcmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZXNzZWQgPT09IHJlZi5jb2RlIHx8IF9faW5kZXhPZi5jYWxsKHJlZi5jb2RlLCBwcmVzc2VkKSA+PSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJlc3NlZCA9PT0gcmVmO1xuICAgIH1cbiAgfTtcblxuICBpdGVyYXRvciA9IGZ1bmN0aW9uKGNvbnRleHQsIHByZXNzZWQpIHtcbiAgICB2YXIgaSwgb3V0LCByZWY7XG4gICAgZm9yIChpIGluIGNvbnRleHQpIHtcbiAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoY29udGV4dCwgaSkpIGNvbnRpbnVlO1xuICAgICAgcmVmID0gY29udGV4dFtpXTtcbiAgICAgIGlmIChpc1JlZihyZWYpKSB7XG4gICAgICAgIGlmIChrZXkuaXMocmVmLCBwcmVzc2VkKSkge1xuICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCA9IGl0ZXJhdG9yKHJlZiwgcHJlc3NlZCk7XG4gICAgICAgIGlmIChpc1JlZihvdXQpKSB7XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cua2V5ID0ga2V5O1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBrZXk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMy4zXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgUmVmZXJlbmNlLCBhc3NlcnRSZWYsIGlzUmVmLCByZWY7XG5cbiAgUmVmZXJlbmNlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKG5hbWUsIGNvZGUpIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBSZWZlcmVuY2U7XG5cbiAgfSkoKTtcblxuICByZWYgPSBmdW5jdGlvbihuYW1lLCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UobmFtZSwgY29kZSk7XG4gIH07XG5cbiAgaXNSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgICByZXR1cm4gcmVmIGluc3RhbmNlb2YgUmVmZXJlbmNlO1xuICB9O1xuXG4gIGFzc2VydFJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmICghaXNSZWYocmVmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlZmVyZW5jZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlZjogcmVmLFxuICAgIGlzUmVmOiBpc1JlZixcbiAgICBhc3NlcnRSZWY6IGFzc2VydFJlZlxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIGFkZERpcnR5UHJvcHMgPSByZXF1aXJlKCcuLi9hZGQtZGlydHktcHJvcHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIG5vb3AgPSByZXF1aXJlKCcuLi9uby1vcCcpO1xudmFyIHBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi4vcGFzcy10aHJvdWdoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkLCBuYW1lLCBsZW5ndGhOYW1lLCBkZWZhdWx0U2l6ZSkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG5cbiAgICB2YXIgZGVzY3JpcHRvcnMgPSBbXTtcbiAgICB2YXIgbnVtRml4ZWQgPSAwO1xuICAgIHZhciBudW1IZWFkZXJzID0gMDtcbiAgICB2YXIgbWFrZURpcnR5Q2xlYW4gPSByZXF1aXJlKCcuLi9kaXJ0eS1jbGVhbicpO1xuICAgIHZhciBkaXJ0eUNsZWFuID0gbWFrZURpcnR5Q2xlYW4oZ3JpZCk7XG4gICAgdmFyIGJ1aWxkZXJEaXJ0eUNsZWFuID0gbWFrZURpcnR5Q2xlYW4oZ3JpZCk7XG4gICAgdmFyIHNlbGVjdGVkID0gW107XG5cbiAgICBmdW5jdGlvbiBzZXREZXNjcmlwdG9yc0RpcnR5KGV2ZW50T3B0aW9uYWwpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRPcHRpb25hbCB8fCB7fTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdncmlkLScgKyBuYW1lICsgJy1jaGFuZ2UnO1xuICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKGV2ZW50KTtcbiAgICAgICAgZGlydHlDbGVhbi5zZXREaXJ0eSgpO1xuICAgICAgICBidWlsZGVyRGlydHlDbGVhbi5zZXREaXJ0eSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmVTZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIGdyaWQuZXZlbnRMb29wLmZpcmUoJ2dyaWQtJyArIG5hbWUgKyAnLXNlbGVjdGlvbi1jaGFuZ2UnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEZXNjcmlwdG9ySW5kaWNlcygpIHtcbiAgICAgICAgZGVzY3JpcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVzY3JpcHRvciwgaSkge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5pbmRleCA9IGk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGFyZUJ1aWxkZXJzRGlydHk6IGJ1aWxkZXJEaXJ0eUNsZWFuLmlzRGlydHksXG4gICAgICAgIGlzRGlydHk6IGRpcnR5Q2xlYW4uaXNEaXJ0eSxcbiAgICAgICAgZGVmYXVsdFNpemU6IGRlZmF1bHRTaXplLFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uICh0b0FkZCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzQXJyYXkodG9BZGQpKSB7XG4gICAgICAgICAgICAgICAgdG9BZGQgPSBbdG9BZGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9BZGQuZm9yRWFjaChmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycy5zcGxpY2UobnVtSGVhZGVycywgMCwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIG51bUZpeGVkKys7XG4gICAgICAgICAgICAgICAgICAgIG51bUhlYWRlcnMrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgY29sdW1uIGlzIGZpeGVkIGFuZCB0aGUgbGFzdCBvbmUgYWRkZWQgaXMgZml4ZWQgKHdlIG9ubHkgYWxsb3cgZml4ZWQgYXQgdGhlIGJlZ2lubmluZyBmb3Igbm93KVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9ycy5sZW5ndGggfHwgZGVzY3JpcHRvcnNbZGVzY3JpcHRvcnMubGVuZ3RoIC0gMV0uZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1GaXhlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGFkZCBhIGZpeGVkIGNvbHVtbiBhZnRlciBhbiB1bmZpeGVkIG9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMucHVzaChkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZURlc2NyaXB0b3JJbmRpY2VzKCk7XG4gICAgICAgICAgICBzZXREZXNjcmlwdG9yc0RpcnR5KHthY3Rpb246ICdhZGQnLCBkZXNjcmlwdG9yczogdG9BZGR9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkSGVhZGVyczogZnVuY3Rpb24gKHRvQWRkKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNBcnJheSh0b0FkZCkpIHtcbiAgICAgICAgICAgICAgICB0b0FkZCA9IFt0b0FkZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b0FkZC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIuaGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXBpLmFkZCh0b0FkZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcjogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnNbaW5kZXhdO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzW2luZGV4XTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoaW5jbHVkZUhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBzdWJ0cmFjdCA9IGluY2x1ZGVIZWFkZXJzID8gMCA6IG51bUhlYWRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnMubGVuZ3RoIC0gc3VidHJhY3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGRlc2NyaXB0b3IsIGRvbnRVcGRhdGVJbmRleCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZGVzY3JpcHRvcnMuaW5kZXhPZihkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBudW1GaXhlZC0tO1xuICAgICAgICAgICAgICAgICAgICBudW1IZWFkZXJzLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdG9yLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bUZpeGVkLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEZXNjcmlwdG9ySW5kaWNlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9ycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVIZWFkZXJzIHx8ICFkZXNjcmlwdG9yLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBhcGkucmVtb3ZlKGRlc2NyaXB0b3IsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbiAoc3RhcnQsIHRhcmdldCkge1xuICAgICAgICAgICAgZGVzY3JpcHRvcnMuc3BsaWNlKHRhcmdldCwgMCwgZGVzY3JpcHRvcnMuc3BsaWNlKHN0YXJ0LCAxKVswXSk7XG4gICAgICAgICAgICB1cGRhdGVEZXNjcmlwdG9ySW5kaWNlcygpO1xuICAgICAgICAgICAgc2V0RGVzY3JpcHRvcnNEaXJ0eSh7YWN0aW9uOiAnbW92ZScsIGRlc2NyaXB0b3JzOiBbYXBpLmdldChzdGFydCksIGFwaS5nZXQodGFyZ2V0KV19KTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtSGVhZGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bUhlYWRlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIG51bUZpeGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtRml4ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmlydHVhbDogZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJbmRleCArIGFwaS5udW1IZWFkZXJzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvRGF0YTogZnVuY3Rpb24gKHZpcnR1YWxJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleCAtIGFwaS5udW1IZWFkZXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoaW5kZXgpIHtcblxuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBhcGlbbmFtZV0oaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgZmlyZVNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXNlbGVjdDogZnVuY3Rpb24gKGluZGV4LCBkb250Tm90aWZ5KSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGFwaVtuYW1lXShpbmRleCk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2Uoc2VsZWN0ZWQuaW5kZXhPZihpbmRleCksIDEpO1xuICAgICAgICAgICAgICAgIGlmICghZG9udE5vdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVTZWxlY3Q6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBhcGlbbmFtZV0oaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBhcGkuZGVzZWxlY3QoaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcGkuc2VsZWN0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNlbGVjdGVkLmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdGVkLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgYXBpLmRlc2VsZWN0KGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpcmVTZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoYnVpbGRlcikge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7fTtcbiAgICAgICAgICAgIHZhciBmaXhlZCA9IGZhbHNlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc2NyaXB0b3IsICdmaXhlZCcsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5oZWFkZXIgfHwgZml4ZWQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZml4ZWQgPSBfZml4ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4vL1xuLy8gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzY3JpcHRvciwgJ2luZGV4Jywge1xuLy8gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbi8vICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9ycy5pbmRleE9mKGRlc2NyaXB0b3IpO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWRkRGlydHlQcm9wcyhkZXNjcmlwdG9yLCBbJ2J1aWxkZXInXSwgW2J1aWxkZXJEaXJ0eUNsZWFuXSk7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmJ1aWxkZXIgPSBidWlsZGVyO1xuXG4gICAgICAgICAgICByZXR1cm4gYWRkRGlydHlQcm9wcyhkZXNjcmlwdG9yLCBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsZW5ndGhOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvbkRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREZXNjcmlwdG9yc0RpcnR5KHthY3Rpb246ICdzaXplJywgZGVzY3JpcHRvcnM6IFtkZXNjcmlwdG9yXX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBvbkRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREZXNjcmlwdG9yc0RpcnR5KHthY3Rpb246ICdoaWRlJywgZGVzY3JpcHRvcnM6IFtkZXNjcmlwdG9yXX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgW2RpcnR5Q2xlYW5dKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlQnVpbGRlcjogZnVuY3Rpb24gKHJlbmRlciwgdXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3JlbmRlcjogcmVuZGVyIHx8IG5vb3AsIHVwZGF0ZTogdXBkYXRlIHx8IHBhc3NUaHJvdWdofTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vYmFzaWNhbGx5IGhlaWdodCBvciB3aWR0aFxuICAgIGFwaVtsZW5ndGhOYW1lXSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW2luZGV4XTtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoZGVzY3JpcHRvci5oaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JbbGVuZ3RoTmFtZV0gfHwgYXBpLmRlZmF1bHRTaXplO1xuICAgIH07XG5cbiAgICAvL3JvdyBvciBjb2wgZ2V0XG4gICAgYXBpW25hbWVdID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yc1tpbmRleCArIG51bUhlYWRlcnNdO1xuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHByb3BzLCBkaXJ0eUNsZWFucykge1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUgfHwgcHJvcDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIChfdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IF92YWwgIT09IHZhbDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YWwgPSBfdmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eUNsZWFucy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJ0eUNsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5vbkRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLm9uRGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyLm1vZHVsZSgnZ3JpZC1kZWNvcmF0b3InLCBbXSlcbiAgICAuZmFjdG9yeSgnR3JpZERlY29yYXRvclNydmMnLCBmdW5jdGlvbiAoJGNvbXBpbGUpIHtcbiAgICAgICAgdmFyIEdyaWREZWNvcmF0b3JTcnZjID0ge1xuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgICAgIHZhciBjb21waWxlZCA9ICRjb21waWxlKG9wdHMudGVtcGxhdGUpKG9wdHMuJHNjb3BlKTtcbiAgICAgICAgICAgICAgICBjb21waWxlZC5vbignZGVjb3JhdG9yLWRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuJHNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vdW5iaW5kIGluIGEgdGltZW91dCB0byBhbGxvdyBhbnkgb3RoZXIgbGlzdGVuZXJzIHRvIGZpcmUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21waWxlZC5vZmYoJ2RlY29yYXRvci1kZXN0cm95Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdHMuJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlZFswXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlZFswXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3JzOiBmdW5jdGlvbiAoZ3JpZCwgbW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0Fubm90YXRlID0gbW9kZWwuYW5ub3RhdGVEZWNvcmF0b3I7XG4gICAgICAgICAgICAgICAgbW9kZWwuYW5ub3RhdGVEZWNvcmF0b3IgPSBmdW5jdGlvbiAoZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gR3JpZERlY29yYXRvclNydmMucmVuZGVyKGRlYy5yZW5kZXJPcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdBbm5vdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ0Fubm90YXRlKGRlYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi4vaGVhZGVyLWRlY29yYXRvcnMnKShncmlkLCBtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBHcmlkRGVjb3JhdG9yU3J2Y1xuICAgIH0pXG5cbjsiLCJ2YXIgcG9zaXRpb25SYW5nZSA9IHJlcXVpcmUoJy4uL3Bvc2l0aW9uLXJhbmdlJyk7XG52YXIgbWFrZURpcnR5Q2xlYW4gPSByZXF1aXJlKCcuLi9kaXJ0eS1jbGVhbicpO1xudmFyIGFkZERpcnR5UHJvcHMgPSByZXF1aXJlKCcuLi9hZGQtZGlydHktcHJvcHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGRpcnR5Q2xlYW4gPSBtYWtlRGlydHlDbGVhbihncmlkKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSBbXTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2goZGVzY3JpcHRvcik7XG4gICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzLnNwbGljZShkZXNjcmlwdG9ycy5pbmRleE9mKGRlc2NyaXB0b3IpLCAxKTtcbiAgICAgICAgICAgIGRpcnR5Q2xlYW4uc2V0RGlydHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcnMuc2xpY2UoMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHRvcCwgbGVmdCwgY2xhc3NOYW1lLCBoZWlnaHQsIHdpZHRoLCBzcGFjZSkge1xuICAgICAgICAgICAgdmFyIHRoaXNEaXJ0eUNsZWFuID0gbWFrZURpcnR5Q2xlYW4oZ3JpZCk7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHt9O1xuICAgICAgICAgICAgLy9taXhpbnNcbiAgICAgICAgICAgIHBvc2l0aW9uUmFuZ2UoZGVzY3JpcHRvciwgdGhpc0RpcnR5Q2xlYW4sIGRpcnR5Q2xlYW4pO1xuICAgICAgICAgICAgYWRkRGlydHlQcm9wcyhkZXNjcmlwdG9yLCBbJ2NsYXNzJ10sIFt0aGlzRGlydHlDbGVhbiwgZGlydHlDbGVhbl0pO1xuXG4gICAgICAgICAgICAvL2FsbCBvZiB0aGVzZSBhcmUgb3B0aW9uYWxcbiAgICAgICAgICAgIGRlc2NyaXB0b3IudG9wID0gdG9wO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIC8vZGVmYXVsdCB0byBzaW5nbGUgY2VsbCByYW5nZXNcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLndpZHRoID0gd2lkdGggfHwgMTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuY2xhc3MgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLnNwYWNlID0gc3BhY2UgfHwgZGVzY3JpcHRvci5zcGFjZTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9LFxuICAgICAgICBpc0RpcnR5OiBkaXJ0eUNsZWFuLmlzRGlydHlcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCJ2YXIgY3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b20tZXZlbnQnKTtcblxudmFyIFBST1BTX1RPX0NPUFlfRlJPTV9NT1VTRV9FVkVOVFMgPSBbJ2NsaWVudFgnLCAnY2xpZW50WScsICdncmlkWCcsICdncmlkWScsICdsYXllclgnLCAnbGF5ZXJZJywgJ3JvdycsICdjb2wnLCAncmVhbFJvdycsICdyZWFsQ29sJ107XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIG1vZGVsID0ge307XG5cbiAgICB2YXIgd2FzRHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgbW9kZWwuX2Fubm90YXRlRXZlbnQgPSBmdW5jdGlvbiBhbm5vdGF0ZUV2ZW50KGUpIHtcbiAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICBlLndhc0RyYWdnZWQgPSB3YXNEcmFnZ2VkO1xuICAgICAgICAgICAgLyoganNoaW50IC1XMDg2ICovXG4gICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgICAgLyoganNoaW50ICtXMDg2ICovXG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICBjYXNlICdkYmxjbGljayc6XG4gICAgICAgICAgICAgICAgbW9kZWwuX2Fubm90YXRlRXZlbnRJbnRlcm5hbChlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZGVsLl9hbm5vdGF0ZUV2ZW50RnJvbVZpZXdDb29yZHMgPSBmdW5jdGlvbiAoZSwgdmlld1Jvdywgdmlld0NvbCkge1xuICAgICAgICBlLnJlYWxSb3cgPSB2aWV3Um93O1xuICAgICAgICBlLnJlYWxDb2wgPSB2aWV3Q29sO1xuICAgICAgICBlLnZpcnR1YWxSb3cgPSBncmlkLnZpZXdQb3J0LnRvVmlydHVhbFJvdyhlLnJlYWxSb3cpO1xuICAgICAgICBlLnZpcnR1YWxDb2wgPSBncmlkLnZpZXdQb3J0LnRvVmlydHVhbENvbChlLnJlYWxDb2wpO1xuICAgICAgICBlLnJvdyA9IGUudmlydHVhbFJvdyAtIGdyaWQucm93TW9kZWwubnVtSGVhZGVycygpO1xuICAgICAgICBlLmNvbCA9IGUudmlydHVhbENvbCAtIGdyaWQuY29sTW9kZWwubnVtSGVhZGVycygpO1xuICAgIH1cblxuICAgIG1vZGVsLl9hbm5vdGF0ZUV2ZW50SW50ZXJuYWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgeSA9IGdyaWQudmlld1BvcnQudG9HcmlkWShlLmNsaWVudFkpO1xuICAgICAgICB2YXIgeCA9IGdyaWQudmlld1BvcnQudG9HcmlkWChlLmNsaWVudFgpO1xuICAgICAgICB2YXIgdmlld1JvdyA9IGdyaWQudmlld1BvcnQuZ2V0Um93QnlUb3AoeSk7XG4gICAgICAgIHZhciB2aWV3Q29sID0gZ3JpZC52aWV3UG9ydC5nZXRDb2xCeUxlZnQoeCk7XG4gICAgICAgIG1vZGVsLl9hbm5vdGF0ZUV2ZW50RnJvbVZpZXdDb29yZHMoZSwgdmlld1Jvdywgdmlld0NvbCk7XG4gICAgICAgIGUuZ3JpZFggPSB4O1xuICAgICAgICBlLmdyaWRZID0geTtcbiAgICB9O1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYWRkSW50ZXJjZXB0b3IoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgbW9kZWwuX2Fubm90YXRlRXZlbnQoZSk7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIHNldHVwRHJhZ0V2ZW50Rm9yTW91c2VEb3duKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzZXR1cERyYWdFdmVudEZvck1vdXNlRG93bihkb3duRXZlbnQpIHtcbiAgICAgICAgd2FzRHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGFzdERyYWdSb3cgPSBkb3duRXZlbnQucm93O1xuICAgICAgICB2YXIgbGFzdERyYWdDb2wgPSBkb3duRXZlbnQuY29sO1xuICAgICAgICB2YXIgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuYmluZE1vdmUgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdtb3VzZW1vdmUnLCB3aW5kb3csIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ1N0YXJ0ZWQgJiYgIWUud2hpY2gpIHtcbiAgICAgICAgICAgICAgICAvL2dvdCBhIG1vdmUgZXZlbnQgd2l0aG91dCBtb3VzZSBkb3duIHdoaWNoIG1lYW5zIHdlIHNvbWVob3cgbWlzc2VkIHRoZSBtb3VzZXVwXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdXNlbW92ZSB1bmJpbmQsIGhvdyBvbiBlYXJ0aCBkbyB0aGVzZSBoYXBwZW4/Jyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlTW91c2VVcChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB3YXNEcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjcmVhdGVBbmRGaXJlRHJhZ0V2ZW50KCdncmlkLWRyYWctc3RhcnQnLCBkb3duRXZlbnQpO1xuICAgICAgICAgICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3JlYXRlQW5kRmlyZURyYWdFdmVudCgnZ3JpZC1kcmFnJywgZSk7XG5cbiAgICAgICAgICAgIGlmIChlLnJvdyAhPT0gbGFzdERyYWdSb3cgfHwgZS5jb2wgIT09IGxhc3REcmFnQ29sKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQW5kRmlyZURyYWdFdmVudCgnZ3JpZC1jZWxsLWRyYWcnLCBlKTtcblxuICAgICAgICAgICAgICAgIGxhc3REcmFnUm93ID0gZS5yb3c7XG4gICAgICAgICAgICAgICAgbGFzdERyYWdDb2wgPSBlLmNvbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdW5iaW5kVXAgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdtb3VzZXVwJywgd2luZG93LCBoYW5kbGVNb3VzZVVwKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGUpIHtcbiAgICAgICAgICAgIHVuYmluZE1vdmUoKTtcbiAgICAgICAgICAgIHVuYmluZFVwKCk7XG5cbiAgICAgICAgICAgIHZhciBkcmFnRW5kID0gY3JlYXRlRHJhZ0V2ZW50RnJvbU1vdXNlRXZlbnQoJ2dyaWQtZHJhZy1lbmQnLCBlKTtcblxuICAgICAgICAgICAgLy9yb3csIGNvbCwgeCwgYW5kIHkgc2hvdWxkIGluaGVyaXRcbiAgICAgICAgICAgIGdyaWQuZXZlbnRMb29wLmZpcmUoZHJhZ0VuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFnRXZlbnRGcm9tTW91c2VFdmVudCh0eXBlLCBlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGN1c3RvbUV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICBQUk9QU19UT19DT1BZX0ZST01fTU9VU0VfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGV2ZW50W3Byb3BdID0gZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBlO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQW5kRmlyZURyYWdFdmVudCh0eXBlLCBlKSB7XG4gICAgICAgIHZhciBkcmFnID0gY3JlYXRlRHJhZ0V2ZW50RnJvbU1vdXNlRXZlbnQodHlwZSwgZSk7XG4gICAgICAgIGlmIChlLnRhcmdldCkge1xuICAgICAgICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQuZXZlbnRMb29wLmZpcmUoZHJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuICAgIHZhciBkaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKShncmlkKTtcblxuXG4gICAgdmFyIHJvdztcbiAgICB2YXIgbW9kZWwgPSB7Y29sOiAwfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kZWwsICdyb3cnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcm93ID0gcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1vZGVsLnJvdyA9IDA7XG5cbiAgICBtb2RlbC5pc0RpcnR5ID0gZGlydHlDbGVhbi5pc0RpcnR5O1xuXG4gICAgbW9kZWwuc2Nyb2xsVG8gPSBmdW5jdGlvbiAociwgYywgZG9udEZpcmUsIGZyb21QaXhlbE1vZGVsKSB7XG4gICAgICAgIGlmIChpc05hTihyKSB8fCBpc05hTihjKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhSb3cgPSAoZ3JpZC5yb3dNb2RlbC5sZW5ndGgoKSB8fCAxKSAtIDE7XG4gICAgICAgIHZhciBtYXhDb2wgPSAoZ3JpZC5jb2xNb2RlbC5sZW5ndGgoKSB8fCAxKSAtIDE7XG4gICAgICAgIHZhciBsYXN0Um93ID0gbW9kZWwucm93O1xuICAgICAgICB2YXIgbGFzdENvbCA9IG1vZGVsLmNvbDtcbiAgICAgICAgbW9kZWwucm93ID0gdXRpbC5jbGFtcChyLCAwLCBtYXhSb3cpO1xuICAgICAgICBtb2RlbC5jb2wgPSB1dGlsLmNsYW1wKGMsIDAsIG1heENvbCk7XG4gICAgICAgIGlmIChsYXN0Um93ICE9PSBtb2RlbC5yb3cgfHwgbGFzdENvbCAhPT0gbW9kZWwuY29sKSB7XG4gICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG5cbiAgICAgICAgICAgIGlmICghZG9udEZpcmUpIHtcbiAgICAgICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKCdncmlkLWNlbGwtc2Nyb2xsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZnJvbVBpeGVsTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuaGVpZ2h0KDAsIG1vZGVsLnJvdyAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwud2lkdGgoMCwgbW9kZWwuY29sIC0gMSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5waXhlbFNjcm9sbE1vZGVsLnNjcm9sbFRvKHRvcCwgbGVmdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29udmVydFZpcnR1YWxUb1Njcm9sbCh2aXJ0dWFsQ29vcmQsIHJvd09yQ29sKSB7XG4gICAgICAgIHJldHVybiB2aXJ0dWFsQ29vcmQgLSBncmlkW3Jvd09yQ29sICsgJ01vZGVsJ10ubnVtRml4ZWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxUb1Jvd09yQ29sKHZpcnR1YWxDb29yZCwgcm93T3JDb2wsIGhlaWdodFdpZHRoKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2Nyb2xsID0gbW9kZWxbcm93T3JDb2xdO1xuICAgICAgICB2YXIgc2Nyb2xsVG8gPSBjdXJyZW50U2Nyb2xsO1xuICAgICAgICBpZiAoZ3JpZC52aWV3UG9ydFtyb3dPckNvbCArICdJc0luVmlldyddKHZpcnR1YWxDb29yZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JvbGxUbztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YXJnZXRTY3JvbGwgPSBjb252ZXJ0VmlydHVhbFRvU2Nyb2xsKHZpcnR1YWxDb29yZCwgcm93T3JDb2wpO1xuICAgICAgICBpZiAodGFyZ2V0U2Nyb2xsIDwgY3VycmVudFNjcm9sbCkge1xuICAgICAgICAgICAgc2Nyb2xsVG8gPSB0YXJnZXRTY3JvbGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2Nyb2xsID4gY3VycmVudFNjcm9sbCkge1xuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoVG9DZWxsID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWxbaGVpZ2h0V2lkdGhdKDAsIHZpcnR1YWxDb29yZCk7XG4gICAgICAgICAgICB2YXIgbnVtRml4ZWQgPSBncmlkW3Jvd09yQ29sICsgJ01vZGVsJ10ubnVtRml4ZWQoKTtcbiAgICAgICAgICAgIHNjcm9sbFRvID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBudW1GaXhlZDsgaSA8IHZpcnR1YWxDb29yZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoVG9DZWxsIC09IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsW2hlaWdodFdpZHRoXShpKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxUbyA9IGkgLSAobnVtRml4ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoVG9DZWxsIDw9IGdyaWQudmlld1BvcnRbaGVpZ2h0V2lkdGhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY3JvbGxUbztcbiAgICB9XG5cbiAgICBtb2RlbC5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uICh2ciwgdmMpIHtcbiAgICAgICAgdnIgPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5jbGFtcFJvdyh2cik7XG4gICAgICAgIHZjID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuY2xhbXBDb2wodmMpO1xuICAgICAgICB2YXIgbmV3Um93ID0gZ2V0U2Nyb2xsVG9Sb3dPckNvbCh2ciwgJ3JvdycsICdoZWlnaHQnKTtcbiAgICAgICAgdmFyIG5ld0NvbCA9IGdldFNjcm9sbFRvUm93T3JDb2wodmMsICdjb2wnLCAnd2lkdGgnKTtcbiAgICAgICAgbW9kZWwuc2Nyb2xsVG8obmV3Um93LCBuZXdDb2wpO1xuICAgIH07XG5cblxuICAgIHJldHVybiBtb2RlbDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGFwaSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0LXJvdy1jb2wtbW9kZWwnKShncmlkLCAnY29sJywgJ3dpZHRoJywgMTAwKTtcblxuICAgIHJldHVybiBhcGk7XG59OyIsInZhciBlbGVtZW50Q2xhc3MgPSByZXF1aXJlKCdlbGVtZW50LWNsYXNzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG5cbiAgICB2YXIgYXBpID0ge2Fubm90YXRlRGVjb3JhdG9yOiBtYWtlUmVvcmRlckRlY29yYXRvcn07XG5cbiAgICBmdW5jdGlvbiBtYWtlUmVvcmRlckRlY29yYXRvcihoZWFkZXJEZWNvcmF0b3IpIHtcbiAgICAgICAgdmFyIGNvbCA9IGhlYWRlckRlY29yYXRvci5sZWZ0O1xuICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0ID0gZ3JpZC5kZWNvcmF0b3JzLmNyZWF0ZSgwLCB1bmRlZmluZWQsIEluZmluaXR5LCB1bmRlZmluZWQsICdweCcsICdyZWFsJyk7XG5cbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5wb3N0UmVuZGVyID0gZnVuY3Rpb24gKGRpdikge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1kcmFnLXJlY3QnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnJlYWxDb2wgPCBncmlkLmNvbE1vZGVsLm51bUZpeGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLmFkZChoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0KTtcblxuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC53aWR0aCA9IGdyaWQudmlld1BvcnQuZ2V0Q29sV2lkdGgoY29sKTtcbiAgICAgICAgICAgIHZhciBjb2xPZmZzZXQgPSBlLmdyaWRYIC0gaGVhZGVyRGVjb3JhdG9yLmdldERlY29yYXRvckxlZnQoKTtcblxuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sID0gZ3JpZC5kZWNvcmF0b3JzLmNyZWF0ZSgwLCB1bmRlZmluZWQsIEluZmluaXR5LCAxLCAnY2VsbCcsICdyZWFsJyk7XG4gICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wucG9zdFJlbmRlciA9IGZ1bmN0aW9uIChkaXYpIHtcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdncmlkLXJlb3JkZXItdGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdC5fdGFyZ2V0Q29sLl9yZW5kZXJlZEVsZW0gPSBkaXY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLmFkZChoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wpO1xuXG4gICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWcgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWcnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3QubGVmdCA9IHV0aWwuY2xhbXAoZS5ncmlkWCAtIGNvbE9mZnNldCwgZ3JpZC52aWV3UG9ydC5nZXRDb2xMZWZ0KGdyaWQuY29sTW9kZWwubnVtRml4ZWQoKSksIEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wubGVmdCA9IHV0aWwuY2xhbXAoZS5yZWFsQ29sLCBncmlkLmNvbE1vZGVsLm51bUZpeGVkKCksIEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZS5yZWFsQ29sID4gY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRDbGFzcyhoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wuX3JlbmRlcmVkRWxlbSkuYWRkKCdyaWdodCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRDbGFzcyhoZWFkZXJEZWNvcmF0b3IuX2RyYWdSZWN0Ll90YXJnZXRDb2wuX3JlbmRlcmVkRWxlbSkucmVtb3ZlKCdyaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl91bmJpbmREcmFnRW5kID0gZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnLWVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldENvbCA9IGhlYWRlckRlY29yYXRvci5fZHJhZ1JlY3QuX3RhcmdldENvbC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgZ3JpZC5jb2xNb2RlbC5tb3ZlKGdyaWQudmlld1BvcnQudG9WaXJ0dWFsQ29sKGNvbCksIGdyaWQudmlld1BvcnQudG9WaXJ0dWFsQ29sKHRhcmdldENvbCkpO1xuICAgICAgICAgICAgICAgIGdyaWQuZGVjb3JhdG9ycy5yZW1vdmUoW2hlYWRlckRlY29yYXRvci5fZHJhZ1JlY3QuX3RhcmdldENvbCwgaGVhZGVyRGVjb3JhdG9yLl9kcmFnUmVjdF0pO1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fdW5iaW5kRHJhZygpO1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fdW5iaW5kRHJhZ0VuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLnBvc3RSZW5kZXIgPSBmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdncmlkLWNvbC1yZW9yZGVyJyk7XG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWctc3RhcnQnLCBkaXYsIGhlYWRlckRlY29yYXRvci5fb25EcmFnU3RhcnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBoZWFkZXJEZWNvcmF0b3I7XG4gICAgfVxuXG4gICAgcmVxdWlyZSgnLi4vaGVhZGVyLWRlY29yYXRvcnMnKShncmlkLCBhcGkpO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGFwaSA9IHthbm5vdGF0ZURlY29yYXRvcjogYW5ub3RhdGVEZWNvcmF0b3J9O1xuXG4gICAgZnVuY3Rpb24gYW5ub3RhdGVEZWNvcmF0b3IoaGVhZGVyRGVjb3JhdG9yKSB7XG4gICAgICAgIHZhciBjb2wgPSBoZWFkZXJEZWNvcmF0b3IubGVmdDtcbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLl9kcmFnTGluZSA9IGdyaWQuZGVjb3JhdG9ycy5jcmVhdGUoMCwgdW5kZWZpbmVkLCBJbmZpbml0eSwgMSwgJ3B4JywgJ3JlYWwnKTtcblxuICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX2RyYWdMaW5lLnBvc3RSZW5kZXIgPSBmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdncmlkLWRyYWctbGluZScpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhlYWRlckRlY29yYXRvci5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICBncmlkLmRlY29yYXRvcnMuYWRkKGhlYWRlckRlY29yYXRvci5fZHJhZ0xpbmUpO1xuXG4gICAgICAgICAgICBoZWFkZXJEZWNvcmF0b3IuX3VuYmluZERyYWcgPSBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWcnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBtaW5YID0gaGVhZGVyRGVjb3JhdG9yLmdldERlY29yYXRvckxlZnQoKSArIDEwO1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fZHJhZ0xpbmUubGVmdCA9IE1hdGgubWF4KGUuZ3JpZFgsIG1pblgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fdW5iaW5kRHJhZ0VuZCA9IGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhZy1lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGdyaWQuY29sTW9kZWwuZ2V0KGdyaWQudmlld1BvcnQudG9WaXJ0dWFsQ29sKGNvbCkpLndpZHRoID0gaGVhZGVyRGVjb3JhdG9yLl9kcmFnTGluZS5sZWZ0IC0gaGVhZGVyRGVjb3JhdG9yLmdldERlY29yYXRvckxlZnQoKTtcbiAgICAgICAgICAgICAgICBncmlkLmRlY29yYXRvcnMucmVtb3ZlKGhlYWRlckRlY29yYXRvci5fZHJhZ0xpbmUpO1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fdW5iaW5kRHJhZygpO1xuICAgICAgICAgICAgICAgIGhlYWRlckRlY29yYXRvci5fdW5iaW5kRHJhZ0VuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaGVhZGVyRGVjb3JhdG9yLnBvc3RSZW5kZXIgPSBmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoNTAlKSc7XG4gICAgICAgICAgICBkaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoNTAlKSc7XG5cbiAgICAgICAgICAgIGRpdi5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbGVmdCcpO1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnY29sLXJlc2l6ZScpO1xuXG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWctc3RhcnQnLCBkaXYsIGhlYWRlckRlY29yYXRvci5fb25EcmFnU3RhcnQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJlcXVpcmUoJy4uL2hlYWRlci1kZWNvcmF0b3JzJykoZ3JpZCwgYXBpKTtcblxuICAgIHJldHVybiBhcGk7XG59OyIsInZhciBjdHJsT3JDbWQgPSByZXF1aXJlKCcuLi9jdHJsLW9yLWNtZCcpO1xudmFyIHRzdiA9IHJlcXVpcmUoJy4uL3RzdicpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi4vZGVib3VuY2UnKTtcbnZhciByYW5nZVV0aWwgPSByZXF1aXJlKCcuLi9yYW5nZS11dGlsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29weVBhc3RlUmFuZ2UoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdyaWQubmF2aWdhdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICAgICAgLy92YWxpZCBzZWxlY3Rpb24gcmFuZ2UgY2Fubm90IGdvIHRvIC0xXG4gICAgICAgIGlmIChzZWxlY3Rpb25SYW5nZS50b3AgPT09IC0xKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IGdyaWQubmF2aWdhdGlvbk1vZGVsLmZvY3VzLnJvdyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBncmlkLm5hdmlnYXRpb25Nb2RlbC5mb2N1cy5jb2wsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25SYW5nZTtcbiAgICB9XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdjb3B5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy9wcmVwYXJlIGZvciBjb3B5XG4gICAgICAgIHZhciBjb3B5RGF0YSA9IFtdO1xuICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBnZXRDb3B5UGFzdGVSYW5nZSgpO1xuICAgICAgICByYW5nZVV0aWwuaXRlcmF0ZShzZWxlY3Rpb25SYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgICAgICAgY29weURhdGEucHVzaChyb3cpXG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9LCBmdW5jdGlvbiAociwgYywgcm93KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdyaWQuZGF0YU1vZGVsLmdldENvcHlEYXRhKHIsIGMpO1xuICAgICAgICAgICAgcm93LnB1c2goZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSgnVGV4dCcsIHRzdi5zdHJpbmdpZnkoY29weURhdGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignY29weSBldmVudCB3aXRob3V0IGNsaXBib2FyZCBkYXRhIG9yIHNldGRhdGEgcHJvcGVydHknKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdwYXN0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdldENvcHlQYXN0ZVJhbmdlKCk7XG4gICAgICAgIGlmICghZS5jbGlwYm9hcmREYXRhIHx8ICFlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdubyBjbGlwYm9hcmQgZGF0YSBvbiBwYXN0ZSBldmVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXN0ZURhdGEgPSB0c3YucGFyc2UoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKSk7XG4gICAgICAgIHZhciBkYXRhQ2hhbmdlcyA9IFtdO1xuICAgICAgICByYW5nZVV0aWwuaXRlcmF0ZShzZWxlY3Rpb25SYW5nZSwgZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRSID0gciAtIHNlbGVjdGlvblJhbmdlLnRvcDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRDID0gYyAtIHNlbGVjdGlvblJhbmdlLmxlZnQ7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlcy5wdXNoKHtyb3c6IHIsIGNvbDogYywgZGF0YTogcGFzdGVEYXRhW29mZnNldFJdW29mZnNldENdLCBwYXN0ZTogdHJ1ZX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JpZC5kYXRhTW9kZWwuc2V0KGRhdGFDaGFuZ2VzKTtcbiAgICB9KTtcblxuICAgIHZhciBtYXliZVNlbGVjdFRleHQgPSBkZWJvdW5jZShmdW5jdGlvbiBtYXliZVNlbGVjdFRleHRJbm5lcigpIHtcbiAgICAgICAgaWYgKCFtb2RlbC5pc1NlbGVjdGlvbkRpc2FibGVkIHx8ICFtb2RlbC5pc1NlbGVjdGlvbkRpc2FibGVkKCkpIHtcbiAgICAgICAgICAgIGdyaWQudGV4dGFyZWEudmFsdWUgPSAnICc7XG4gICAgICAgICAgICBncmlkLnRleHRhcmVhLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfSwgMSlcblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2tleXVwJywgbWF5YmVTZWxlY3RUZXh0KTtcbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWZvY3VzJywgbWF5YmVTZWxlY3RUZXh0KTtcblxuICAgIHZhciBtb2RlbCA9IHt9O1xuICAgIHJldHVybiBtb2RlbDtcbn07IiwidmFyIGVsZW1lbnRDbGFzcyA9IHJlcXVpcmUoJ2VsZW1lbnQtY2xhc3MnKTtcbnZhciBkaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZ3JpZCA9IHt9O1xuXG4gICAgLy90aGUgb3JkZXIgaGVyZSBtYXR0ZXJzIGJlY2F1c2Ugc29tZSBvZiB0aGVzZSBkZXBlbmQgb24gZWFjaCBvdGhlclxuICAgIGdyaWQuZXZlbnRMb29wID0gcmVxdWlyZSgnLi4vZXZlbnQtbG9vcCcpKGdyaWQpO1xuICAgIGdyaWQuZGVjb3JhdG9ycyA9IHJlcXVpcmUoJy4uL2RlY29yYXRvcnMnKShncmlkKTtcbiAgICBncmlkLmNlbGxDbGFzc2VzID0gcmVxdWlyZSgnLi4vY2VsbC1jbGFzc2VzJykoZ3JpZCk7XG4gICAgZ3JpZC5yb3dNb2RlbCA9IHJlcXVpcmUoJy4uL3Jvdy1tb2RlbCcpKGdyaWQpO1xuICAgIGdyaWQuY29sTW9kZWwgPSByZXF1aXJlKCcuLi9jb2wtbW9kZWwnKShncmlkKTtcbiAgICBncmlkLmRhdGFNb2RlbCA9IHJlcXVpcmUoJy4uL3NpbXBsZS1kYXRhLW1vZGVsJykoZ3JpZCk7XG4gICAgZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwgPSByZXF1aXJlKCcuLi92aXJ0dWFsLXBpeGVsLWNlbGwtbW9kZWwnKShncmlkKTtcbiAgICBncmlkLmNlbGxTY3JvbGxNb2RlbCA9IHJlcXVpcmUoJy4uL2NlbGwtc2Nyb2xsLW1vZGVsJykoZ3JpZCk7XG4gICAgZ3JpZC5jZWxsTW91c2VNb2RlbCA9IHJlcXVpcmUoJy4uL2NlbGwtbW91c2UtbW9kZWwnKShncmlkKTtcblxuICAgIGdyaWQudmlld1BvcnQgPSByZXF1aXJlKCcuLi92aWV3LXBvcnQnKShncmlkKTtcbiAgICBncmlkLnZpZXdMYXllciA9IHJlcXVpcmUoJy4uL3ZpZXctbGF5ZXInKShncmlkKTtcblxuICAgIC8vdGhpbmdzIHdpdGggbG9naWMgdGhhdCBhbHNvIHJlZ2lzdGVyIGRlY29yYXRvcnMgKHNsaWdodGx5IGxlc3MgY29yZSB0aGFuIHRoZSBvdGhlciBtb2RlbHMpXG4gICAgZ3JpZC5uYXZpZ2F0aW9uTW9kZWwgPSByZXF1aXJlKCcuLi9uYXZpZ2F0aW9uLW1vZGVsJykoZ3JpZCk7XG4gICAgZ3JpZC5waXhlbFNjcm9sbE1vZGVsID0gcmVxdWlyZSgnLi4vcGl4ZWwtc2Nyb2xsLW1vZGVsJykoZ3JpZCk7XG4gICAgZ3JpZC5jb2xSZXNpemUgPSByZXF1aXJlKCcuLi9jb2wtcmVzaXplJykoZ3JpZCk7XG4gICAgZ3JpZC5jb2xSZW9yZGVyID0gcmVxdWlyZSgnLi4vY29sLXJlb3JkZXInKShncmlkKTtcbiAgICBncmlkLnNob3dIaWRkZW5Db2xzID0gcmVxdWlyZSgnLi4vc2hvdy1oaWRkZW4tY29scycpKGdyaWQpO1xuICAgIGdyaWQuY29weVBhc3RlID0gcmVxdWlyZSgnLi4vY29weS1wYXN0ZScpKGdyaWQpO1xuXG4gICAgdmFyIGRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBncmlkLnJlcXVlc3REcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWdyaWQuZXZlbnRMb29wLmlzUnVubmluZykge1xuICAgICAgICAgICAgZ3JpZC52aWV3TGF5ZXIuZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmF3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBncmlkLmV2ZW50TG9vcC5hZGRFeGl0TGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZHJhd1JlcXVlc3RlZCkge1xuICAgICAgICAgICAgZ3JpZC52aWV3TGF5ZXIuZHJhdygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzZXR1cFRleHRhcmVhRm9yQ29udGFpbmVyKHRleHRhcmVhLCBjb250YWluZXIpIHtcbiAgICAgICAgdGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudENsYXNzKGNvbnRhaW5lcikuYWRkKCdmb2N1cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7XG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKCdncmlkLWZvY3VzJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudENsYXNzKGNvbnRhaW5lcikucmVtb3ZlKCdmb2N1cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuZmlyZSgnZ3JpZC1ibHVyJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRleHRhcmVhKSB7XG4gICAgICAgICAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9jdXNUZXh0QXJlYSgpIHtcbiAgICAgICAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGV4dGFyZWEuc2V0QXR0cmlidXRlKCdkdHMnLCAnZ3JpZC10ZXh0YXJlYScpO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAnLTEwMDAwMHB4JztcbiAgICAgICAgcmV0dXJuIHRleHRhcmVhO1xuICAgIH1cblxuICAgIGdyaWQuYnVpbGQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHNldHVwVGV4dGFyZWFGb3JDb250YWluZXIoZ3JpZC50ZXh0YXJlYSwgY29udGFpbmVyKTtcbiAgICAgICAgZ3JpZC52aWV3UG9ydC5zaXplVG9Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgZ3JpZC52aWV3TGF5ZXIuYnVpbGQoY29udGFpbmVyKTtcbiAgICAgICAgZ3JpZC5ldmVudExvb3Auc2V0Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIGdyaWQubWFrZURpcnR5Q2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXJ0eUNsZWFuKGdyaWQpO1xuICAgIH07XG5cbiAgICBncmlkLnRleHRhcmVhID0gY3JlYXRlRm9jdXNUZXh0QXJlYSgpO1xuXG4gICAgcmV0dXJuIGdyaWQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC93aW4vaSkgPyBlLmN0cmxLZXkgOiBlLm1ldGFLZXkpXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCkge1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpOyAgLy8gTVVTVCBiZSAnQ3VzdG9tRXZlbnQnXG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgcmV0dXJuIGV2ZW50O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgZGVsYXkpIHtcbiAgICB2YXIgZiA9IGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgaWYgKGYudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGYudGltZW91dCk7XG4gICAgICAgICAgICBmLnRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZi50aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIGY7XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIG1ha2VEaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKTtcbnZhciBwb3NpdGlvblJhbmdlID0gcmVxdWlyZSgnLi4vcG9zaXRpb24tcmFuZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGRpcnR5Q2xlYW4gPSBtYWtlRGlydHlDbGVhbihncmlkKTtcblxuICAgIHZhciBhbGl2ZURlY29yYXRvcnMgPSBbXTtcbiAgICB2YXIgZGVhZERlY29yYXRvcnMgPSBbXTtcblxuICAgIHZhciBkZWNvcmF0b3JzID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGFsaXZlRGVjb3JhdG9ycy5wdXNoKGRlY29yYXRvcik7XG4gICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc0FycmF5KGRlY29yYXRvcnMpKSB7XG4gICAgICAgICAgICAgICAgZGVjb3JhdG9ycyA9IFtkZWNvcmF0b3JzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29yYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxpdmVEZWNvcmF0b3JzLmluZGV4T2YoZGVjb3JhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaXZlRGVjb3JhdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkZWFkRGVjb3JhdG9ycy5wdXNoKGRlY29yYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5Q2xlYW4uc2V0RGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QWxpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGl2ZURlY29yYXRvcnMuc2xpY2UoMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvcEFsbERlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbGREZWFkID0gZGVhZERlY29yYXRvcnM7XG4gICAgICAgICAgICBkZWFkRGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG9sZERlYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGRpcnR5Q2xlYW4uaXNEaXJ0eSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAodCwgbCwgaCwgdywgdSwgcykge1xuICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IHt9O1xuICAgICAgICAgICAgdmFyIHRoaXNEaXJ0eUNsZWFuID0gbWFrZURpcnR5Q2xlYW4oZ3JpZCk7XG5cbiAgICAgICAgICAgIC8vbWl4aW4gdGhlIHBvc2l0aW9uIHJhbmdlIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgIHBvc2l0aW9uUmFuZ2UoZGVjb3JhdG9yLCB0aGlzRGlydHlDbGVhbiwgZGlydHlDbGVhbik7XG4gICAgICAgICAgICBkZWNvcmF0b3IudG9wID0gdDtcbiAgICAgICAgICAgIGRlY29yYXRvci5sZWZ0ID0gbDtcbiAgICAgICAgICAgIGRlY29yYXRvci5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgZGVjb3JhdG9yLndpZHRoID0gdztcbiAgICAgICAgICAgIGRlY29yYXRvci51bml0cyA9IHUgfHwgZGVjb3JhdG9yLnVuaXRzO1xuICAgICAgICAgICAgZGVjb3JhdG9yLnNwYWNlID0gcyB8fCBkZWNvcmF0b3Iuc3BhY2U7XG5cbiAgICAgICAgICAgIC8vdGhleSBjYW4gb3ZlcnJpZGUgYnV0IHdlIHNob3VsZCBoYXZlIGFuIGVtcHR5IGRlZmF1bHQgdG8gcHJldmVudCBucGVzXG4gICAgICAgICAgICBkZWNvcmF0b3IucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUucmlnaHQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdG9yLnBvc3RSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yLnBvc3RSZW5kZXIoZGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIHJldHVybiBkZWNvcmF0b3JzO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG4gICAgdmFyIGRpcnR5ID0gdHJ1ZTtcblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBpLnNldENsZWFuKCk7XG4gICAgfSk7XG5cblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNDbGVhbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICFkaXJ0eTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vd2hlbiB0aGluZ3MgYXJlIGluaXRhbGl6aW5nIHNvbWV0aW1lcyB0aGlzIGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgICAvL3dlIGhhdmUgdG8gaG9wZSB0aGF0IGF0IHRoZSBlbmQgb2YgaW5pdGlhbGl6YXRpb24gdGhlIGdyaWQgd2lsbCBjYWxsIHJlcXVlc3QgZHJhdyBpdHNlbGZcbiAgICAgICAgICAgIGlmIChncmlkLnJlcXVlc3REcmF3KSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZXF1ZXN0RHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRDbGVhbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbn07IiwidmFyIG1vdXNld2hlZWwgPSByZXF1aXJlKCcuLi9tb3VzZXdoZWVsJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsaXN0ZW5lcnMgPSByZXF1aXJlKCcuLi9saXN0ZW5lcnMnKTtcblxudmFyIEVWRU5UUyA9IFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2Vtb3ZlJywgJ2RibGNsaWNrJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnY29weScsICdwYXN0ZSddO1xuXG52YXIgR1JJRF9FVkVOVFMgPSBbJ2dyaWQtZHJhZy1zdGFydCcsICdncmlkLWRyYWcnLCAnZ3JpZC1jZWxsLWRyYWcnLCAnZ3JpZC1kcmFnLWVuZCddO1xuXG52YXIgZXZlbnRMb29wID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcbiAgICB2YXIgZWxvb3AgPSB7XG4gICAgICAgIGlzUnVubmluZzogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZXJzQnlOYW1lID0ge307XG4gICAgdmFyIGRvbVVuYmluZEZucyA9IFtdO1xuXG4gICAgdmFyIHVuYmluZEFsbDtcblxuICAgIGVsb29wLnNldENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIHVuYmluZE1vdXNlV2hlZWxGbiA9IG1vdXNld2hlZWwuYmluZChjb250YWluZXIsIG1haW5Mb29wKTtcblxuICAgICAgICBFVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgYmluZFRvRG9tRWxlbWVudChjb250YWluZXIsIG5hbWUsIG1haW5Mb29wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgR1JJRF9FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgYmluZFRvRG9tRWxlbWVudCh3aW5kb3csIG5hbWUsIG1haW5Mb29wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdW5iaW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW5iaW5kTW91c2VXaGVlbEZuKCk7XG5cbiAgICAgICAgICAgIC8vaGF2ZSB0byBjb3B5IHRoZSBhcnJheSBzaW5jZSB0aGUgdW5iaW5kIHdpbGwgYWN0dWFsbHkgcmVtb3ZlIGl0c2VsZiBmcm9tIHRoZSBhcnJheSB3aGljaCBtb2RpZmllcyBpdCBtaWQgaXRlcmF0aW9uXG4gICAgICAgICAgICBkb21VbmJpbmRGbnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodW5iaW5kKSB7XG4gICAgICAgICAgICAgICAgdW5iaW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0SGFuZGxlcnMobmFtZSkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBoYW5kbGVyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlcnMgPSBoYW5kbGVyc0J5TmFtZVtuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5kVG9Eb21FbGVtZW50KGVsZW0sIG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHZhciB1bmJpbmRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBkb21VbmJpbmRGbnMuc3BsaWNlKGRvbVVuYmluZEZucy5pbmRleE9mKHVuYmluZEZuKSwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvbVVuYmluZEZucy5wdXNoKHVuYmluZEZuKTtcbiAgICAgICAgcmV0dXJuIHVuYmluZEZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhhbmRsZXJGcm9tQXJncyhhcmdzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICBlbG9vcC5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHZhciBuYW1lID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRIYW5kbGVyRnJvbUFyZ3MoYXJncyk7XG4gICAgICAgIGlmICghaGFuZGxlciB8fCAhbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgJ2Nhbm5vdCBiaW5kIHdpdGhvdXQgYXQgbGVhc3QgbmFtZSBhbmQgZnVuY3Rpb24nO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgZWxlbSA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsLmlzRWxlbWVudChhcmcpIHx8IGFyZyA9PT0gd2luZG93IHx8IGFyZyA9PT0gZG9jdW1lbnQ7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgZ2V0SGFuZGxlcnMobmFtZSkucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMobmFtZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJzLmluZGV4T2YoaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxvb3BXaXRoKGhhbmRsZXIpO1xuICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhlIGVsZW0gY2FuIHJlY2VpdmUgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbmRUb0RvbUVsZW1lbnQoZWxlbSwgbmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGVsb29wLmJpbmRPbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZ2V0SGFuZGxlckZyb21BcmdzKGFyZ3MpO1xuICAgICAgICBhcmdzLnNwbGljZShhcmdzLmluZGV4T2YoaGFuZGxlciksIDEsIGZ1bmN0aW9uIGJpbmRPbmNlSGFuZGxlcihlKSB7XG4gICAgICAgICAgICB1bmJpbmQoKTtcbiAgICAgICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5iaW5kID0gZWxvb3AuYmluZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHVuYmluZDtcbiAgICB9XG5cbiAgICBlbG9vcC5maXJlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50ID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJyA/IHt0eXBlOiBldmVudH0gOiBldmVudDtcbiAgICAgICAgbWFpbkxvb3AoZXZlbnQpO1xuICAgIH07XG5cbiAgICB2YXIgaW50ZXJjZXB0b3JzID0gbGlzdGVuZXJzKCk7XG4gICAgdmFyIGV4aXRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnMoKTtcblxuICAgIGVsb29wLmFkZEludGVyY2VwdG9yID0gaW50ZXJjZXB0b3JzLmFkZExpc3RlbmVyO1xuICAgIGVsb29wLmFkZEV4aXRMaXN0ZW5lciA9IGV4aXRMaXN0ZW5lcnMuYWRkTGlzdGVuZXI7XG5cbiAgICBmdW5jdGlvbiBsb29wV2l0aChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxvb3AoZSwgZm4pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtYWluTG9vcCA9IGxvb3BXaXRoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vaGF2ZSB0byBjb3B5IHRoZSBhcnJheSBiZWNhdXNlIGhhbmRsZXJzIGNhbiB1bmJpbmQgdGhlbXNlbHZlcyB3aGljaCBtb2RpZmllcyB0aGUgYXJyYXlcbiAgICAgICAgLy93ZSB1c2Ugc29tZSBzbyB0aGF0IHdlIGNhbiBicmVhayBvdXQgb2YgdGhlIGxvb3AgaWYgbmVlZCBiZVxuICAgICAgICBnZXRIYW5kbGVycyhlLnR5cGUpLnNsaWNlKDApLnNvbWUoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICAgICAgICBpZiAoZS5ncmlkU3RvcEJ1YmJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9vcChlLCBib2R5Rm4pIHtcbiAgICAgICAgdmFyIGlzT3V0ZXJMb29wUnVubmluZyA9IGVsb29wLmlzUnVubmluZztcbiAgICAgICAgZWxvb3AuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaW50ZXJjZXB0b3JzLm5vdGlmeShlKTtcbiAgICAgICAgaWYgKCFlLmdyaWRTdG9wQnViYmxpbmcpIHtcbiAgICAgICAgICAgIGJvZHlGbihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNPdXRlckxvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICBlbG9vcC5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGV4aXRMaXN0ZW5lcnMubm90aWZ5KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZWxvb3AuYmluZCgnZ3JpZC1kZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB1bmJpbmRBbGwoKTtcbiAgICAgICAgZWxvb3AuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGVsb29wLnN0b3BCdWJibGluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuZ3JpZFN0b3BCdWJibGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG5cbiAgICByZXR1cm4gZWxvb3A7XG59O1xuXG5cbmV2ZW50TG9vcC5FVkVOVFMgPSBFVkVOVFM7XG5ldmVudExvb3AuR1JJRF9FVkVOVFMgPSBHUklEX0VWRU5UUztcbm1vZHVsZS5leHBvcnRzID0gZXZlbnRMb29wOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkLCBtb2RlbCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG5cbiAgICB2YXIgYXBpID0gbW9kZWwgfHwge307XG4gICAgYXBpLl9kZWNvcmF0b3JzID0ge307XG5cbiAgICBmdW5jdGlvbiBtYWtlRGVjb3JhdG9yKGNvbCkge1xuICAgICAgICB2YXIgZGVjb3JhdG9yID0gZ3JpZC5kZWNvcmF0b3JzLmNyZWF0ZSgwLCBjb2wsIDEsIDEsICdjZWxsJywgJ3JlYWwnKTtcblxuXG4gICAgICAgIGRlY29yYXRvci5nZXREZWNvcmF0b3JMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0UmVjdCA9IGRlY29yYXRvci5ib3VuZGluZ0JveCAmJiBkZWNvcmF0b3IuYm91bmRpbmdCb3guZ2V0Q2xpZW50UmVjdHMoKSAmJiBkZWNvcmF0b3IuYm91bmRpbmdCb3guZ2V0Q2xpZW50UmVjdHMoKVswXSB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiBncmlkLnZpZXdQb3J0LnRvR3JpZFgoZmlyc3RSZWN0LmxlZnQpIHx8IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFwaS5hbm5vdGF0ZURlY29yYXRvcikge1xuICAgICAgICAgICAgYXBpLmFubm90YXRlRGVjb3JhdG9yKGRlY29yYXRvcik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgfVxuXG4gICAgYXBpLm1ha2VEZWNvcmF0b3IgPSBhcGkubWFrZURlY29yYXRvciB8fCBtYWtlRGVjb3JhdG9yO1xuXG4gICAgZnVuY3Rpb24gZW5zdXJlRGVjb3JhdG9yUGVyQ29sKCkge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGdyaWQudmlld1BvcnQuY29sczsgYysrKSB7XG4gICAgICAgICAgICBpZiAoIWFwaS5fZGVjb3JhdG9yc1tjXSkge1xuICAgICAgICAgICAgICAgIGlmIChhcGkuaXNOZWVkZWQgJiYgIWFwaS5pc05lZWRlZChjKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGFwaS5tYWtlRGVjb3JhdG9yKGMpO1xuICAgICAgICAgICAgICAgIGFwaS5fZGVjb3JhdG9yc1tjXSA9IGRlY29yYXRvcjtcbiAgICAgICAgICAgICAgICBncmlkLmRlY29yYXRvcnMuYWRkKGRlY29yYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLXZpZXdwb3J0LWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZW5zdXJlRGVjb3JhdG9yUGVyQ29sKCk7XG4gICAgfSk7XG4gICAgZW5zdXJlRGVjb3JhdG9yUGVyQ29sKCk7XG5cbiAgICByZXR1cm4gYXBpO1xufTsiLCIvKlxuIEEgc2ltcGxlIHBhY2thZ2UgZm9yIGNyZWF0aW5nIGEgbGlzdCBvZiBsaXN0ZW5lcnMgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW5kIG5vdGlmaWVkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vcmV0dXJucyBhIHJlbW92YWwgZnVuY3Rpb24gdG8gdW5iaW5kIHRoZSBsaXN0ZW5lclxuICAgICAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChmbik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobGlzdGVuZXJzLmluZGV4T2YoZm4pLCAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufTsiLCJ2YXIgRVZFTlRfTkFNRVMgPSBbJ21vdXNld2hlZWwnLCAnd2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnXTtcblxudmFyIGFwaSA9IHtcbiAgICBnZXREZWx0YTogZnVuY3Rpb24gKGV2ZW50LCB4YXhpcykge1xuICAgICAgICBpZiAoZXZlbnQud2hlZWxEZWx0YSkgeyAvL2ZvciBldmVyeXRoaW5nIGJ1dCBmaXJlZm94XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBldmVudC53aGVlbERlbHRhWTtcbiAgICAgICAgICAgIGlmICh4YXhpcykge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsdGE7XG5cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHsgLy9mb3IgZmlyZWZveCBwcmUgdmVyc2lvbiAxN1xuICAgICAgICAgICAgaWYgKGV2ZW50LmF4aXMgJiYgKChldmVudC5heGlzID09PSAxICYmIHhheGlzKSB8fCAoZXZlbnQuYXhpcyA9PT0gMiAmJiAheGF4aXMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIGV2ZW50LmRldGFpbCAqIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhWCB8fCBldmVudC5kZWx0YVkpIHtcbiAgICAgICAgICAgIGlmICh4YXhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIGV2ZW50LmRlbHRhWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xICogZXZlbnQuZGVsdGFZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvL2JpbmRzIGEgY3Jvc3MgYnJvd3NlciBub3JtYWxpemVkIG1vdXNld2hlZWwgZXZlbnQsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHVuYmluZCB0aGUgbGlzdGVuZXI7XG4gICAgYmluZDogZnVuY3Rpb24gKGVsZW0sIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIobm9ybWFsaXplV2hlZWxFdmVudChlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgRVZFTlRfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIG5vcm1hbGl6ZWRMaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBFVkVOVF9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIG5vcm1hbGl6ZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgIH0sXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVXaGVlbEV2ZW50XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVXaGVlbEV2ZW50KGUpIHtcbiAgICB2YXIgZGVsdGFYID0gYXBpLmdldERlbHRhKGUsIHRydWUpO1xuICAgIHZhciBkZWx0YVkgPSBhcGkuZ2V0RGVsdGEoZSk7XG4gICAgdmFyIG5ld0V2ZW50ID0gT2JqZWN0LmNyZWF0ZShlLFxuICAgICAgICB7XG4gICAgICAgICAgICBkZWx0YVk6IHt2YWx1ZTogZGVsdGFZfSxcbiAgICAgICAgICAgIGRlbHRhWDoge3ZhbHVlOiBkZWx0YVh9LFxuICAgICAgICAgICAgdHlwZToge3ZhbHVlOiAnbW91c2V3aGVlbCd9XG4gICAgICAgIH0pO1xuXG4gICAgbmV3RXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5ld0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBuZXdFdmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcGk7IiwidmFyIGtleSA9IHJlcXVpcmUoJ2tleScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcmFuZ2VVdGlsID0gcmVxdWlyZSgnLi4vcmFuZ2UtdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG5cbiAgICB2YXIgbW9kZWwgPSB7XG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICBjb2w6IDBcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZm9jdXNDbGFzcyA9IGdyaWQuY2VsbENsYXNzZXMuY3JlYXRlKDAsIDAsICdmb2N1cycpO1xuICAgIGdyaWQuY2VsbENsYXNzZXMuYWRkKGZvY3VzQ2xhc3MpO1xuXG4gICAgbW9kZWwuZm9jdXNEZWNvcmF0b3IgPSBncmlkLmRlY29yYXRvcnMuY3JlYXRlKDAsIDAsIDEsIDEpO1xuICAgIG1vZGVsLmZvY3VzRGVjb3JhdG9yLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRlZmF1bHRSZW5kZXIoKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1mb2N1cy1kZWNvcmF0b3InKTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9O1xuICAgIGdyaWQuZGVjb3JhdG9ycy5hZGQobW9kZWwuZm9jdXNEZWNvcmF0b3IpO1xuXG5cbiAgICBmdW5jdGlvbiBjbGFtcFJvd1RvTWluTWF4KHJvdykge1xuICAgICAgICByZXR1cm4gdXRpbC5jbGFtcChyb3csIDAsIGdyaWQucm93TW9kZWwubGVuZ3RoKCkgLSAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENvbFRvTWluTWF4KGNvbCkge1xuICAgICAgICByZXR1cm4gdXRpbC5jbGFtcChjb2wsIDAsIGdyaWQuY29sTW9kZWwubGVuZ3RoKCkgLSAxKTtcbiAgICB9XG5cbiAgICBtb2RlbC5zZXRGb2N1cyA9IGZ1bmN0aW9uIHNldEZvY3VzKHJvdywgY29sLCBvcHRpb25hbEV2ZW50KSB7XG4gICAgICAgIHJvdyA9IGNsYW1wUm93VG9NaW5NYXgocm93KTtcbiAgICAgICAgY29sID0gY2xhbXBDb2xUb01pbk1heChjb2wpO1xuICAgICAgICBtb2RlbC5mb2N1cy5yb3cgPSByb3c7XG4gICAgICAgIG1vZGVsLmZvY3VzLmNvbCA9IGNvbDtcbiAgICAgICAgZm9jdXNDbGFzcy50b3AgPSByb3c7XG4gICAgICAgIGZvY3VzQ2xhc3MubGVmdCA9IGNvbDtcbiAgICAgICAgbW9kZWwuZm9jdXNEZWNvcmF0b3IudG9wID0gcm93O1xuICAgICAgICBtb2RlbC5mb2N1c0RlY29yYXRvci5sZWZ0ID0gY29sO1xuICAgICAgICBncmlkLmNlbGxTY3JvbGxNb2RlbC5zY3JvbGxJbnRvVmlldyhyb3csIGNvbCk7XG4gICAgICAgIC8vZm9jdXMgY2hhbmdlcyBhbHdheXMgY2xlYXIgdGhlIHNlbGVjdGlvblxuICAgICAgICBjbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGFycm93ID0ga2V5LmNvZGUuYXJyb3c7XG4gICAgICAgIGlmICgha2V5LmlzKGFycm93LCBlLndoaWNoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vZm9jdXMgbG9naWNcblxuICAgICAgICBpZiAoIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIC8vaWYgbm90aGluZyBjaGFuZ2VzIGdyZWF0IHdlJ2xsIHN0YXkgd2hlcmUgd2UgYXJlXG4gICAgICAgICAgICB2YXIgbmF2VG9Sb3cgPSBtb2RlbC5mb2N1cy5yb3c7XG4gICAgICAgICAgICB2YXIgbmF2VG9Db2wgPSBtb2RlbC5mb2N1cy5jb2w7XG5cblxuICAgICAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBhcnJvdy5kb3duLmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIG5hdlRvUm93Kys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYXJyb3cudXAuY29kZTpcbiAgICAgICAgICAgICAgICAgICAgbmF2VG9Sb3ctLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBhcnJvdy5yaWdodC5jb2RlOlxuICAgICAgICAgICAgICAgICAgICBuYXZUb0NvbCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGFycm93LmxlZnQuY29kZTpcbiAgICAgICAgICAgICAgICAgICAgbmF2VG9Db2wtLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbC5zZXRGb2N1cyhuYXZUb1JvdywgbmF2VG9Db2wsIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9zZWxlY3Rpb24gbG9naWNcbiAgICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb247XG4gICAgICAgICAgICAvL3N0YW5kIGluIGZvciBpZiBpdCdzIGNsZWFyZWRcbiAgICAgICAgICAgIGlmIChtb2RlbC5zZWxlY3Rpb24udG9wID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbiA9IHt0b3A6IG1vZGVsLmZvY3VzLnJvdywgbGVmdDogbW9kZWwuZm9jdXMuY29sLCBoZWlnaHQ6IDEsIHdpZHRoOiAxfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IG1vZGVsLnNlbGVjdGlvbi50b3AsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1vZGVsLnNlbGVjdGlvbi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG1vZGVsLnNlbGVjdGlvbi5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtb2RlbC5zZWxlY3Rpb24ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGFycm93LmRvd24uY29kZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmZvY3VzLnJvdyA9PT0gbmV3U2VsZWN0aW9uLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmhlaWdodCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLnRvcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmhlaWdodC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYXJyb3cudXAuY29kZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmZvY3VzLnJvdyA9PT0gbmV3U2VsZWN0aW9uLnRvcCArIG5ld1NlbGVjdGlvbi5oZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24udG9wLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24uaGVpZ2h0Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24uaGVpZ2h0LS07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGFycm93LnJpZ2h0LmNvZGU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5mb2N1cy5jb2wgPT09IG5ld1NlbGVjdGlvbi5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24ud2lkdGgrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5sZWZ0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24ud2lkdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGFycm93LmxlZnQuY29kZTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmZvY3VzLmNvbCA9PT0gbmV3U2VsZWN0aW9uLmxlZnQgKyBuZXdTZWxlY3Rpb24ud2lkdGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24ubGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLndpZHRoKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24ud2lkdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb24uaGVpZ2h0ID09PSAxICYmIG5ld1NlbGVjdGlvbi53aWR0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG91dHNpZGVNaW5NYXgocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHJvdyA8IDAgfHwgcm93ID4gZ3JpZC5yb3dNb2RlbC5sZW5ndGgoKSB8fCBjb2wgPCAwIHx8IGNvbCA+IGdyaWQuY29sTW9kZWwubGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy9hc3N1bWUgdGhlIGV2ZW50IGhhcyBiZWVuIGFubm90YXRlZCBieSB0aGUgY2VsbCBtb3VzZSBtb2RlbCBpbnRlcmNlcHRvclxuICAgICAgICB2YXIgcm93ID0gZS5yb3c7XG4gICAgICAgIHZhciBjb2wgPSBlLmNvbDtcbiAgICAgICAgaWYgKHJvdyA8IDAgJiYgY29sID49IDApIHtcbiAgICAgICAgICAgIGdyaWQuY29sTW9kZWwudG9nZ2xlU2VsZWN0KGNvbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbCA8IDAgJiYgcm93ID49IDApIHtcbiAgICAgICAgICAgIGdyaWQucm93TW9kZWwudG9nZ2xlU2VsZWN0KHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93IDwgMCAmJiBjb2wgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIG1vZGVsLnNldEZvY3VzKHJvdywgY29sLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbkZyb21Qb2ludHMobW9kZWwuZm9jdXMucm93LCBtb2RlbC5mb2N1cy5jb2wsIHJvdywgY29sKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2RlbC5fcm93U2VsZWN0aW9uQ2xhc3NlcyA9IFtdO1xuICAgIG1vZGVsLl9jb2xTZWxlY3Rpb25DbGFzc2VzID0gW107XG4gICAgLy9yb3cgY29sIHNlbGVjdGlvblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJvd0NvbFNlbGVjdGlvbkNoYW5nZShyb3dPckNvbCkge1xuICAgICAgICB2YXIgZGVjb3JhdG9yc0ZpZWxkID0gKCdfJyArIHJvd09yQ29sICsgJ1NlbGVjdGlvbkNsYXNzZXMnKTtcbiAgICAgICAgbW9kZWxbZGVjb3JhdG9yc0ZpZWxkXS5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb25EZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGdyaWQuY2VsbENsYXNzZXMucmVtb3ZlKHNlbGVjdGlvbkRlY29yYXRvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBtb2RlbFtkZWNvcmF0b3JzRmllbGRdID0gW107XG5cbiAgICAgICAgZ3JpZFtyb3dPckNvbCArICdNb2RlbCddLmdldFNlbGVjdGVkKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB2aXJ0dWFsSW5kZXggPSBncmlkW3Jvd09yQ29sICsgJ01vZGVsJ10udG9WaXJ0dWFsKGluZGV4KTtcbiAgICAgICAgICAgIHZhciB0b3AgPSByb3dPckNvbCA9PT0gJ3JvdycgPyB2aXJ0dWFsSW5kZXggOiAwO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSByb3dPckNvbCA9PT0gJ2NvbCcgPyB2aXJ0dWFsSW5kZXggOiAwO1xuICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGdyaWQuY2VsbENsYXNzZXMuY3JlYXRlKHRvcCwgbGVmdCwgJ3NlbGVjdGVkJywgMSwgMSwgJ3ZpcnR1YWwnKTtcbiAgICAgICAgICAgIGdyaWQuY2VsbENsYXNzZXMuYWRkKGRlY29yYXRvcik7XG4gICAgICAgICAgICBtb2RlbFtkZWNvcmF0b3JzRmllbGRdLnB1c2goZGVjb3JhdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1yb3ctc2VsZWN0aW9uLWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFuZGxlUm93Q29sU2VsZWN0aW9uQ2hhbmdlKCdyb3cnKTtcbiAgICB9KTtcblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtY29sLXNlbGVjdGlvbi1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbmRsZVJvd0NvbFNlbGVjdGlvbkNoYW5nZSgnY29sJyk7XG4gICAgfSk7XG5cbiAgICB2YXIgc2VsZWN0aW9uID0gZ3JpZC5kZWNvcmF0b3JzLmNyZWF0ZSgpO1xuXG4gICAgdmFyIGRlZmF1bHRSZW5kZXIgPSBzZWxlY3Rpb24ucmVuZGVyO1xuICAgIHNlbGVjdGlvbi5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkZWZhdWx0UmVuZGVyKCk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2dyaWQtc2VsZWN0aW9uJyk7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfTtcblxuICAgIGdyaWQuZGVjb3JhdG9ycy5hZGQoc2VsZWN0aW9uKTtcblxuICAgIG1vZGVsLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLnRvcCA9IG5ld1NlbGVjdGlvbi50b3A7XG4gICAgICAgIHNlbGVjdGlvbi5sZWZ0ID0gbmV3U2VsZWN0aW9uLmxlZnQ7XG4gICAgICAgIHNlbGVjdGlvbi5oZWlnaHQgPSBuZXdTZWxlY3Rpb24uaGVpZ2h0O1xuICAgICAgICBzZWxlY3Rpb24ud2lkdGggPSBuZXdTZWxlY3Rpb24ud2lkdGg7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgICBtb2RlbC5zZXRTZWxlY3Rpb24oe3RvcDogLTEsIGxlZnQ6IC0xLCBoZWlnaHQ6IC0xLCB3aWR0aDogLTF9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Gcm9tUG9pbnRzKGZyb21Sb3csIGZyb21Db2wsIHRvUm93LCB0b0NvbCkge1xuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gcmFuZ2VVdGlsLmNyZWF0ZUZyb21Qb2ludHMoZnJvbVJvdywgZnJvbUNvbCwgY2xhbXBSb3dUb01pbk1heCh0b1JvdyksIGNsYW1wQ29sVG9NaW5NYXgodG9Db2wpKTtcbiAgICAgICAgbW9kZWwuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChvdXRzaWRlTWluTWF4KGUucm93LCBlLmNvbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVJvdyA9IG1vZGVsLmZvY3VzLnJvdztcbiAgICAgICAgdmFyIGZyb21Db2wgPSBtb2RlbC5mb2N1cy5jb2w7XG4gICAgICAgIHZhciB1bmJpbmREcmFnID0gZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1jZWxsLWRyYWcnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uRnJvbVBvaW50cyhmcm9tUm93LCBmcm9tQ29sLCBlLnJvdywgZS5jb2wpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdW5iaW5kRHJhZ0VuZCA9IGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhZy1lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1bmJpbmREcmFnKCk7XG4gICAgICAgICAgICB1bmJpbmREcmFnRW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWRyYWctc3RhcnQnLCBzZWxlY3Rpb24uX29uRHJhZ1N0YXJ0KTtcbiAgICBjbGVhclNlbGVjdGlvbigpO1xuXG4gICAgbW9kZWwuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2Egbm9vcCBmdW5jdGlvbiB0byB1c2Vcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuLi9kZWJvdW5jZScpO1xudmFyIGNhcGl0YWxpemUgPSByZXF1aXJlKCdjYXBpdGFsaXplJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcbiAgICB2YXIgbW9kZWwgPSB7dG9wOiAwLCBsZWZ0OiAwLCBtYXhTY3JvbGw6IHt9fTtcbiAgICB2YXIgc2Nyb2xsQmFyV2lkdGggPSAxMDtcblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtdmlydHVhbC1waXhlbC1jZWxsLWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLnRvdGFsSGVpZ2h0KCkgLSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5maXhlZEhlaWdodCgpO1xuICAgICAgICB2YXIgc2Nyb2xsV2lkdGggPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC50b3RhbFdpZHRoKCkgLSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5maXhlZFdpZHRoKCk7XG4gICAgICAgIG1vZGVsLnNldFNjcm9sbFNpemUoc2Nyb2xsSGVpZ2h0LCBzY3JvbGxXaWR0aCk7XG4gICAgICAgIGNhY2hlTWF4U2Nyb2xsKCk7XG4gICAgICAgIHNpemVTY3JvbGxCYXJzKCk7XG4gICAgfSk7XG5cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtdmlld3BvcnQtY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWNoZU1heFNjcm9sbCgpO1xuICAgICAgICBzaXplU2Nyb2xsQmFycygpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY2FjaGVNYXhTY3JvbGwoKSB7XG4gICAgICAgIG1vZGVsLm1heFNjcm9sbC5oZWlnaHQgPSBnZXRNYXhTY3JvbGwoJ2hlaWdodCcpO1xuICAgICAgICBtb2RlbC5tYXhTY3JvbGwud2lkdGggPSBnZXRNYXhTY3JvbGwoJ3dpZHRoJyk7XG4gICAgfVxuXG4gICAgLy9hc3N1bWVzIGEgc3RhbmRhcmRpemVkIHdoZWVsIGV2ZW50IHRoYXQgd2UgY3JlYXRlIHRocm91Z2ggdGhlIG1vdXNld2hlZWwgcGFja2FnZVxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ21vdXNld2hlZWwnLCBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGUpIHtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGUuZGVsdGFZO1xuICAgICAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVg7XG4gICAgICAgIG1vZGVsLnNjcm9sbFRvKG1vZGVsLnRvcCAtIGRlbHRhWSwgbW9kZWwubGVmdCAtIGRlbHRhWCwgdHJ1ZSk7XG4gICAgICAgIGRlYm91bmNlZE5vdGlmeSgpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBtb2RlbC5zZXRTY3JvbGxTaXplID0gZnVuY3Rpb24gKGgsIHcpIHtcbiAgICAgICAgbW9kZWwuaGVpZ2h0ID0gaDtcbiAgICAgICAgbW9kZWwud2lkdGggPSB3O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgICAgIC8vVE9ETzogcG9zc2libHkga2VlcCB0cmFjayBvZiBkZWx0YSBzaW5jZSBsYXN0IHVwZGF0ZSBhbmQgc2VuZCBpdCBhbG9uZy4gZm9yIG5vdywgbm9cbiAgICAgICAgZ3JpZC5ldmVudExvb3AuZmlyZSgnZ3JpZC1waXhlbC1zY3JvbGwnKTtcblxuICAgICAgICAvL3VwZGF0ZSB0aGUgY2VsbCBzY3JvbGxcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IG1vZGVsLnRvcDtcbiAgICAgICAgdmFyIHJvdyA9IGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLmdldFJvdyhzY3JvbGxUb3AgKyBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5maXhlZEhlaWdodCgpKSAtIGdyaWQucm93TW9kZWwubnVtRml4ZWQoKTtcblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IG1vZGVsLmxlZnQ7XG4gICAgICAgIHZhciBjb2wgPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC5nZXRDb2woc2Nyb2xsTGVmdCArIGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLmZpeGVkV2lkdGgoKSkgLSBncmlkLmNvbE1vZGVsLm51bUZpeGVkKCk7XG5cbiAgICAgICAgZ3JpZC5jZWxsU2Nyb2xsTW9kZWwuc2Nyb2xsVG8ocm93LCBjb2wsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGRlYm91bmNlZE5vdGlmeSA9IGRlYm91bmNlKG5vdGlmeUxpc3RlbmVycywgMSk7XG5cbiAgICBtb2RlbC5zY3JvbGxUbyA9IGZ1bmN0aW9uICh0b3AsIGxlZnQsIGRvbnROb3RpZnkpIHtcbiAgICAgICAgbW9kZWwudG9wID0gdXRpbC5jbGFtcCh0b3AsIDAsIG1vZGVsLm1heFNjcm9sbC5oZWlnaHQpO1xuICAgICAgICBtb2RlbC5sZWZ0ID0gdXRpbC5jbGFtcChsZWZ0LCAwLCBtb2RlbC5tYXhTY3JvbGwud2lkdGgpO1xuICAgICAgICBwb3NpdGlvblNjcm9sbEJhcnMoKTtcblxuICAgICAgICBpZiAoIWRvbnROb3RpZnkpIHtcbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycygpO1xuICAgICAgICB9XG5cblxuICAgIH07XG5cblxuICAgIC8qIFNDUk9MTCBCQVIgTE9HSUMgKi9cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbkZyb21SZWFsKHNjcm9sbEJhclJlYWxDbGlja0Nvb3JkLCBoZWlnaHRXaWR0aCwgdmVydEhvcnopIHtcbiAgICAgICAgdmFyIHNjcm9sbEJhclRvcENsaWNrID0gc2Nyb2xsQmFyUmVhbENsaWNrQ29vcmQgLSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFsnZml4ZWQnICsgY2FwaXRhbGl6ZShoZWlnaHRXaWR0aCldKCk7XG4gICAgICAgIHZhciBzY3JvbGxSYXRpbyA9IHNjcm9sbEJhclRvcENsaWNrIC8gZ2V0TWF4U2Nyb2xsQmFyQ29vcmQoaGVpZ2h0V2lkdGgsIHZlcnRIb3J6KTtcbiAgICAgICAgdmFyIHNjcm9sbENvb3JkID0gc2Nyb2xsUmF0aW8gKiBtb2RlbC5tYXhTY3JvbGxbaGVpZ2h0V2lkdGhdO1xuICAgICAgICByZXR1cm4gc2Nyb2xsQ29vcmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVNjcm9sbEJhckRlY29yYXRvcihpc0hvcnopIHtcbiAgICAgICAgdmFyIGRlY29yYXRvciA9IGdyaWQuZGVjb3JhdG9ycy5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHhPclkgPSBpc0hvcnogPyAnWCcgOiAnWSc7XG4gICAgICAgIHZhciBoZWlnaHRXaWR0aCA9IGlzSG9yeiA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgdmFyIHZlcnRIb3J6ID0gaXNIb3J6ID8gJ2hvcnonIDogJ3ZlcnQnO1xuICAgICAgICB2YXIgZ3JpZENvb3JkRmllbGQgPSAnZ3JpZCcgKyB4T3JZO1xuICAgICAgICB2YXIgbGF5ZXJDb29yZEZpZWxkID0gJ2xheWVyJyArIHhPclk7XG4gICAgICAgIHZhciB2aWV3UG9ydENsYW1wRm4gPSBncmlkLnZpZXdQb3J0WydjbGFtcCcgKyB4T3JZXTtcblxuICAgICAgICBkZWNvcmF0b3IucG9zdFJlbmRlciA9IGZ1bmN0aW9uIChzY3JvbGxCYXJFbGVtKSB7XG4gICAgICAgICAgICBzY3JvbGxCYXJFbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1zY3JvbGwtYmFyJyk7XG4gICAgICAgICAgICBkZWNvcmF0b3IuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHNjcm9sbEJhckVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQmFyT2Zmc2V0ID0gZVtsYXllckNvb3JkRmllbGRdO1xuXG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yLl91bmJpbmREcmFnID0gZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyaWRDb29yZCA9IHZpZXdQb3J0Q2xhbXBGbihlW2dyaWRDb29yZEZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxCYXJSZWFsQ2xpY2tDb29yZCA9IGdyaWRDb29yZCAtIHNjcm9sbEJhck9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbENvb3JkID0gZ2V0U2Nyb2xsUG9zaXRpb25Gcm9tUmVhbChzY3JvbGxCYXJSZWFsQ2xpY2tDb29yZCwgaGVpZ2h0V2lkdGgsIHZlcnRIb3J6KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSG9yeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2Nyb2xsVG8obW9kZWwudG9wLCBzY3JvbGxDb29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zY3JvbGxUbyhzY3JvbGxDb29yZCwgbW9kZWwubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlY29yYXRvci5fdW5iaW5kRHJhZ0VuZCA9IGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZHJhZy1lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3IuX3VuYmluZERyYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yLl91bmJpbmREcmFnRW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kcmFnLXN0YXJ0Jywgc2Nyb2xsQmFyRWxlbSwgZGVjb3JhdG9yLl9vbkRyYWdTdGFydCk7XG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdtb3VzZWRvd24nLCBzY3JvbGxCYXJFbGVtLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGdyaWQuZXZlbnRMb29wLnN0b3BCdWJibGluZyhlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsQmFyRWxlbTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZWNvcmF0b3IudW5pdHMgPSAncHgnO1xuICAgICAgICBkZWNvcmF0b3Iuc3BhY2UgPSAncmVhbCc7XG5cbiAgICAgICAgcmV0dXJuIGRlY29yYXRvcjtcbiAgICB9XG5cbiAgICBtb2RlbC52ZXJ0U2Nyb2xsQmFyID0gbWFrZVNjcm9sbEJhckRlY29yYXRvcigpO1xuICAgIG1vZGVsLmhvcnpTY3JvbGxCYXIgPSBtYWtlU2Nyb2xsQmFyRGVjb3JhdG9yKHRydWUpO1xuICAgIG1vZGVsLnZlcnRTY3JvbGxCYXIud2lkdGggPSBzY3JvbGxCYXJXaWR0aDtcbiAgICBtb2RlbC5ob3J6U2Nyb2xsQmFyLmhlaWdodCA9IHNjcm9sbEJhcldpZHRoO1xuXG4gICAgZnVuY3Rpb24gZ2V0TWF4U2Nyb2xsKGhlaWdodFdpZHRoKSB7XG4gICAgICAgIHZhciByb3dPckNvbCA9IGhlaWdodFdpZHRoID09PSAnaGVpZ2h0JyA/ICdyb3cnIDogJ2NvbCc7XG4gICAgICAgIHZhciBzY3JvbGxMZW5ndGggPSBtb2RlbFtoZWlnaHRXaWR0aF07XG4gICAgICAgIHZhciB2aWV3U2Nyb2xsSGVpZ2h0T3JXaWR0aCA9IGdldFZpZXdTY3JvbGxIZWlnaHRPcldpZHRoKGhlaWdodFdpZHRoKTtcbiAgICAgICAgdmFyIGZpcnN0U2Nyb2xsYWJsZUNlbGwgPSBncmlkW3Jvd09yQ29sICsgJ01vZGVsJ10ubnVtRml4ZWQoKTtcbiAgICAgICAgd2hpbGUgKHNjcm9sbExlbmd0aCA+IHZpZXdTY3JvbGxIZWlnaHRPcldpZHRoIC0gMTApIHtcbiAgICAgICAgICAgIHNjcm9sbExlbmd0aCAtPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFtoZWlnaHRXaWR0aF0oZmlyc3RTY3JvbGxhYmxlQ2VsbCk7XG4gICAgICAgICAgICBmaXJzdFNjcm9sbGFibGVDZWxsKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsW2hlaWdodFdpZHRoXSAtIHNjcm9sbExlbmd0aDtcbiAgICB9XG5cbiAgICBtb2RlbC5fZ2V0TWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsO1xuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsUmF0aW9Gcm9tVmlydHVhbFNjcm9sbENvb3JkcyhzY3JvbGwsIGhlaWdodFdpZHRoKSB7XG4gICAgICAgIHZhciBtYXhTY3JvbGwgPSBtb2RlbC5tYXhTY3JvbGxbaGVpZ2h0V2lkdGhdO1xuICAgICAgICB2YXIgc2Nyb2xsUmF0aW8gPSBzY3JvbGwgLyBtYXhTY3JvbGw7XG4gICAgICAgIHJldHVybiBzY3JvbGxSYXRpbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhTY3JvbGxCYXJDb29yZChoZWlnaHRXaWR0aCwgdmVydEhvcnopIHtcbiAgICAgICAgcmV0dXJuIGdldFZpZXdTY3JvbGxIZWlnaHRPcldpZHRoKGhlaWdodFdpZHRoKSAtIG1vZGVsW3ZlcnRIb3J6ICsgJ1Njcm9sbEJhciddW2hlaWdodFdpZHRoXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZWFsU2Nyb2xsQmFyUG9zaXRpb24oc2Nyb2xsLCBoZWlnaHRXaWR0aCwgdmVydEhvcnopIHtcbiAgICAgICAgdmFyIHNjcm9sbFJhdGlvID0gZ2V0U2Nyb2xsUmF0aW9Gcm9tVmlydHVhbFNjcm9sbENvb3JkcyhzY3JvbGwsIGhlaWdodFdpZHRoKTtcbiAgICAgICAgdmFyIG1heFNjcm9sbEJhclNjcm9sbCA9IGdldE1heFNjcm9sbEJhckNvb3JkKGhlaWdodFdpZHRoLCB2ZXJ0SG9yeik7XG4gICAgICAgIC8vaW4gc2Nyb2xsIGJhciBjb29yZHNcbiAgICAgICAgdmFyIHNjcm9sbEJhckNvb3JkID0gc2Nyb2xsUmF0aW8gKiBtYXhTY3JvbGxCYXJTY3JvbGw7XG4gICAgICAgIC8vYWRkIHRoZSBmaXhlZCBoZWlnaHQgdG8gdHJhbnNsYXRlIGJhY2sgaW50byByZWFsIGNvb3Jkc1xuICAgICAgICByZXR1cm4gc2Nyb2xsQmFyQ29vcmQgKyBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFsnZml4ZWQnICsgY2FwaXRhbGl6ZShoZWlnaHRXaWR0aCldKCk7XG4gICAgfVxuXG4gICAgbW9kZWwuX2dldFJlYWxTY3JvbGxCYXJQb3NpdGlvbiA9IGdldFJlYWxTY3JvbGxCYXJQb3NpdGlvbjtcbiAgICBtb2RlbC5fZ2V0U2Nyb2xsUG9zaXRpb25Gcm9tUmVhbCA9IGdldFNjcm9sbFBvc2l0aW9uRnJvbVJlYWw7XG5cbiAgICBmdW5jdGlvbiBjYWxjU2Nyb2xsQmFyUmVhbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlYWxTY3JvbGxCYXJQb3NpdGlvbihtb2RlbC50b3AsICdoZWlnaHQnLCAndmVydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNTY3JvbGxCYXJSZWFsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlYWxTY3JvbGxCYXJQb3NpdGlvbihtb2RlbC5sZWZ0LCAnd2lkdGgnLCAnaG9yeicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uU2Nyb2xsQmFycygpIHtcbiAgICAgICAgbW9kZWwudmVydFNjcm9sbEJhci50b3AgPSBjYWxjU2Nyb2xsQmFyUmVhbFRvcCgpO1xuICAgICAgICBtb2RlbC5ob3J6U2Nyb2xsQmFyLmxlZnQgPSBjYWxjU2Nyb2xsQmFyUmVhbExlZnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3U2Nyb2xsSGVpZ2h0T3JXaWR0aChoZWlnaHRXaWR0aCkge1xuICAgICAgICByZXR1cm4gZ3JpZC52aWV3UG9ydFtoZWlnaHRXaWR0aF0gLSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFsnZml4ZWQnICsgY2FwaXRhbGl6ZShoZWlnaHRXaWR0aCldKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZVZpZXdXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZpZXdTY3JvbGxIZWlnaHRPcldpZHRoKCd3aWR0aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbGFibGVWaWV3SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Vmlld1Njcm9sbEhlaWdodE9yV2lkdGgoJ2hlaWdodCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpemVTY3JvbGxCYXJzKCkge1xuICAgICAgICBtb2RlbC52ZXJ0U2Nyb2xsQmFyLmxlZnQgPSBncmlkLnZpZXdQb3J0LndpZHRoIC0gc2Nyb2xsQmFyV2lkdGg7XG4gICAgICAgIG1vZGVsLmhvcnpTY3JvbGxCYXIudG9wID0gZ3JpZC52aWV3UG9ydC5oZWlnaHQgLSBzY3JvbGxCYXJXaWR0aDtcbiAgICAgICAgdmFyIHNjcm9sbGFibGVWaWV3SGVpZ2h0ID0gZ2V0U2Nyb2xsYWJsZVZpZXdIZWlnaHQoKTtcbiAgICAgICAgdmFyIHNjcm9sbGFibGVWaWV3V2lkdGggPSBnZXRTY3JvbGxhYmxlVmlld1dpZHRoKCk7XG4gICAgICAgIG1vZGVsLnZlcnRTY3JvbGxCYXIuaGVpZ2h0ID0gTWF0aC5tYXgoc2Nyb2xsYWJsZVZpZXdIZWlnaHQgLyBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC50b3RhbEhlaWdodCgpICogc2Nyb2xsYWJsZVZpZXdIZWlnaHQsIDIwKTtcbiAgICAgICAgbW9kZWwuaG9yelNjcm9sbEJhci53aWR0aCA9IE1hdGgubWF4KHNjcm9sbGFibGVWaWV3V2lkdGggLyBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC50b3RhbFdpZHRoKCkgKiBzY3JvbGxhYmxlVmlld1dpZHRoLCAyMCk7XG4gICAgICAgIHBvc2l0aW9uU2Nyb2xsQmFycygpO1xuICAgIH1cblxuICAgIGdyaWQuZGVjb3JhdG9ycy5hZGQobW9kZWwudmVydFNjcm9sbEJhcik7XG4gICAgZ3JpZC5kZWNvcmF0b3JzLmFkZChtb2RlbC5ob3J6U2Nyb2xsQmFyKTtcbiAgICAvKiBFTkQgU0NST0xMIEJBUiBMT0dJQyAqL1xuXG4gICAgcmV0dXJuIG1vZGVsO1xufTsiLCJ2YXIgYWRkRGlydHlQcm9wcyA9IHJlcXVpcmUoJy4uL2FkZC1kaXJ0eS1wcm9wcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmFuZ2UsIGRpcnR5Q2xlYW4sIHBhcmVudERpcnR5Q2xlYW4pIHtcbiAgICByYW5nZSA9IHJhbmdlIHx8IHt9OyAvL2FsbG93IG1peGluIGZ1bmN0aW9uYWxpdHlcbiAgICByYW5nZS5pc0RpcnR5ID0gZGlydHlDbGVhbi5pc0RpcnR5O1xuXG4gICAgdmFyIHdhdGNoZWRQcm9wZXJ0aWVzID0gWyd0b3AnLCAnbGVmdCcsICdoZWlnaHQnLCAnd2lkdGgnLCAndW5pdHMnLCAnc3BhY2UnXTtcbiAgICB2YXIgZGlydHlDbGVhbnMgPSBbZGlydHlDbGVhbl07XG4gICAgaWYgKHBhcmVudERpcnR5Q2xlYW4pIHtcbiAgICAgICAgZGlydHlDbGVhbnMucHVzaChwYXJlbnREaXJ0eUNsZWFuKTtcbiAgICB9XG5cbiAgICBhZGREaXJ0eVByb3BzKHJhbmdlLCB3YXRjaGVkUHJvcGVydGllcywgZGlydHlDbGVhbnMpO1xuICAgIC8vZGVmYXVsdHNcbiAgICByYW5nZS51bml0cyA9ICdjZWxsJztcbiAgICByYW5nZS5zcGFjZSA9ICdkYXRhJztcblxuICAgIHJldHVybiByYW5nZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy90YWtlcyBhIHBvaW50IGFuZCBhIGxlbmd0aCBhcyB0aGUgcmFuZ2VzIGluIGFycmF5IGZvcm1cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChyYW5nZTEsIHJhbmdlMikge1xuICAgICAgICB2YXIgcmFuZ2UyU3RhcnQgPSByYW5nZTJbMF07XG4gICAgICAgIHZhciByYW5nZTFTdGFydCA9IHJhbmdlMVswXTtcbiAgICAgICAgdmFyIHJhbmdlMUVuZCA9IHJhbmdlMVN0YXJ0ICsgcmFuZ2UxWzFdIC0gMTtcbiAgICAgICAgdmFyIHJhbmdlMkVuZCA9IHJhbmdlMlN0YXJ0ICsgcmFuZ2UyWzFdIC0gMTtcbiAgICAgICAgaWYgKHJhbmdlMlN0YXJ0ID4gcmFuZ2UxRW5kIHx8IHJhbmdlMkVuZCA8IHJhbmdlMVN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0U3RhcnQgPSAocmFuZ2UxU3RhcnQgPiByYW5nZTJTdGFydCA/IHJhbmdlMVN0YXJ0IDogcmFuZ2UyU3RhcnQpO1xuICAgICAgICB2YXIgcmVzdWx0RW5kID0gKHJhbmdlMUVuZCA8IHJhbmdlMkVuZCA/IHJhbmdlMUVuZCA6IHJhbmdlMkVuZCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICByZXN1bHRTdGFydCxcbiAgICAgICAgICAgIHJlc3VsdEVuZCAtIHJlc3VsdFN0YXJ0ICsgMVxuICAgICAgICBdO1xuICAgIH0sXG4gICAgLy90YWtlcyBhIHBvaW50IGFuZCBhIGxlbmd0aCBhcyB0aGUgcmFuZ2VzIGluIGFycmF5IGZvcm1cbiAgICB1bmlvbjogZnVuY3Rpb24gKHJhbmdlMSwgcmFuZ2UyKSB7XG4gICAgICAgIGlmICghcmFuZ2UxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZTJTdGFydCA9IHJhbmdlMlswXTtcbiAgICAgICAgdmFyIHJhbmdlMkVuZCA9IHJhbmdlMlN0YXJ0ICsgcmFuZ2UyWzFdIC0gMTtcbiAgICAgICAgdmFyIHJhbmdlMVN0YXJ0ID0gcmFuZ2UxWzBdO1xuICAgICAgICB2YXIgcmFuZ2UxRW5kID0gcmFuZ2UxU3RhcnQgKyByYW5nZTFbMV0gLSAxO1xuICAgICAgICB2YXIgcmVzdWx0U3RhcnQgPSAocmFuZ2UxU3RhcnQgPCByYW5nZTJTdGFydCA/IHJhbmdlMVN0YXJ0IDogcmFuZ2UyU3RhcnQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmVzdWx0U3RhcnQsXG4gICAgICAgICAgICAocmFuZ2UxRW5kID4gcmFuZ2UyRW5kID8gcmFuZ2UxRW5kIDogcmFuZ2UyRW5kKSAtIHJlc3VsdFN0YXJ0ICsgMVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvL3Rha2VzIHR3byByb3csIGNvbCBwb2ludHMgYW5kIGNyZWF0ZXMgYSBub3JtYWwgcG9zaXRpb24gcmFuZ2VcbiAgICBjcmVhdGVGcm9tUG9pbnRzOiBmdW5jdGlvbiAocjEsIGMxLCByMiwgYzIpIHtcbiAgICAgICAgdmFyIHJhbmdlID0ge307XG4gICAgICAgIGlmIChyMSA8IHIyKSB7XG4gICAgICAgICAgICByYW5nZS50b3AgPSByMTtcbiAgICAgICAgICAgIHJhbmdlLmhlaWdodCA9IHIyIC0gcjEgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UudG9wID0gcjI7XG4gICAgICAgICAgICByYW5nZS5oZWlnaHQgPSByMSAtIHIyICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjMSA8IGMyKSB7XG4gICAgICAgICAgICByYW5nZS5sZWZ0ID0gYzE7XG4gICAgICAgICAgICByYW5nZS53aWR0aCA9IGMyIC0gYzEgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UubGVmdCA9IGMyO1xuICAgICAgICAgICAgcmFuZ2Uud2lkdGggPSBjMSAtIGMyICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSxcbiAgICBpdGVyYXRlOiBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGNlbGxGbjtcbiAgICAgICAgdmFyIHJvd0ZuO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY2VsbEZuID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGNlbGxGbiA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIHJvd0ZuID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHIgPSByYW5nZS50b3A7IHIgPCByYW5nZS50b3AgKyByYW5nZS5oZWlnaHQ7IHIrKykge1xuICAgICAgICAgICAgdmFyIHJvd1Jlc3VsdDtcbiAgICAgICAgICAgIGlmIChyb3dGbikge1xuICAgICAgICAgICAgICAgIHJvd1Jlc3VsdCA9IHJvd0ZuKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IHJhbmdlLmxlZnQ7IGMgPCByYW5nZS5sZWZ0ICsgcmFuZ2Uud2lkdGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbEZuKHIsIGMsIHJvd1Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2dyaWQpIHtcbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuXG4gICAgdmFyIGFwaSA9IHJlcXVpcmUoJy4uL2Fic3RyYWN0LXJvdy1jb2wtbW9kZWwnKShncmlkLCAncm93JywgJ2hlaWdodCcsIDMwKTtcblxuICAgIHJldHVybiBhcGk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBhcGkgPSB7X2RlY29yYXRvcnM6IHt9fTtcblxuICAgIGZ1bmN0aW9uIHNldENvbFNob3dpbmcoY29sKSB7XG4gICAgICAgIGdyaWQuY29sTW9kZWwuZ2V0KGNvbCkuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9XaGlsZUhpZGRlbihjb2wsIGZuKSB7XG4gICAgICAgIHdoaWxlIChncmlkLmNvbE1vZGVsLmdldChjb2wgLSAxKS5oaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbC0tO1xuICAgICAgICAgICAgZm4gJiYgZm4oY29sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURlY29yYXRvcihjb2wsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBoZWFkZXJEZWNvcmF0b3IgPSBncmlkLmRlY29yYXRvcnMuY3JlYXRlKDAsIGNvbCwgMSwgMSwgJ2NlbGwnLCAndmlydHVhbCcpO1xuXG4gICAgICAgIGhlYWRlckRlY29yYXRvci5wb3N0UmVuZGVyID0gZnVuY3Rpb24gKGRpdikge1xuXG4gICAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSg1MCUsIC01MCUpJztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSg1MCUsIC01MCUpJztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2xlZnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKC01MCUsIC01MCUpJztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXYuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2JvdHRvbScpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRvcCA9ICc1MCUnO1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2hvdy1oaWRkZW4tY29scycpO1xuXG4gICAgICAgICAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdjbGljaycsIGRpdiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvV2hpbGVIaWRkZW4oY29sLCBzZXRDb2xTaG93aW5nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaGVhZGVyRGVjb3JhdG9yO1xuICAgIH1cblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtY29sLWNoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmFjdGlvbiA9PT0gJ2hpZGUnIHx8IGUuYWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICAgICAgZS5kZXNjcmlwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGRlc2NyaXB0b3IuaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2wgJiYgY29sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNDb2wgPSBjb2wgKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHRTaWRlID0gY29sID09PSBncmlkLmNvbE1vZGVsLmxlbmd0aCh0cnVlKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgd2UncmUgbGFzdCB3ZSBhY3R1YWxseSBoYXZlIHRvIGJhY2t0cmFjayB0byB0aGUgbGFzdCBzaG93aW5nIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RIaWRkZW5Db2wgPSBkb1doaWxlSGlkZGVuKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNDb2wgPSBsYXN0SGlkZGVuQ29sIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBjcmVhdGVEZWNvcmF0b3IoZGVjQ29sLCByaWdodFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmRlY29yYXRvcnMuYWRkKGRlY29yYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5fZGVjb3JhdG9yc1tjb2xdID0gZGVjb3JhdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBhcGkuX2RlY29yYXRvcnNbY29sXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5kZWNvcmF0b3JzLnJlbW92ZShkZWNvcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuX2RlY29yYXRvcnNbY29sXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcblxuICAgIHZhciBjZWxsRGF0YSA9IFtdO1xuICAgIHZhciBoZWFkZXJEYXRhID0gW107XG4gICAgdmFyIHNvcnRlZENvbDtcbiAgICB2YXIgYXNjZW5kaW5nO1xuICAgIHZhciBkaXJ0eUNsZWFuID0gcmVxdWlyZSgnLi4vZGlydHktY2xlYW4nKShncmlkKTtcbiAgICB2YXIgaW50ZXJuYWxTZXQgPSBmdW5jdGlvbiAoZGF0YSwgciwgYywgZGF0dW0pIHtcbiAgICAgICAgaWYgKCFkYXRhW3JdKSB7XG4gICAgICAgICAgICBkYXRhW3JdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtyXVtjXSA9IGRhdHVtO1xuICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGlzRGlydHk6IGRpcnR5Q2xlYW4uaXNEaXJ0eSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAociwgYywgZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdHVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkYXR1bSA9IHt2YWx1ZTogZGF0dW0ucmVwbGFjZSgnW3JSXScsICcnKS5yZXBsYWNlKCdbY0NdJywgJycpLnNwbGl0KCcgJyl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhID0gW3tyb3c6IHIsIGNvbDogYywgZGF0YTogZGF0dW19XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxTZXQoY2VsbERhdGEsIGNoYW5nZS5yb3csIGNoYW5nZS5jb2wsIGNoYW5nZS5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRIZWFkZXI6IGZ1bmN0aW9uIChyLCBjLCBkYXR1bSkge1xuICAgICAgICAgICAgaW50ZXJuYWxTZXQoaGVhZGVyRGF0YSwgciwgYywgZGF0dW0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChyLCBjKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGNlbGxEYXRhW2dyaWQucm93TW9kZWwucm93KHIpLmRhdGFSb3ddO1xuICAgICAgICAgICAgdmFyIGRhdHVtID0gZGF0YVJvdyAmJiBkYXRhUm93W2dyaWQuY29sTW9kZWwuY29sKGMpLmRhdGFDb2xdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0dW0gJiYgZGF0dW0udmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCh2YWx1ZSAmJiAncicgKyB2YWx1ZVswXSArICcgYycgKyB2YWx1ZVsxXSkgfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiAodmFsdWUgJiYgJ3InICsgdmFsdWVbMF0gKyAnIGMnICsgdmFsdWVbMV0pIHx8ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb3B5RGF0YTogZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGkuZ2V0KHIsIGMpLmZvcm1hdHRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVhZGVyOiBmdW5jdGlvbiAociwgYykge1xuICAgICAgICAgICAgdmFyIGRhdGFSb3cgPSBoZWFkZXJEYXRhW2dyaWQucm93TW9kZWwuZ2V0KHIpLmRhdGFSb3ddO1xuXG4gICAgICAgICAgICB2YXIgZGF0dW0gPSBkYXRhUm93ICYmIGRhdGFSb3dbZ3JpZC5jb2xNb2RlbC5nZXQoYykuZGF0YUNvbF07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXR1bSAmJiBkYXR1bS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogdmFsdWUgJiYgJ2hyJyArIHZhbHVlWzBdICsgJyBoYycgKyB2YWx1ZVsxXSB8fCAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVTb3J0OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIHJldFZhbCA9IC0xO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVNZXRob2QgPSBmdW5jdGlvbiAodmFsMSwgdmFsMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwxIDwgKHZhbDIpID8gcmV0VmFsIDogLTEgKiByZXRWYWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGMgPT09IHNvcnRlZENvbCkge1xuICAgICAgICAgICAgICAgIGlmIChhc2NlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNjZW5kaW5nID0gIWFzY2VuZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc29ydGVkQ29sID0gYztcbiAgICAgICAgICAgICAgICBhc2NlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbERhdGEuc29ydChmdW5jdGlvbiAoZGF0YVJvdzEsIGRhdGFSb3cyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhUm93MSB8fCAhZGF0YVJvdzFbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhUm93MiB8fCAhZGF0YVJvdzJbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldFZhbCAqIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZU1ldGhvZChkYXRhUm93MVtjXS52YWx1ZSwgZGF0YVJvdzJbY10udmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXJ0eUNsZWFuLnNldERpcnR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbn07IiwibW9kdWxlLmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIHIpIHtcbiAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBjKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignXFxuJykgIT09IC0xIHx8IHZhbHVlLmluZGV4T2YoJ1xcdCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vcmVwbGFjZSBcIiB3aXRoIFwiXCIgdG8gZXNjYXBlIGFuZCB3cmFwIHRoZSB3aG9sZSB2YWx1ZSBpbiBxdW90ZXMgXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnXCInICsgdmFsdWUucmVwbGFjZSgnXCInLCAnXCJcIicpICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyArPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjICE9PSByb3cubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnXFx0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHIgIT09IGRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc3RyaW5nICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuLy8gcmVmOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjkzMTYzLzIzNDNcbi8vIFRoaXMgd2lsbCBwYXJzZSBhIGRlbGltaXRlZCBzdHJpbmcgaW50byBhbiBhcnJheSBvZlxuLy8gYXJyYXlzLiBUaGUgZGVmYXVsdCBkZWxpbWl0ZXIgaXMgdGhlIGNvbW1hLCBidXQgdGhpc1xuLy8gY2FuIGJlIG92ZXJyaWRlbiBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuZnVuY3Rpb24gRFNWVG9BcnJheShzdHJEYXRhLCBzdHJEZWxpbWl0ZXIpIHtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGRlbGltaXRlciBpcyBkZWZpbmVkLiBJZiBub3QsXG4gICAgLy8gdGhlbiBkZWZhdWx0IHRvIGNvbW1hLlxuICAgIHN0ckRlbGltaXRlciA9IChzdHJEZWxpbWl0ZXIgfHwgXCIsXCIpO1xuXG4gICAgLy8gQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIHRvIHBhcnNlIHRoZSBDU1YgdmFsdWVzLlxuICAgIHZhciBvYmpQYXR0ZXJuID0gbmV3IFJlZ0V4cChcbiAgICAgICAgKFxuICAgICAgICAgICAgLy8gRGVsaW1pdGVycy5cbiAgICAgICAgXCIoXFxcXFwiICsgc3RyRGVsaW1pdGVyICsgXCJ8XFxcXHI/XFxcXG58XFxcXHJ8XilcIiArXG5cbiAgICAgICAgICAgIC8vIFF1b3RlZCBmaWVsZHMuXG4gICAgICAgIFwiKD86XFxcIihbXlxcXCJdKig/OlxcXCJcXFwiW15cXFwiXSopKilcXFwifFwiICtcblxuICAgICAgICAgICAgLy8gU3RhbmRhcmQgZmllbGRzLlxuICAgICAgICBcIihbXlxcXCJcXFxcXCIgKyBzdHJEZWxpbWl0ZXIgKyBcIlxcXFxyXFxcXG5dKikpXCJcbiAgICAgICAgKSxcbiAgICAgICAgXCJnaVwiXG4gICAgKTtcblxuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IHRvIGhvbGQgb3VyIGRhdGEuIEdpdmUgdGhlIGFycmF5XG4gICAgLy8gYSBkZWZhdWx0IGVtcHR5IGZpcnN0IHJvdy5cbiAgICB2YXIgYXJyRGF0YSA9IFtbXV07XG5cbiAgICAvLyBDcmVhdGUgYW4gYXJyYXkgdG8gaG9sZCBvdXIgaW5kaXZpZHVhbCBwYXR0ZXJuXG4gICAgLy8gbWF0Y2hpbmcgZ3JvdXBzLlxuICAgIHZhciBhcnJNYXRjaGVzID0gbnVsbDtcblxuXG4gICAgLy8gS2VlcCBsb29waW5nIG92ZXIgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzXG4gICAgLy8gdW50aWwgd2UgY2FuIG5vIGxvbmdlciBmaW5kIGEgbWF0Y2guXG4gICAgd2hpbGUgKGFyck1hdGNoZXMgPSBvYmpQYXR0ZXJuLmV4ZWMoc3RyRGF0YSkpIHtcblxuICAgICAgICAvLyBHZXQgdGhlIGRlbGltaXRlciB0aGF0IHdhcyBmb3VuZC5cbiAgICAgICAgdmFyIHN0ck1hdGNoZWREZWxpbWl0ZXIgPSBhcnJNYXRjaGVzWzFdO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gZGVsaW1pdGVyIGhhcyBhIGxlbmd0aFxuICAgICAgICAvLyAoaXMgbm90IHRoZSBzdGFydCBvZiBzdHJpbmcpIGFuZCBpZiBpdCBtYXRjaGVzXG4gICAgICAgIC8vIGZpZWxkIGRlbGltaXRlci4gSWYgaWQgZG9lcyBub3QsIHRoZW4gd2Uga25vd1xuICAgICAgICAvLyB0aGF0IHRoaXMgZGVsaW1pdGVyIGlzIGEgcm93IGRlbGltaXRlci5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RyTWF0Y2hlZERlbGltaXRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIHN0ck1hdGNoZWREZWxpbWl0ZXIgIT09IHN0ckRlbGltaXRlclxuICAgICAgICApIHtcblxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSByZWFjaGVkIGEgbmV3IHJvdyBvZiBkYXRhLFxuICAgICAgICAgICAgLy8gYWRkIGFuIGVtcHR5IHJvdyB0byBvdXIgZGF0YSBhcnJheS5cbiAgICAgICAgICAgIGFyckRhdGEucHVzaChbXSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJNYXRjaGVkVmFsdWU7XG5cbiAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBvdXIgZGVsaW1pdGVyIG91dCBvZiB0aGUgd2F5LFxuICAgICAgICAvLyBsZXQncyBjaGVjayB0byBzZWUgd2hpY2gga2luZCBvZiB2YWx1ZSB3ZVxuICAgICAgICAvLyBjYXB0dXJlZCAocXVvdGVkIG9yIHVucXVvdGVkKS5cbiAgICAgICAgaWYgKGFyck1hdGNoZXNbMl0pIHtcblxuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBxdW90ZWQgdmFsdWUuIFdoZW4gd2UgY2FwdHVyZVxuICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSwgdW5lc2NhcGUgYW55IGRvdWJsZSBxdW90ZXMuXG4gICAgICAgICAgICBzdHJNYXRjaGVkVmFsdWUgPSBhcnJNYXRjaGVzWzJdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcIlxcXCJcXFwiXCIsIFwiZ1wiKSxcbiAgICAgICAgICAgICAgICBcIlxcXCJcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG5vbi1xdW90ZWQgdmFsdWUuXG4gICAgICAgICAgICBzdHJNYXRjaGVkVmFsdWUgPSBhcnJNYXRjaGVzWzNdO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgb3VyIHZhbHVlIHN0cmluZywgbGV0J3MgYWRkXG4gICAgICAgIC8vIGl0IHRvIHRoZSBkYXRhIGFycmF5LlxuICAgICAgICBhcnJEYXRhW2FyckRhdGEubGVuZ3RoIC0gMV0ucHVzaChzdHJNYXRjaGVkVmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgcGFyc2VkIGRhdGEuXG4gICAgcmV0dXJuICggYXJyRGF0YSApO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBEU1ZUb0FycmF5KHN0cmluZywgJ1xcdCcpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjbGFtcDogZnVuY3Rpb24gKG51bSwgbWluLCBtYXgsIHJldHVybk5hTikge1xuICAgICAgICBpZiAobnVtID4gbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuTmFOID8gTmFOIDogbWF4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0gPCBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5OYU4gPyBOYU4gOiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9LFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtYmVyKTtcbiAgICB9LFxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhKG5vZGUgJiZcbiAgICAgICAgKG5vZGUubm9kZU5hbWUgfHwgLy8gd2UgYXJlIGEgZGlyZWN0IGVsZW1lbnRcbiAgICAgICAgKG5vZGUucHJvcCAmJiBub2RlLmF0dHIgJiYgbm9kZS5maW5kKSkpOyAgLy8gd2UgaGF2ZSBhbiBvbiBhbmQgZmluZCBtZXRob2QgcGFydCBvZiBqcXVlcnkgQVBJXG4gICAgfSxcbiAgICBpc0FycmF5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gKGVsZW0sIHQsIGwsIGIsIHIpIHtcbiAgICAgICAgZWxlbS5zdHlsZS50b3AgPSB0ICsgJ3B4JztcbiAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gbCArICdweCc7XG4gICAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gYiArICdweCc7XG4gICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSByICsgJ3B4JztcbiAgICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICB9XG59OyIsInZhciBjdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbS1ldmVudCcpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi4vZGVib3VuY2UnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIHZpZXdMYXllciA9IHt9O1xuXG5cbiAgICB2YXIgZ3JpZCA9IF9ncmlkO1xuICAgIHZhciBjb250YWluZXI7XG4gICAgdmFyIHJvb3Q7XG4gICAgdmFyIGNlbGxDb250YWluZXI7XG4gICAgdmFyIGRlY29yYXRvckNvbnRhaW5lcjtcbiAgICB2YXIgYm9yZGVyV2lkdGg7XG5cbiAgICB2YXIgR1JJRF9DRUxMX0NPTlRBSU5FUl9CQVNFX0NMQVNTID0gJ2dyaWQtY2VsbHMnO1xuICAgIHZhciBHUklEX1ZJRVdfUk9PVF9DTEFTUyA9ICdqcy1ncmlkLXZpZXctcm9vdCc7XG4gICAgdmFyIENFTExfQ0xBU1MgPSAnZ3JpZC1jZWxsJztcblxuICAgIHZhciBjZWxsczsgLy9tYXRyaXggb2YgcmVuZGVyZWQgY2VsbCBlbGVtZW50cztcbiAgICB2YXIgcm93czsgLy9hcnJheSBvZiBhbGwgcmVuZGVyZWQgcm93c1xuICAgIHZhciBidWlsdENvbHM7IC8vbWFwIGZyb20gY29sIGluZGV4IHRvIGFuIGFycmF5IG9mIGJ1aWx0IGVsZW1lbnRzIGZvciB0aGUgY29sdW1uIHRvIHVwZGF0ZSBvbiBzY3JvbGxcbiAgICB2YXIgYnVpbHRSb3dzOyAvL21hcCBmcm9tIHJvdyBpbmRleCB0byBhbiBhcnJheSBvZiBidWlsdCBlbGVtZW50cyBmb3IgdGhlIHJvdyB0byB1cGRhdGUgb24gc2Nyb2xsXG5cbiAgICAvL2FkZCB0aGUgY2VsbCBjbGFzc2VzIHRocm91Z2ggdGhlIHN0YW5kYXJkIG1ldGhvZFxuICAgIGdyaWQuY2VsbENsYXNzZXMuYWRkKGdyaWQuY2VsbENsYXNzZXMuY3JlYXRlKDAsIDAsIENFTExfQ0xBU1MsIEluZmluaXR5LCBJbmZpbml0eSwgJ3ZpcnR1YWwnKSk7XG5cbiAgICB2YXIgcm93SGVhZGVyQ2xhc3NlcyA9IGdyaWQuY2VsbENsYXNzZXMuY3JlYXRlKDAsIDAsICdncmlkLWhlYWRlciBncmlkLXJvdy1oZWFkZXInLCBJbmZpbml0eSwgMCwgJ3ZpcnR1YWwnKTtcbiAgICB2YXIgY29sSGVhZGVyQ2xhc3NlcyA9IGdyaWQuY2VsbENsYXNzZXMuY3JlYXRlKDAsIDAsICdncmlkLWhlYWRlciBncmlkLWNvbC1oZWFkZXInLCAwLCBJbmZpbml0eSwgJ3ZpcnR1YWwnKTtcbiAgICB2YXIgZml4ZWRDb2xDbGFzc2VzID0gZ3JpZC5jZWxsQ2xhc3Nlcy5jcmVhdGUoMCwgLTEsICdncmlkLWxhc3QtZml4ZWQtY29sJywgSW5maW5pdHksIDEsICd2aXJ0dWFsJyk7XG4gICAgdmFyIGZpeGVkUm93Q2xhc3NlcyA9IGdyaWQuY2VsbENsYXNzZXMuY3JlYXRlKC0xLCAwLCAnZ3JpZC1sYXN0LWZpeGVkLXJvdycsIDEsIEluZmluaXR5LCAndmlydHVhbCcpO1xuXG4gICAgZ3JpZC5jZWxsQ2xhc3Nlcy5hZGQocm93SGVhZGVyQ2xhc3Nlcyk7XG4gICAgZ3JpZC5jZWxsQ2xhc3Nlcy5hZGQoY29sSGVhZGVyQ2xhc3Nlcyk7XG4gICAgZ3JpZC5jZWxsQ2xhc3Nlcy5hZGQoZml4ZWRSb3dDbGFzc2VzKTtcbiAgICBncmlkLmNlbGxDbGFzc2VzLmFkZChmaXhlZENvbENsYXNzZXMpO1xuXG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWNvbC1jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpeGVkQ29sQ2xhc3Nlcy5sZWZ0ID0gZ3JpZC5jb2xNb2RlbC5udW1GaXhlZCgpIC0gMTtcbiAgICAgICAgcm93SGVhZGVyQ2xhc3Nlcy53aWR0aCA9IGdyaWQuY29sTW9kZWwubnVtSGVhZGVycygpO1xuICAgIH0pO1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1yb3ctY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmaXhlZFJvd0NsYXNzZXMudG9wID0gZ3JpZC5yb3dNb2RlbC5udW1GaXhlZCgpIC0gMTtcbiAgICAgICAgY29sSGVhZGVyQ2xhc3Nlcy5oZWlnaHQgPSBncmlkLnJvd01vZGVsLm51bUhlYWRlcnMoKTtcbiAgICB9KTtcblxuXG4gICAgdmlld0xheWVyLmJ1aWxkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgIGNvbnRhaW5lciA9IGVsZW07XG5cbiAgICAgICAgY2VsbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjZWxsQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZHRzJywgJ2dyaWQtY2VsbHMnKTtcbiAgICAgICAgY2VsbENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgR1JJRF9DRUxMX0NPTlRBSU5FUl9CQVNFX0NMQVNTKTtcbiAgICAgICAgdXRpbC5wb3NpdGlvbihjZWxsQ29udGFpbmVyLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY2VsbENvbnRhaW5lci5zdHlsZS56SW5kZXggPSAwO1xuXG4gICAgICAgIGRlY29yYXRvckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkZWNvcmF0b3JDb250YWluZXIuc2V0QXR0cmlidXRlKCdkdHMnLCAnZ3JpZC1kZWNvcmF0b3JzJyk7XG4gICAgICAgIHV0aWwucG9zaXRpb24oZGVjb3JhdG9yQ29udGFpbmVyLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgZGVjb3JhdG9yQ29udGFpbmVyLnN0eWxlLnpJbmRleCA9IDA7XG4gICAgICAgIGRlY29yYXRvckNvbnRhaW5lci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICAgIHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgR1JJRF9WSUVXX1JPT1RfQ0xBU1MpO1xuXG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoY2VsbENvbnRhaW5lcik7XG4gICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZGVjb3JhdG9yQ29udGFpbmVyKTtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocm9vdCk7XG5cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBtZWFzdXJlQm9yZGVyV2lkdGgoKSB7XG4gICAgICAgIC8vcmVhZCB0aGUgYm9yZGVyIHdpZHRoLCBmb3IgdGhlIHJhcmUgY2FzZSBvZiBsYXJnZXIgdGhhbiAxcHggYm9yZGVycywgb3RoZXJ3aXNlIHRoZSBkcmF3IHdpbGwgZGVmYXVsdCB0byAxXG4gICAgICAgIGlmIChib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc0dyaWRDZWxsID0gY2VsbHNbMF0gJiYgY2VsbHNbMF1bMF07XG4gICAgICAgIGlmIChqc0dyaWRDZWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSBqc0dyaWRDZWxsLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGpzR3JpZENlbGwuY2xhc3NOYW1lID0gQ0VMTF9DTEFTUztcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShqc0dyaWRDZWxsKTtcbiAgICAgICAgICAgIHZhciBib3JkZXJXaWR0aFByb3AgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyk7XG4gICAgICAgICAgICBib3JkZXJXaWR0aCA9IHBhcnNlSW50KGJvcmRlcldpZHRoUHJvcCk7XG4gICAgICAgICAgICBqc0dyaWRDZWxsLmNsYXNzTmFtZSA9IG9sZENsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGJvcmRlcldpZHRoID0gaXNOYU4oYm9yZGVyV2lkdGgpIHx8ICFib3JkZXJXaWR0aCA/IHVuZGVmaW5lZCA6IGJvcmRlcldpZHRoO1xuICAgICAgICByZXR1cm4gYm9yZGVyV2lkdGg7XG4gICAgfVxuXG4gICAgLy9vbmx5IGRyYXcgb25jZSBwZXIganMgdHVybiwgbWF5IG5lZWQgdG8gY3JlYXRlIGEgc3luY2hyb25vdXMgdmVyc2lvblxuICAgIHZpZXdMYXllci5kcmF3ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWV3TGF5ZXIuX2RyYXcoKTtcbiAgICB9LCAxKTtcblxuICAgIHZpZXdMYXllci5fZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9yZXR1cm4gaWYgd2UgaGF2ZW4ndCBidWlsdCB5ZXRcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWJ1aWx0ID0gZ3JpZC52aWV3UG9ydC5pc0RpcnR5KCk7XG4gICAgICAgIGlmIChyZWJ1aWx0KSB7XG4gICAgICAgICAgICB2aWV3TGF5ZXIuX2J1aWxkQ2VsbHMoY2VsbENvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVpbHRDb2xzRGlydHkgPSBncmlkLmNvbE1vZGVsLmFyZUJ1aWxkZXJzRGlydHkoKTtcbiAgICAgICAgaWYgKHJlYnVpbHQgfHwgYnVpbHRDb2xzRGlydHkpIHtcbiAgICAgICAgICAgIHZpZXdMYXllci5fYnVpbGRDb2xzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVpbHRSb3dzRGlydHkgPSBncmlkLnJvd01vZGVsLmFyZUJ1aWxkZXJzRGlydHkoKTtcbiAgICAgICAgaWYgKHJlYnVpbHQgfHwgYnVpbHRSb3dzRGlydHkpIHtcbiAgICAgICAgICAgIHZpZXdMYXllci5fYnVpbGRSb3dzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VsbHNQb3NpdGlvbk9yU2l6ZUNoYW5nZWQgPSBncmlkLmNvbE1vZGVsLmlzRGlydHkoKSB8fCBncmlkLnJvd01vZGVsLmlzRGlydHkoKSB8fCBncmlkLmNlbGxTY3JvbGxNb2RlbC5pc0RpcnR5KCk7XG5cbiAgICAgICAgaWYgKGdyaWQuY2VsbENsYXNzZXMuaXNEaXJ0eSgpIHx8IHJlYnVpbHQgfHwgY2VsbHNQb3NpdGlvbk9yU2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZpZXdMYXllci5fZHJhd0NlbGxDbGFzc2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVidWlsdCB8fCBjZWxsc1Bvc2l0aW9uT3JTaXplQ2hhbmdlZCB8fCBidWlsdENvbHNEaXJ0eSB8fCBidWlsdFJvd3NEaXJ0eSB8fCBncmlkLmRhdGFNb2RlbC5pc0RpcnR5KCkpIHtcbiAgICAgICAgICAgIHZpZXdMYXllci5fZHJhd0NlbGxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kZWNvcmF0b3JzLmlzRGlydHkoKSB8fCByZWJ1aWx0IHx8IGNlbGxzUG9zaXRpb25PclNpemVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB2aWV3TGF5ZXIuX2RyYXdEZWNvcmF0b3JzKGNlbGxzUG9zaXRpb25PclNpemVDaGFuZ2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuZXZlbnRMb29wLmZpcmUoJ2dyaWQtZHJhdycpO1xuICAgIH07XG5cbiAgICAvKiBDRUxMIExPR0lDICovXG4gICAgZnVuY3Rpb24gZ2V0Qm9yZGVyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBib3JkZXJXaWR0aCB8fCAxO1xuICAgIH1cblxuICAgIHZpZXdMYXllci5fZHJhd0NlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZWFzdXJlQm9yZGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIGJXaWR0aCA9IGdldEJvcmRlcldpZHRoKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dzID0gZ3JpZC5yb3dNb2RlbC5udW1IZWFkZXJzKCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2xzID0gZ3JpZC5jb2xNb2RlbC5udW1IZWFkZXJzKCk7XG4gICAgICAgIHZhciB0b3RhbFZpc2libGVDZWxsV2lkdGggPSAwO1xuICAgICAgICB2YXIgbGFzdFZpcnR1YWxDb2w7XG4gICAgICAgIGdyaWQudmlld1BvcnQuaXRlcmF0ZUNlbGxzKGZ1bmN0aW9uIGRyYXdDZWxsKHIsIGMpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gY2VsbHNbcl1bY107XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBncmlkLnZpZXdQb3J0LmdldENvbFdpZHRoKGMpO1xuICAgICAgICAgICAgdmFyIHZpcnR1YWxDb2wgPSBncmlkLnZpZXdQb3J0LnRvVmlydHVhbENvbChjKTtcbiAgICAgICAgICAgIC8vaWYgd2UgZ290IHRoZSBzYW1lIHZDb2wgd2UndmUgYmVlbiBjbGFtcGVkIGFuZCBpdHMgdGltZSB0byBoaWRlIHRoaXMgY2VsbFxuICAgICAgICAgICAgLy9hbHNvIGhpZGUgdGhlIGNlbGwgaWYgaXRzIHdpZHRoIGlzIHplcm8gY2F1c2UgeWEuLi5cbiAgICAgICAgICAgIGlmICh3aWR0aCA9PSAwIHx8IHZpcnR1YWxDb2wgPT09IGxhc3RWaXJ0dWFsQ29sKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9jYWxjdWxhdGUgd2lkdGggZm9yIHJvd3MgbGF0ZXIgYnV0IG9ubHkgZG8gaXQgb25lIHRpbWUgKHNvIG9uIHRoZSBmaXJzdCByb3cpXG4gICAgICAgICAgICAgICAgdG90YWxWaXNpYmxlQ2VsbFdpZHRoICs9IHdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0VmlydHVhbENvbCA9IHZpcnR1YWxDb2w7XG4gICAgICAgICAgICBjZWxsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgIGNlbGwuc3R5bGUud2lkdGggPSB3aWR0aCArIGJXaWR0aCArICdweCc7XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZ3JpZC52aWV3UG9ydC5nZXRDb2xMZWZ0KGMpO1xuXG4gICAgICAgICAgICBjZWxsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcblxuICAgICAgICAgICAgd2hpbGUgKGNlbGwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNlbGwucmVtb3ZlQ2hpbGQoY2VsbC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2aXJ0dWFsUm93ID0gZ3JpZC52aWV3UG9ydC50b1ZpcnR1YWxSb3cocik7XG5cbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgaWYgKHIgPCBoZWFkZXJSb3dzIHx8IGMgPCBoZWFkZXJDb2xzKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdyaWQuZGF0YU1vZGVsLmdldEhlYWRlcih2aXJ0dWFsUm93LCB2aXJ0dWFsQ29sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdyaWQuZGF0YU1vZGVsLmdldChncmlkLnJvd01vZGVsLnRvRGF0YSh2aXJ0dWFsUm93KSwgZ3JpZC5jb2xNb2RlbC50b0RhdGEodmlydHVhbENvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9hcnRpZmljaWFsbHkgb25seSBnZXQgYnVpbGRlcnMgZm9yIHJvdyBoZWFkZXJzIGZvciBub3dcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gdmlydHVhbFJvdyA8IGhlYWRlclJvd3MgJiYgZ3JpZC5yb3dNb2RlbC5nZXQodmlydHVhbFJvdykuYnVpbGRlciB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgaGFzUm93QnVpbGRlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICBoYXNSb3dCdWlsZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnVpbGRlciA9IGdyaWQuY29sTW9kZWwuZ2V0KHZpcnR1YWxDb2wpLmJ1aWxkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjZWxsQ2hpbGQ7XG4gICAgICAgICAgICBpZiAoYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIHZhciBidWlsdEVsZW07XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Jvd0J1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbHRFbGVtID0gYnVpbHRSb3dzW3ZpcnR1YWxSb3ddW2NdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWx0RWxlbSA9IGJ1aWx0Q29sc1t2aXJ0dWFsQ29sXVtyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbENoaWxkID0gYnVpbGRlci51cGRhdGUoYnVpbHRFbGVtLCB7XG4gICAgICAgICAgICAgICAgICAgIHZpcnR1YWxDb2w6IHZpcnR1YWxDb2wsXG4gICAgICAgICAgICAgICAgICAgIHZpcnR1YWxSb3c6IHZpcnR1YWxSb3csXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgd2UgZGlkbid0IGdldCBhIGNoaWxkIGZyb20gdGhlIGJ1aWxkZXIgdXNlIGEgcmVndWxhciB0ZXh0IG5vZGVcbiAgICAgICAgICAgIGlmICghY2VsbENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2VsbENoaWxkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YS5mb3JtYXR0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChjZWxsQ2hpbGQpO1xuICAgICAgICB9LCBmdW5jdGlvbiBkcmF3Um93KHIpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBncmlkLnZpZXdQb3J0LmdldFJvd0hlaWdodChyKTtcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgIHJvdy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBiV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdmFyIHRvcCA9IGdyaWQudmlld1BvcnQuZ2V0Um93VG9wKHIpO1xuICAgICAgICAgICAgcm93LnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICByb3cuc3R5bGUud2lkdGggPSB0b3RhbFZpc2libGVDZWxsV2lkdGggKyAncHgnO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsU2Nyb2xsTW9kZWwucm93ICUgMikge1xuICAgICAgICAgICAgY2VsbENvbnRhaW5lci5jbGFzc05hbWUgPSBHUklEX0NFTExfQ09OVEFJTkVSX0JBU0VfQ0xBU1MgKyAnIG9kZHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VsbENvbnRhaW5lci5jbGFzc05hbWUgPSBHUklEX0NFTExfQ09OVEFJTkVSX0JBU0VfQ0xBU1M7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICB2aWV3TGF5ZXIuX2J1aWxkQ2VsbHMgPSBmdW5jdGlvbiBidWlsZENlbGxzKGNlbGxDb250YWluZXIpIHtcbiAgICAgICAgd2hpbGUgKGNlbGxDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY2VsbENvbnRhaW5lci5yZW1vdmVDaGlsZChjZWxsQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cblxuICAgICAgICBjZWxscyA9IFtdO1xuICAgICAgICByb3dzID0gW107XG4gICAgICAgIHZhciByb3c7XG4gICAgICAgIGdyaWQudmlld1BvcnQuaXRlcmF0ZUNlbGxzKGZ1bmN0aW9uIChyLCBjKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGJ1aWxkRGl2Q2VsbCgpO1xuICAgICAgICAgICAgY2VsbHNbcl1bY10gPSBjZWxsO1xuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGNlbGwpO1xuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgY2VsbHNbcl0gPSBbXTtcbiAgICAgICAgICAgIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcm93LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZ3JpZC1yb3cnKTtcbiAgICAgICAgICAgIHJvdy5zZXRBdHRyaWJ1dGUoJ2R0cycsICdncmlkLXJvdycpO1xuICAgICAgICAgICAgcm93LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHJvdy5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgIHJvd3Nbcl0gPSByb3c7XG4gICAgICAgICAgICBjZWxsQ29udGFpbmVyLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBidWlsZERpdkNlbGwoKSB7XG4gICAgICAgIHZhciBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdkdHMnLCAnZ3JpZC1jZWxsJyk7XG4gICAgICAgIHZhciBzdHlsZSA9IGNlbGwuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgICBzdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgc3R5bGUuYm90dG9tID0gJzBweCc7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cblxuICAgIC8qIEVORCBDRUxMIExPR0lDICovXG5cbiAgICAvKiBDT0wgQlVJTERFUiBMT0dJQyAqL1xuICAgIHZpZXdMYXllci5fYnVpbGRDb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBidWlsdENvbHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBncmlkLmNvbE1vZGVsLmxlbmd0aCh0cnVlKTsgYysrKSB7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IGdyaWQuY29sTW9kZWwuZ2V0KGMpLmJ1aWxkZXI7XG4gICAgICAgICAgICBpZiAoYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIGJ1aWx0Q29sc1tjXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJlYWxSb3cgPSAwOyByZWFsUm93IDwgZ3JpZC52aWV3UG9ydC5yb3dzOyByZWFsUm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbHRDb2xzW2NdW3JlYWxSb3ddID0gYnVpbGRlci5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEVORCBDT0wgQlVJTERFUiBMT0dJQyAqL1xuXG4gICAgLyogUk9XIEJVSUxERVIgTE9HSUMgXG4gICAgICogIGZvciBub3cgd2Ugb25seSBidWlsZCBoZWFkZXJzXG4gICAgICogKi9cblxuICAgIHZpZXdMYXllci5fYnVpbGRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBidWlsdFJvd3MgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBncmlkLnJvd01vZGVsLm51bUhlYWRlcnMoKTsgcisrKSB7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IGdyaWQucm93TW9kZWwuZ2V0KHIpLmJ1aWxkZXI7XG4gICAgICAgICAgICBpZiAoYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIGJ1aWx0Um93c1tyXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJlYWxDb2wgPSAwOyByZWFsQ29sIDwgZ3JpZC52aWV3UG9ydC5jb2xzOyByZWFsQ29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbHRSb3dzW3JdW3JlYWxDb2xdID0gYnVpbGRlci5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEVORCBST1cgQlVJTERFUiBMT0dJQyovXG5cbiAgICAvKiBERUNPUkFUT1IgTE9HSUMgKi9cbiAgICBmdW5jdGlvbiBzZXRQb3NpdGlvbihib3VuZGluZ0JveCwgdG9wLCBsZWZ0LCBoZWlnaHQsIHdpZHRoKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGJvdW5kaW5nQm94LnN0eWxlO1xuICAgICAgICBpZiAoaGVpZ2h0IDw9IDAgfHwgd2lkdGggPD0gMCkge1xuICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5kaXNwbGF5ID0gJydcbiAgICAgICAgc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uRGVjb3JhdG9yKGJvdW5kaW5nLCB0LCBsLCBoLCB3KSB7XG4gICAgICAgIHNldFBvc2l0aW9uKGJvdW5kaW5nLCB0LCBsLCB1dGlsLmNsYW1wKGgsIDAsIGdyaWQudmlld1BvcnQuaGVpZ2h0KSwgdXRpbC5jbGFtcCh3LCAwLCBncmlkLnZpZXdQb3J0LndpZHRoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpb25DZWxsRGVjb3JhdG9yRnJvbVZpZXdDZWxsUmFuZ2UocmVhbENlbGxSYW5nZSwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgdmFyIHJlYWxQeFJhbmdlID0gZ3JpZC52aWV3UG9ydC50b1B4KHJlYWxDZWxsUmFuZ2UpO1xuICAgICAgICBwb3NpdGlvbkRlY29yYXRvcihib3VuZGluZ0JveCwgcmVhbFB4UmFuZ2UudG9wLCByZWFsUHhSYW5nZS5sZWZ0LCByZWFsUHhSYW5nZS5oZWlnaHQgJiYgcmVhbFB4UmFuZ2UuaGVpZ2h0ICsgZ2V0Qm9yZGVyV2lkdGgoKSwgcmVhbFB4UmFuZ2Uud2lkdGggJiYgcmVhbFB4UmFuZ2Uud2lkdGggKyBnZXRCb3JkZXJXaWR0aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZUZvckRlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICB0b3A6IGRlc2NyaXB0b3IudG9wLFxuICAgICAgICAgICAgbGVmdDogZGVzY3JpcHRvci5sZWZ0LFxuICAgICAgICAgICAgaGVpZ2h0OiBkZXNjcmlwdG9yLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBkZXNjcmlwdG9yLndpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNwYWNlID09PSAnZGF0YScgJiYgZGVzY3JpcHRvci51bml0cyA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICByYW5nZS50b3AgKz0gZ3JpZC5yb3dNb2RlbC5udW1IZWFkZXJzKCk7XG4gICAgICAgICAgICByYW5nZS5sZWZ0ICs9IGdyaWQuY29sTW9kZWwubnVtSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICB2aWV3TGF5ZXIuX2RyYXdEZWNvcmF0b3JzID0gZnVuY3Rpb24gKGNlbGxzUG9zaXRpb25PclNpemVDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBhbGl2ZURlY29yYXRvcnMgPSBncmlkLmRlY29yYXRvcnMuZ2V0QWxpdmUoKTtcbiAgICAgICAgYWxpdmVEZWNvcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGRlY29yYXRvcikge1xuXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBkZWNvcmF0b3IuYm91bmRpbmdCb3g7XG4gICAgICAgICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmdCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGRlY29yYXRvci5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICAgIHZhciBkZWNFbGVtZW50ID0gZGVjb3JhdG9yLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChkZWNFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmFwcGVuZENoaWxkKGRlY0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3JDb250YWluZXIuYXBwZW5kQ2hpbGQoYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlY29yYXRvci5pc0RpcnR5KCkgfHwgY2VsbHNQb3NpdGlvbk9yU2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdG9yLnNwYWNlID09PSAncmVhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkZWNvcmF0b3IudW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkRlY29yYXRvcihib3VuZGluZ0JveCwgZGVjb3JhdG9yLnRvcCwgZGVjb3JhdG9yLmxlZnQsIGRlY29yYXRvci5oZWlnaHQsIGRlY29yYXRvci53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjZWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNlbGxEZWNvcmF0b3JGcm9tVmlld0NlbGxSYW5nZShkZWNvcmF0b3IsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNvcmF0b3Iuc3BhY2UgPT09ICd2aXJ0dWFsJyB8fCBkZWNvcmF0b3Iuc3BhY2UgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRlY29yYXRvci51bml0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2VsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwODYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2VGb3JEZXNjcmlwdG9yKGRlY29yYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWxDZWxsUmFuZ2UgPSBncmlkLnZpZXdQb3J0LmludGVyc2VjdChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWxDZWxsUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DZWxsRGVjb3JhdG9yRnJvbVZpZXdDZWxsUmFuZ2UocmVhbENlbGxSYW5nZSwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRGVjb3JhdG9yKGJvdW5kaW5nQm94LCAtMSwgLTEsIC0xLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50ICtXMDg2ICovXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVtb3ZlRGVjb3JhdG9ycyhncmlkLmRlY29yYXRvcnMucG9wQWxsRGVhZCgpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRGVjb3JhdG9ycyhkZWNvcmF0b3JzKSB7XG4gICAgICAgIGRlY29yYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBkZWNvcmF0b3IuYm91bmRpbmdCb3g7XG4gICAgICAgICAgICBpZiAoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXkgcmVuZGVyZWQgYW4gZWxlbWVudCBwcmV2aW91c2x5IHdlIGF0dGFjaGVkIGl0IHRvIHRoZSBib3VuZGluZyBib3ggYXMgdGhlIG9ubHkgY2hpbGRcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWRFbGVtZW50ID0gYm91bmRpbmdCb3guZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGEgZGVzdHJveSBkb20gZXZlbnQgdGhhdCBidWJibGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXN0cm95RXZlbnQgPSBjdXN0b21FdmVudCgnZGVjb3JhdG9yLWRlc3Ryb3knLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZGVzdHJveUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb3JhdG9yQ29udGFpbmVyLnJlbW92ZUNoaWxkKGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IuYm91bmRpbmdCb3ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIEVORCBERUNPUkFUT1IgTE9HSUMgKi9cblxuICAgIC8qIENFTEwgQ0xBU1NFUyBMT0dJQyAqL1xuICAgIHZpZXdMYXllci5fZHJhd0NlbGxDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBncmlkLnZpZXdQb3J0Lml0ZXJhdGVDZWxscyhmdW5jdGlvbiAociwgYykge1xuICAgICAgICAgICAgY2VsbHNbcl1bY10uY2xhc3NOYW1lID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICBncmlkLmNlbGxDbGFzc2VzLmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlRm9yRGVzY3JpcHRvcihkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBncmlkLnZpZXdQb3J0LmludGVyc2VjdChyYW5nZSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm93TG9vcDpcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBpbnRlcnNlY3Rpb24uaGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgaW50ZXJzZWN0aW9uLndpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gaW50ZXJzZWN0aW9uLnRvcCArIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGludGVyc2VjdGlvbi5sZWZ0ICsgYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsUm93ID0gY2VsbHNbcm93XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNlbGxSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcm93TG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBjZWxsUm93W2NvbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNsYXNzTmFtZSA9IChjZWxsLmNsYXNzTmFtZSA/IGNlbGwuY2xhc3NOYW1lICsgJyAnIDogJycpICsgZGVzY3JpcHRvci5jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyogRU5EIENFTEwgQ0xBU1NFUyBMT0dJQyovXG5cbiAgICB2aWV3TGF5ZXIuZGVzdHJveSA9IGNsZWFudXA7XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICByZW1vdmVEZWNvcmF0b3JzKGdyaWQuZGVjb3JhdG9ycy5nZXRBbGl2ZSgpLmNvbmNhdChncmlkLmRlY29yYXRvcnMucG9wQWxsRGVhZCgpKSk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJ5U2VsZWN0b3JBbGwgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLicgKyBHUklEX1ZJRVdfUk9PVF9DTEFTUyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlTZWxlY3RvckFsbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBxdWVyeVNlbGVjdG9yQWxsW2ldO1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1kZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWV3TGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodmlld0xheWVyLmRyYXcudGltZW91dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlld0xheWVyO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciByYW5nZVV0aWwgPSByZXF1aXJlKCcuLi9yYW5nZS11dGlsJyk7XG52YXIgY2FwaXRhbGl6ZSA9IHJlcXVpcmUoJ2NhcGl0YWxpemUnKTtcbnZhciBhZGREaXJ0eVByb3BzID0gcmVxdWlyZSgnLi4vYWRkLWRpcnR5LXByb3BzJyk7XG52YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuLi9kZWJvdW5jZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfZ3JpZCkge1xuICAgIHZhciBncmlkID0gX2dyaWQ7XG4gICAgdmFyIGRpcnR5Q2xlYW4gPSByZXF1aXJlKCcuLi9kaXJ0eS1jbGVhbicpKGdyaWQpO1xuICAgIHZhciBjb250YWluZXI7XG5cbiAgICB2YXIgdmlld1BvcnQgPSBhZGREaXJ0eVByb3BzKHt9LCBbJ3Jvd3MnLCAnY29scycsICd3aWR0aCcsICdoZWlnaHQnXSwgW2RpcnR5Q2xlYW5dKTtcbiAgICB2aWV3UG9ydC5yb3dzID0gMDtcbiAgICB2aWV3UG9ydC5jb2xzID0gMDtcbiAgICB2aWV3UG9ydC5pc0RpcnR5ID0gZGlydHlDbGVhbi5pc0RpcnR5O1xuXG4gICAgLy90aGVzZSBwcm9iYWJseSB0cmlnZ2VyIHJlZmxvdyBzbyB3ZSBtYXkgbmVlZCB0byB0aGluayBhYm91dCBjYWNoaW5nIHRoZSB2YWx1ZSBhbmQgdXBkYXRpbmcgaXQgYXQgb24gZHJhd3Mgb3Igc29tZXRoaW5nXG4gICAgZnVuY3Rpb24gZ2V0Rmlyc3RDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRDbGllbnRSZWN0cyAmJiBjb250YWluZXIuZ2V0Q2xpZW50UmVjdHMoKSAmJiBjb250YWluZXIuZ2V0Q2xpZW50UmVjdHMoKVswXSB8fCB7fTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmlld1BvcnQsICd0b3AnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZpcnN0Q2xpZW50UmVjdCgpLnRvcCB8fCAwO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmlld1BvcnQsICdsZWZ0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGaXJzdENsaWVudFJlY3QoKS5sZWZ0IHx8IDA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZpZXdQb3J0LnRvR3JpZFggPSBmdW5jdGlvbiAoY2xpZW50WCkge1xuICAgICAgICByZXR1cm4gY2xpZW50WCAtIHZpZXdQb3J0LmxlZnQ7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LnRvR3JpZFkgPSBmdW5jdGlvbiAoY2xpZW50WSkge1xuICAgICAgICByZXR1cm4gY2xpZW50WSAtIHZpZXdQb3J0LnRvcDtcbiAgICB9O1xuXG5cbiAgICB2YXIgZml4ZWQgPSB7cm93czogMCwgY29sczogMH07XG5cbiAgICBmdW5jdGlvbiBnZXRGaXhlZChyb3dPckNvbCkge1xuICAgICAgICByZXR1cm4gZml4ZWRbcm93T3JDb2wgKyAncyddO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LnNpemVUb0NvbnRhaW5lciA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGVsZW07XG4gICAgICAgIHZpZXdQb3J0LndpZHRoID0gZWxlbS5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmlld1BvcnQuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZpZXdQb3J0LnJvd3MgPSBjYWxjdWxhdGVNYXhMZW5ndGhzKHZpZXdQb3J0LmhlaWdodCwgZ3JpZC5yb3dNb2RlbCk7XG4gICAgICAgIHZpZXdQb3J0LmNvbHMgPSBjYWxjdWxhdGVNYXhMZW5ndGhzKHZpZXdQb3J0LndpZHRoLCBncmlkLmNvbE1vZGVsKTtcbiAgICAgICAgZ3JpZC5ldmVudExvb3AuZmlyZSgnZ3JpZC12aWV3cG9ydC1jaGFuZ2UnKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuX29uUmVzaXplID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWV3UG9ydC5fcmVzaXplKCk7XG4gICAgfSwgMjAwKTtcblxuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdQb3J0Ll9vblJlc2l6ZS50aW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNob3J0RGVib3VuY2VkUmVzaXplLnRpbWVvdXQpO1xuICAgIH0pO1xuXG4gICAgdmlld1BvcnQuX3Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdmlld1BvcnQuc2l6ZVRvQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNob3J0RGVib3VuY2VkUmVzaXplID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWV3UG9ydC5fcmVzaXplKCk7XG4gICAgfSwgMSk7XG5cbiAgICB2aWV3UG9ydC5zaG9ydERlYm91bmNlZFJlc2l6ZSA9IHNob3J0RGVib3VuY2VkUmVzaXplO1xuXG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdyZXNpemUnLCB3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy93ZSBkb24ndCBiaW5kIHRoZSBoYW5kbGVyIGRpcmVjdGx5IHNvIHRoYXQgdGVzdHMgY2FuIG1vY2sgaXQgb3V0XG4gICAgICAgIHZpZXdQb3J0Ll9vblJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1yb3ctY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmaXhlZC5yb3dzID0gZ3JpZC5yb3dNb2RlbC5udW1GaXhlZCgpO1xuICAgICAgICBzaG9ydERlYm91bmNlZFJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgZ3JpZC5ldmVudExvb3AuYmluZCgnZ3JpZC1jb2wtY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmaXhlZC5jb2xzID0gZ3JpZC5jb2xNb2RlbC5udW1GaXhlZCgpO1xuICAgICAgICBzaG9ydERlYm91bmNlZFJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29udmVydFJlYWxUb1ZpcnR1YWwoY29vcmQsIHJvd09yQ29sLCBjb29yZElzVmlydHVhbCkge1xuICAgICAgICAvL2NvdWxkIGNhY2hlIHRoaXMgb24gY2hhbmdlcyBpLmUuIHJvdy1jaGFuZ2Ugb3IgY29sLWNoYW5nZSBldmVudHNcbiAgICAgICAgdmFyIG51bUZpeGVkID0gZ2V0Rml4ZWQocm93T3JDb2wpO1xuICAgICAgICBpZiAoY29vcmQgPCBudW1GaXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29yZCArIChjb29yZElzVmlydHVhbCA/IC0xIDogMSkgKiBncmlkLmNlbGxTY3JvbGxNb2RlbFtyb3dPckNvbF07XG4gICAgfVxuXG4vLyBjb252ZXJ0cyBhIHZpZXdwb3J0IHJvdyBvciBjb2x1bW4gdG8gYSByZWFsIHJvdyBvciBjb2x1bW4gXG4vLyBjbGFtcHMgaXQgaWYgdGhlIGNvbHVtbiB3b3VsZCBiZSBvdXRzaWRlIHRoZSByYW5nZVxuICAgIGZ1bmN0aW9uIGdldFZpcnR1YWxSb3dDb2xVbnNhZmUocmVhbENvb3JkLCByb3dPckNvbCkge1xuICAgICAgICByZXR1cm4gY29udmVydFJlYWxUb1ZpcnR1YWwocmVhbENvb3JkLCByb3dPckNvbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmlydHVhbFJvd0NvbENsYW1wZWQodmlld0Nvb3JkLCByb3dPckNvbCkge1xuICAgICAgICB2YXIgdmlydHVhbFJvd0NvbCA9IGdldFZpcnR1YWxSb3dDb2xVbnNhZmUodmlld0Nvb3JkLCByb3dPckNvbCk7XG4gICAgICAgIHJldHVybiBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFsnY2xhbXAnICsgY2FwaXRhbGl6ZShyb3dPckNvbCldKHZpcnR1YWxSb3dDb2wpO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LnRvVmlydHVhbFJvdyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBnZXRWaXJ0dWFsUm93Q29sQ2xhbXBlZChyLCAncm93Jyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LnRvVmlydHVhbENvbCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZXRWaXJ0dWFsUm93Q29sQ2xhbXBlZChjLCAnY29sJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFJlYWxSb3dDb2xDbGFtcGVkKHZpcnR1YWxDb29yZCwgcm93T3JDb2wpIHtcbiAgICAgICAgdmFyIG51bUZpeGVkID0gZ2V0Rml4ZWQocm93T3JDb2wpO1xuICAgICAgICBpZiAodmlydHVhbENvb3JkIDwgbnVtRml4ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heFZpZXdQb3J0SW5kZXggPSB2aWV3UG9ydFtyb3dPckNvbCArICdzJ10gLSAxO1xuICAgICAgICByZXR1cm4gdXRpbC5jbGFtcCh2aXJ0dWFsQ29vcmQgLSBncmlkLmNlbGxTY3JvbGxNb2RlbFtyb3dPckNvbF0sIG51bUZpeGVkLCBtYXhWaWV3UG9ydEluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2aWV3UG9ydC5yb3dJc0luVmlldyA9IGZ1bmN0aW9uICh2aXJ0dWFsUm93KSB7XG4gICAgICAgIHZhciByZWFsUm93ID0gdmlld1BvcnQudG9SZWFsUm93KHZpcnR1YWxSb3cpO1xuICAgICAgICByZXR1cm4gIWlzTmFOKHJlYWxSb3cpICYmIGdldExlbmd0aEJldHdlZW5WaWV3Q29vcmRzKDAsIHJlYWxSb3csICdyb3cnLCAnaGVpZ2h0JywgdHJ1ZSkgPCB2aWV3UG9ydC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmNvbElzSW5WaWV3ID0gZnVuY3Rpb24gKHZpcnR1YWxDb2wpIHtcbiAgICAgICAgdmFyIHJlYWxDb2wgPSB2aWV3UG9ydC50b1JlYWxDb2wodmlydHVhbENvbCk7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocmVhbENvbCkgJiYgZ2V0TGVuZ3RoQmV0d2VlblZpZXdDb29yZHMoMCwgcmVhbENvbCwgJ2NvbCcsICd3aWR0aCcsIHRydWUpIDwgdmlld1BvcnQud2lkdGg7XG4gICAgfTtcblxuXG4vL2RlZmF1bHQgdW5jbGFtcGVkIGNhdXNlIHRoYXQgc2VlbXMgdG8gYmUgdGhlIG1vcmUgbGlrZWx5IHVzZSBjYXNlIGNvbnZlcnRpbmcgdGhpcyBkaXJlY3Rpb25cbiAgICB2aWV3UG9ydC50b1JlYWxSb3cgPSBmdW5jdGlvbiAodmlydHVhbFJvdykge1xuICAgICAgICByZXR1cm4gZ2V0UmVhbFJvd0NvbENsYW1wZWQodmlydHVhbFJvdywgJ3JvdycpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC50b1JlYWxDb2wgPSBmdW5jdGlvbiAodmlydHVhbENvbCkge1xuICAgICAgICByZXR1cm4gZ2V0UmVhbFJvd0NvbENsYW1wZWQodmlydHVhbENvbCwgJ2NvbCcpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC5jbGFtcFJvdyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmNsYW1wKHIsIDAsIHZpZXdQb3J0LnJvd3MgLSAxKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuY2xhbXBDb2wgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gdXRpbC5jbGFtcChjLCAwLCB2aWV3UG9ydC5jb2xzIC0gMSk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmNsYW1wWSA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHJldHVybiB1dGlsLmNsYW1wKHksIDAsIHZpZXdQb3J0LmhlaWdodCk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmNsYW1wWCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB1dGlsLmNsYW1wKHgsIDAsIHZpZXdQb3J0LndpZHRoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoQmV0d2VlblZpZXdDb29yZHMoc3RhcnRDb29yZCwgZW5kQ29vcmQsIHJvd09yQ29sLCBoZWlnaHRPcldpZHRoLCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIHJvd09yQ29sQ2FwID0gY2FwaXRhbGl6ZShyb3dPckNvbCk7XG4gICAgICAgIHZhciB0b1ZpcnR1YWwgPSB2aWV3UG9ydFsndG9WaXJ0dWFsJyArIHJvd09yQ29sQ2FwXTtcbiAgICAgICAgdmFyIGxlbmd0aEZuID0gZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWxbaGVpZ2h0T3JXaWR0aF07XG4gICAgICAgIHZhciBjbGFtcEZuID0gdmlld1BvcnRbJ2NsYW1wJyArIHJvd09yQ29sQ2FwXTtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHZhciBudW1GaXhlZCA9IGdldEZpeGVkKHJvd09yQ29sKTtcbiAgICAgICAgdmFyIGlzSW5Ob25maXhlZEFyZWEgPSBlbmRDb29yZCA+PSBudW1GaXhlZDtcbiAgICAgICAgdmFyIGlzSW5GaXhlZEFyZWEgPSBzdGFydENvb3JkIDwgbnVtRml4ZWQ7XG4gICAgICAgIHZhciBleGNsdXNpdmVPZmZzZXQgPSAoaW5jbHVzaXZlID8gMCA6IDEpO1xuICAgICAgICBpZiAoaXNJbkZpeGVkQXJlYSkge1xuICAgICAgICAgICAgdmFyIGZpeGVkRW5kQ29vcmQgPSAoaXNJbk5vbmZpeGVkQXJlYSA/IG51bUZpeGVkIC0gMSA6IGVuZENvb3JkIC0gZXhjbHVzaXZlT2Zmc2V0KTtcbiAgICAgICAgICAgIHBvcyArPSBsZW5ndGhGbihzdGFydENvb3JkLCBmaXhlZEVuZENvb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbk5vbmZpeGVkQXJlYSkge1xuICAgICAgICAgICAgcG9zICs9IGxlbmd0aEZuKChpc0luRml4ZWRBcmVhID8gdG9WaXJ0dWFsKG51bUZpeGVkKSA6IHRvVmlydHVhbChzdGFydENvb3JkKSksIHRvVmlydHVhbChjbGFtcEZuKGVuZENvb3JkKSkgLSBleGNsdXNpdmVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VG9wT3JMZWZ0KGVuZENvb3JkLCByb3dPckNvbCwgaGVpZ2h0T3JXaWR0aCkge1xuICAgICAgICByZXR1cm4gZ2V0TGVuZ3RoQmV0d2VlblZpZXdDb29yZHMoMCwgZW5kQ29vcmQsIHJvd09yQ29sLCBoZWlnaHRPcldpZHRoKTtcbiAgICB9XG5cbiAgICB2aWV3UG9ydC5nZXRSb3dUb3AgPSBmdW5jdGlvbiAodmlld1BvcnRDb29yZCkge1xuICAgICAgICByZXR1cm4gZ2V0VG9wT3JMZWZ0KHZpZXdQb3J0Q29vcmQsICdyb3cnLCAnaGVpZ2h0Jyk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmdldENvbExlZnQgPSBmdW5jdGlvbiAodmlld1BvcnRDb2wpIHtcbiAgICAgICAgcmV0dXJuIGdldFRvcE9yTGVmdCh2aWV3UG9ydENvbCwgJ2NvbCcsICd3aWR0aCcpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC50b1B4ID0gZnVuY3Rpb24gKHJlYWxDZWxsUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogdmlld1BvcnQuZ2V0Um93VG9wKHJlYWxDZWxsUmFuZ2UudG9wKSxcbiAgICAgICAgICAgIGxlZnQ6IHZpZXdQb3J0LmdldENvbExlZnQocmVhbENlbGxSYW5nZS5sZWZ0KSxcbiAgICAgICAgICAgIGhlaWdodDogZ2V0TGVuZ3RoQmV0d2VlblZpZXdDb29yZHMocmVhbENlbGxSYW5nZS50b3AsIHJlYWxDZWxsUmFuZ2UudG9wICsgcmVhbENlbGxSYW5nZS5oZWlnaHQgLSAxLCAncm93JywgJ2hlaWdodCcsIHRydWUpLFxuICAgICAgICAgICAgd2lkdGg6IGdldExlbmd0aEJldHdlZW5WaWV3Q29vcmRzKHJlYWxDZWxsUmFuZ2UubGVmdCwgcmVhbENlbGxSYW5nZS5sZWZ0ICsgcmVhbENlbGxSYW5nZS53aWR0aCAtIDEsICdjb2wnLCAnd2lkdGgnLCB0cnVlKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRSb3dPckNvbEZyb21Qb3NpdGlvbihwb3MsIHJvd09yQ29sLCBoZWlnaHRPcldpZHRoLCByZXR1cm5WaXJ0dWFsKSB7XG4gICAgICAgIC8vd2UgY291bGQgZG8gdGhpcyBzbGlnaGx5IGZhc3RlciB3aXRoIGJpbmFyeSBzZWFyY2ggdG8gZ2V0IGxvZyhuKSBpbnN0ZWFkIG9mIG4sIGJ1dCB3aWxsIG9ubHkgZG8gaXQgaWYgd2UgYWN0dWFsbHkgbmVlZCB0byBvcHRpbWl6ZSB0aGlzXG4gICAgICAgIHZhciByb3dPckNvbENhcCA9IGNhcGl0YWxpemUocm93T3JDb2wpO1xuICAgICAgICB2YXIgdmlld01heCA9IHZpZXdQb3J0W3Jvd09yQ29sICsgJ3MnXTtcbiAgICAgICAgdmFyIHRvVmlydHVhbCA9IHZpZXdQb3J0Wyd0b1ZpcnR1YWwnICsgcm93T3JDb2xDYXBdO1xuICAgICAgICB2YXIgbGVuZ3RoRm4gPSBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbFtoZWlnaHRPcldpZHRoXTtcbiAgICAgICAgdmFyIHN1bW1lZExlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld01heDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmlydHVhbCA9IHRvVmlydHVhbChpKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhGbih2aXJ0dWFsKTtcbiAgICAgICAgICAgIHZhciBuZXdTdW0gPSBzdW1tZWRMZW5ndGggKyBsZW5ndGg7XG4gICAgICAgICAgICBpZiAobmV3U3VtID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZpcnR1YWwgPyB2aXJ0dWFsIDogaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bW1lZExlbmd0aCA9IG5ld1N1bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHZpZXdQb3J0LmdldFZpcnR1YWxSb3dCeVRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcbiAgICAgICAgcmV0dXJuIGdldFJvd09yQ29sRnJvbVBvc2l0aW9uKHRvcCwgJ3JvdycsICdoZWlnaHQnLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmlld1BvcnQuZ2V0VmlydHVhbENvbEJ5TGVmdCA9IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgIHJldHVybiBnZXRSb3dPckNvbEZyb21Qb3NpdGlvbihsZWZ0LCAnY29sJywgJ3dpZHRoJywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmdldFJvd0J5VG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICByZXR1cm4gZ2V0Um93T3JDb2xGcm9tUG9zaXRpb24odG9wLCAncm93JywgJ2hlaWdodCcpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC5nZXRDb2xCeUxlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICByZXR1cm4gZ2V0Um93T3JDb2xGcm9tUG9zaXRpb24obGVmdCwgJ2NvbCcsICd3aWR0aCcpO1xuICAgIH07XG5cbiAgICB2aWV3UG9ydC5nZXRSb3dIZWlnaHQgPSBmdW5jdGlvbiAodmlld1BvcnRSb3cpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQudmlydHVhbFBpeGVsQ2VsbE1vZGVsLmhlaWdodCh2aWV3UG9ydC50b1ZpcnR1YWxSb3codmlld1BvcnQuY2xhbXBSb3codmlld1BvcnRSb3cpKSk7XG4gICAgfTtcblxuICAgIHZpZXdQb3J0LmdldENvbFdpZHRoID0gZnVuY3Rpb24gKHZpZXdQb3J0Q29sKSB7XG4gICAgICAgIHJldHVybiBncmlkLnZpcnR1YWxQaXhlbENlbGxNb2RlbC53aWR0aCh2aWV3UG9ydC50b1ZpcnR1YWxDb2wodmlld1BvcnQuY2xhbXBDb2wodmlld1BvcnRDb2wpKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGludGVyc2VjdFJvd3NPckNvbHMoaW50ZXJzZWN0aW9uLCByYW5nZSwgdG9wT3JMZWZ0LCByb3dPckNvbCwgaGVpZ2h0T3JXaWR0aCkge1xuICAgICAgICB2YXIgbnVtRml4ZWQgPSBmaXhlZFtyb3dPckNvbCArICdzJ107XG4gICAgICAgIHZhciBmaXhlZFJhbmdlID0gWzAsIG51bUZpeGVkXTtcblxuICAgICAgICB2YXIgdmlydHVhbFJhbmdlID0gW3JhbmdlW3RvcE9yTGVmdF0sIHJhbmdlW2hlaWdodE9yV2lkdGhdXTtcbiAgICAgICAgdmFyIGZpeGVkSW50ZXJzZWN0aW9uID0gcmFuZ2VVdGlsLmludGVyc2VjdChmaXhlZFJhbmdlLCB2aXJ0dWFsUmFuZ2UpO1xuICAgICAgICB2YXIgc2Nyb2xsUmFuZ2UgPSBbbnVtRml4ZWQsIHZpZXdQb3J0W3Jvd09yQ29sICsgJ3MnXSAtIG51bUZpeGVkXTtcbiAgICAgICAgdmlydHVhbFJhbmdlWzBdIC09IGdyaWQuY2VsbFNjcm9sbE1vZGVsW3Jvd09yQ29sXTtcbiAgICAgICAgdmFyIHNjcm9sbEludGVyc2VjdGlvbiA9IHJhbmdlVXRpbC5pbnRlcnNlY3Qoc2Nyb2xsUmFuZ2UsIHZpcnR1YWxSYW5nZSk7XG4gICAgICAgIHZhciByZXN1bHRSYW5nZSA9IHJhbmdlVXRpbC51bmlvbihmaXhlZEludGVyc2VjdGlvbiwgc2Nyb2xsSW50ZXJzZWN0aW9uKTtcbiAgICAgICAgaWYgKCFyZXN1bHRSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcnNlY3Rpb25bdG9wT3JMZWZ0XSA9IHJlc3VsdFJhbmdlWzBdO1xuICAgICAgICBpbnRlcnNlY3Rpb25baGVpZ2h0T3JXaWR0aF0gPSByZXN1bHRSYW5nZVsxXTtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICB9XG5cbiAgICB2aWV3UG9ydC5pbnRlcnNlY3QgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgLy9hc3N1bWUgdmlydHVhbCBjZWxscyBmb3Igbm93XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSb3dzT3JDb2xzKHt9LCByYW5nZSwgJ3RvcCcsICdyb3cnLCAnaGVpZ2h0Jyk7XG4gICAgICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0Um93c09yQ29scyhpbnRlcnNlY3Rpb24sIHJhbmdlLCAnbGVmdCcsICdjb2wnLCAnd2lkdGgnKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVNYXhMZW5ndGhzKHRvdGFsTGVuZ3RoLCBsZW5ndGhNb2RlbCkge1xuICAgICAgICB2YXIgbGVuZ3RoTWV0aG9kID0gbGVuZ3RoTW9kZWwud2lkdGggJiYgZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwud2lkdGggfHwgZ3JpZC52aXJ0dWFsUGl4ZWxDZWxsTW9kZWwuaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtRml4ZWQgPSBsZW5ndGhNb2RlbC5udW1GaXhlZCgpO1xuICAgICAgICB2YXIgd2luZG93TGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG1heFNpemUgPSAwO1xuICAgICAgICB2YXIgZml4ZWRMZW5ndGggPSAwO1xuICAgICAgICB2YXIgd2luZG93U3RhcnRJbmRleCA9IG51bUZpeGVkO1xuXG4gICAgICAgIGZvciAodmFyIGZpeGVkID0gMDsgZml4ZWQgPCBudW1GaXhlZDsgZml4ZWQrKykge1xuICAgICAgICAgICAgZml4ZWRMZW5ndGggKz0gbGVuZ3RoTWV0aG9kKGZpeGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaXQgbWlnaHQgYmUgc2FmZXIgdG8gYWN0dWFsbHkgc3VtIHRoZSBsZW5ndGhzIGluIHRoZSB2aXJ0dWFsUGl4ZWxDZWxsTW9kZWwgYnV0IGZvciBub3cgaGVyZSBpcyBva1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IG51bUZpeGVkOyBpbmRleCA8IGxlbmd0aE1vZGVsLmxlbmd0aCh0cnVlKTsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aE9mSWluZGV4ID0gbGVuZ3RoTWV0aG9kKGluZGV4KTtcbiAgICAgICAgICAgIHdpbmRvd0xlbmd0aCArPSBsZW5ndGhPZklpbmRleDtcbiAgICAgICAgICAgIHdoaWxlICh3aW5kb3dMZW5ndGggKyBmaXhlZExlbmd0aCA+IHRvdGFsTGVuZ3RoICYmIHdpbmRvd1N0YXJ0SW5kZXggPCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0xlbmd0aCAtPSBsZW5ndGhNZXRob2Qod2luZG93U3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgd2luZG93U3RhcnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdpbmRvd1NpemUgPSBpbmRleCAtIHdpbmRvd1N0YXJ0SW5kZXggKyAxOyAvLyBhZGQgdGhlIG9uZSBiZWNhdXNlIHdlIHdhbnQgdGhlIGxhc3QgaW5kZXggdGhhdCBkaWRuJ3QgZml0XG4gICAgICAgICAgICBpZiAod2luZG93U2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICBtYXhTaXplID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhTaXplICsgbnVtRml4ZWQgKyAxO1xuICAgIH1cblxuXG4gICAgdmlld1BvcnQuaXRlcmF0ZUNlbGxzID0gZnVuY3Rpb24gKGNlbGxGbiwgb3B0aW9uYWxSb3dGbiwgb3B0aW9uYWxNYXhSb3csIG9wdGlvbmFsTWF4Q29sKSB7XG4gICAgICAgIG9wdGlvbmFsTWF4Um93ID0gb3B0aW9uYWxNYXhSb3cgfHwgSW5maW5pdHk7XG4gICAgICAgIG9wdGlvbmFsTWF4Q29sID0gb3B0aW9uYWxNYXhDb2wgfHwgSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgTWF0aC5taW4odmlld1BvcnQucm93cywgb3B0aW9uYWxNYXhSb3cpOyByKyspIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25hbFJvd0ZuKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxSb3dGbihyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZWxsRm4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IE1hdGgubWluKHZpZXdQb3J0LmNvbHMsIG9wdGlvbmFsTWF4Q29sKTsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxGbihyLCBjKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdmlld1BvcnQ7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9ncmlkKSB7XG4gICAgdmFyIGdyaWQgPSBfZ3JpZDtcbiAgICB2YXIgbW9kZWwgPSB7fTtcblxuICAgIC8vYWxsIHBpeGVscyBhcmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgdmlydHVhbCB3b3JsZCwgbm8gcmVhbCB3b3JsZCBwaXhlbHMgYXJlIGRlYWx0IHdpdGggaGVyZSA6KVxuICAgIG1vZGVsLmdldFJvdyA9IGZ1bmN0aW9uICh0b3BQeCkge1xuICAgICAgICBpZiAodG9wUHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW1MZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGdyaWQucm93TW9kZWwubGVuZ3RoKHRydWUpOyByKyspIHtcbiAgICAgICAgICAgIHN1bUxlbmd0aCArPSBncmlkLnJvd01vZGVsLmhlaWdodChyKTtcbiAgICAgICAgICAgIGlmICh0b3BQeCA8IHN1bUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfTtcblxuICAgIC8veWVzIHRoZXNlIGFyZSB2ZXJ5IHNpbWlsYXIgYnV0IHRoZXJlIHdpbGwgYmUgZGlmZmVyZW5jZXNcbiAgICBtb2RlbC5nZXRDb2wgPSBmdW5jdGlvbiAobGVmdFB4KSB7XG4gICAgICAgIGlmIChsZWZ0UHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW1MZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGdyaWQuY29sTW9kZWwubGVuZ3RoKHRydWUpOyBjKyspIHtcbiAgICAgICAgICAgIHN1bUxlbmd0aCArPSBncmlkLmNvbE1vZGVsLndpZHRoKGMpO1xuICAgICAgICAgICAgaWYgKGxlZnRQeCA8IHN1bUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gY2xhbXBSb3dPckNvbCh2aXJ0dWFsUm93Q29sLCByb3dPckNvbCkge1xuICAgICAgICB2YXIgbWF4Um93Q29sID0gZ3JpZFtyb3dPckNvbCArICdNb2RlbCddLmxlbmd0aCh0cnVlKSAtIDE7XG4gICAgICAgIHJldHVybiB1dGlsLmNsYW1wKHZpcnR1YWxSb3dDb2wsIDAsIG1heFJvd0NvbCk7XG4gICAgfVxuXG4gICAgbW9kZWwuY2xhbXBSb3cgPSBmdW5jdGlvbiAodmlydHVhbFJvdykge1xuICAgICAgICByZXR1cm4gY2xhbXBSb3dPckNvbCh2aXJ0dWFsUm93LCAncm93Jyk7XG4gICAgfTtcblxuICAgIG1vZGVsLmNsYW1wQ29sID0gZnVuY3Rpb24gKHZpcnR1YWxDb2wpIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wUm93T3JDb2wodmlydHVhbENvbCwgJ2NvbCcpO1xuICAgIH07XG5cbiAgICAvL2ZvciBub3cgdGhlc2UganVzdCBjYWxsIHRocm91Z2ggdG8gdGhlIHJvdyBhbmQgY29sdW1uIG1vZGVsLCBidXQgdmVyeSBsaWtlbHkgaXQgd2lsbCBuZWVkIHRvIGluY2x1ZGUgc29tZSBvdGhlciBjYWxjdWxhdGlvbnNcbiAgICBtb2RlbC5oZWlnaHQgPSBmdW5jdGlvbiAodmlydHVhbFJvd1N0YXJ0LCB2aXJ0dWFsUm93RW5kKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHRPcldpZHRoKHZpcnR1YWxSb3dTdGFydCwgdmlydHVhbFJvd0VuZCwgJ3JvdycpO1xuICAgIH07XG5cbiAgICBtb2RlbC53aWR0aCA9IGZ1bmN0aW9uICh2aXJ0dWFsQ29sU3RhcnQsIHZpcnR1YWxDb2xFbmQpIHtcbiAgICAgICAgcmV0dXJuIGhlaWdodE9yV2lkdGgodmlydHVhbENvbFN0YXJ0LCB2aXJ0dWFsQ29sRW5kLCAnY29sJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhlaWdodE9yV2lkdGgoc3RhcnQsIGVuZCwgcm93T3JDb2wpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZW5kID0gdXRpbC5pc051bWJlcihlbmQpID8gZW5kIDogc3RhcnQ7XG4gICAgICAgIGVuZCA9IGNsYW1wUm93T3JDb2woZW5kLCByb3dPckNvbCk7XG4gICAgICAgIHN0YXJ0ID0gY2xhbXBSb3dPckNvbChzdGFydCwgcm93T3JDb2wpO1xuICAgICAgICB2YXIgbGVuZ3RoTW9kZWwgPSBncmlkW3Jvd09yQ29sICsgJ01vZGVsJ107XG4gICAgICAgIHZhciBsZW5ndGhGbiA9IGxlbmd0aE1vZGVsLndpZHRoIHx8IGxlbmd0aE1vZGVsLmhlaWdodDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gbGVuZ3RoRm4oaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG5cbiAgICBtb2RlbC50b3RhbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmhlaWdodCgwLCBncmlkLnJvd01vZGVsLmxlbmd0aCh0cnVlKSAtIDEpO1xuICAgIH07XG5cbiAgICBtb2RlbC50b3RhbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9kZWwud2lkdGgoMCwgZ3JpZC5jb2xNb2RlbC5sZW5ndGgodHJ1ZSkgLSAxKTtcbiAgICB9O1xuXG4gICAgbW9kZWwuZml4ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5oZWlnaHQoMCwgZ3JpZC5yb3dNb2RlbC5udW1GaXhlZCgpIC0gMSk7XG4gICAgfTtcblxuICAgIG1vZGVsLmZpeGVkV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC53aWR0aCgwLCBncmlkLmNvbE1vZGVsLm51bUZpeGVkKCkgLSAxKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2l6ZUNoYW5nZUxpc3RlbmVyKCkge1xuICAgICAgICAvL2ZvciBub3cgd2UgZG9uJ3QgY2FjaGUgYW55dGhpbmcgYWJvdXQgdGhpcyBzbyB3ZSBqdXN0IG5vdGlmeVxuICAgICAgICBncmlkLmV2ZW50TG9vcC5maXJlKCdncmlkLXZpcnR1YWwtcGl4ZWwtY2VsbC1jaGFuZ2UnKTtcbiAgICB9XG5cbiAgICBncmlkLmV2ZW50TG9vcC5iaW5kKCdncmlkLWNvbC1jaGFuZ2UnLCBzaXplQ2hhbmdlTGlzdGVuZXIpO1xuICAgIGdyaWQuZXZlbnRMb29wLmJpbmQoJ2dyaWQtcm93LWNoYW5nZScsIHNpemVDaGFuZ2VMaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gbW9kZWw7XG59OyJdfQ==
